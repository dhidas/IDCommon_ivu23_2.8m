; --------------------------------------
; BNL 2.8m IVU
;	Version 0.01	: Initial release
;	              Å¶modified 1.5m(Ver1.33)
;			0.03	: GAP axis move & synchronous move->individual correction move
;					: Axis position error is based on upper beam (upstream and downstream) and lower beam (upstream and downstream).
;					: not check Upstream ( upper axis and lower axis) and downstream (upper axis and lower axis).
;					: Å¶Because height direction can not be calculated.
;			0.031	: Individual move
;					: Below functions are unchecked
;					: 	GAP evacuation, home-position evacuation, JACK-UP move,
;					:	stop by limit switch input,
;					:	limit motor move by software limit.
;			0.032	: JACK-UP move
;			0.033	: Position limit LS setting
;			0.034	: Add checking of KILL-LS during JACK-UP move and GAP move.
;			1.000	: HOME-POSITION evacuation
;					:	HOME-POSITION evacuation processing
;					:		(1)When HOME-LS is detected
;					:			OPEN direction set value move -> CLOSE direction move ->detects HOME-LS and stops
;					:		(2)When HOME-LS is not detected
;					:			CLOSE direction JOG move -> detects HOME-LS and stops -> processes (1)
;					:		After HOME-LS move, move axes which do not detect HOME-LS by 8um.
;					:		Stop axes which detect HOME-LS.
;					:		If HOME-LS is not detected, continue move 8um
;					:		After finished, BRICK does not change OFFSET value.
;			1.001	: Because a vibration occurred(noise), review the PID Proportional Gain (Ixx30).
;			1.002	: Add following check point to confirm PLC1,PLC2 - PLC7 processing.
;					:	P8000 = PLC1 start counter
;					:	P8001 = FREAD start counter
;					:	P8002 = M4000 reference address, start setting counter
;					:	P8003 = M4000 reference address, start setting counter
;					:	P8004 = M5280 setting times counter
;					:	P8005 = PLCxx ENABLE setting times counter
;					:	P8006 = I5 check setting configuration counter
;					:	P8007 = PLC2Å`PLC7 ENABLE setting counter
;					:	P8008 = PLC1 DISABLE setting counter
;					:	P8009 = PLC1 end counter
;					:	P8010 = PLC2 start counter
;			1.003	: Reduce timer in PLC1
;					: Add I variable setting of synchronous mode at start ofPLC1, .
;			1.004	: Review individual move of HOME evacuation function. (2014/05/01:still working & unchecked)
;					: Add sequence counter in PLC2. (to check if it starts from upper layer)
;					:	P8011 = PLC2 sequence counter
;			1.1		: Add initial reference address setting which starts from M4000.
;					: Using IOC autosave module,
;					: delete data save command in Brick (do not execute SAVE command)
;					: Processing summary)
;					:	Request initial data (M4498[P1498]=1) to IOC 
;					:	Confirm response data put (M4497[P1497]=-1) from IOC
;					:	Set initial data request finish  (M4496[P1496]=1) to IOC
;					:	getting initial data, SPEED, OFFSET and EVACUATION-ENABLE/DISABLE
;					: Correct processing When Individual move and detecting #4:CLOSE-KILL
;			1.11	: Add HOME evacuation individual axis stop & beacon output.
;			1.12	: Add GAP command position and JACK command position get register.
;					:	P1494[M4494] JACK command position (absolute position)
;					:	P1495[M4495] GAP command positon (absolute position)
;					:	Å¶use to correct Vertical Offset position error
;			1.13	: Review upper and lower beam position error,  and individual move velocity in correction move.
;					:	Å¶measure to adding spring in order to newly limit move in mechanical system.
;					:    reflect PLC7
;					:	  velocity:0.1Å®0.5 position error value:+/-5umÅ®+/-30um
;			1.14	: Measure against alarm clear not working from IOC
;					:	  sometimes, setting M33-M36 0 from 1 does not work
;			1.153	: Abort processing and alarm clear processing before move command when following error occurs.
;					:	  use below status of coordinate system 1 to confirm
;					:		M5188(Warning Following Error)
;					:		M5189(Fatal Following Error)
;					:		M5190(Amp Fault)
;					:	  review end check of number of retry of correction processing
;					:	  review correction value calculation (calculate from set GAP and Vertical Offset position)
;			1.154	: GAP_CLOSE_KILL processing (2014/09/15:unchecked)
;			1.2		: Recovery processing of motor amplifier error (Err12.0)
;			1.21	: Add variables initialization by following error checking
;					: Save GAP setpoint and JACK setpoint of correction move when move command is issued
;					: Judge move command retry by IOC retry bit (0x0040)
;			1.22	: Review processing of fault processing
;			1.3		: Setting default value of each OFFSET, velocity, and GAP evacuation enable/disable.
;					: Å¶define #1 and #2 individually
;			1.31	: Measure of receiving a stop command against an axis which is not moving
;					: Add initialization of inside variables when abort occurs
;					: Add checking position error during Vertical-Offset move (10um)
;					: Processing to receive Kill & Abort command from IOC
;			1.32	: Review HOME function
;			1.4		: Add skew compensation table
;					: 	I51=1:compensation enable I51=0:compensation disable
;					:	Only when GAP move position setting, I51=1
;					:	Clear Mxx69 compensation value by zero when I51 is set 0 from 1.
;					:	Do not use compensation (disable) on Other GAP move, correction move, GAP evacuation and HOME function 
;					:	Add registers to update scan of compensation table from upper layer PC.
;			1.41	: Deter individual correction move when compensation is disable (P1480[=M4480]=1).
;					:	Å¶Because linear scale direction does not correspond to motor move direction.
;					:	 take measure by using compensation table
;					:	M962 is GAP POSITION[unit=nm]
;					:	M1462 is VERTICAL OFFSET[unit=nm]
;			1.42	: Add checking consistency of position data before move command.
;			1.43	: Review stop command 
;			1.431	: Add Timer(at line no=8213,8434)
;			1.44	: Add Remedy for stack
;					:	Make real axis position correspond to virtual axis position at changing the mode between separate mode and synchronous mode
;			1.45	: Correct Ready register processing, and timing of adjstment and brake.
; --------------------------------------
;	Note
;		GAP axis move value is GAP axis total move value
;		Therefor use it as BRICK command value when GAP move. 
;		Make sure that M register variables are not rewritten by IOC
; --------------------------------------
; #define		BNL28_VER		0.01		; Version No.[2014/01/20(Hitz)]
; #define		BNL28_VER		0.02		; Version No.[2014/03/16(NXE)]
; #define		BNL28_VER		0.03		; Version No.[2014/03/18(NXE)]
; #define		BNL28_VER		0.031		; Version No.[2014/03/22(NXE)]
; #define		BNL28_VER		0.032		; Version No.[2014/03/26(Hitz)]
; #define		BNL28_VER		0.033		; Version No.[2014/04/01(NXE)]
; #define		BNL28_VER		0.034		; Version No.[2014/04/02(NXE)]
; #define		BNL28_VER		1.000		; Version No.[2014/04/21(NXE)]
; #define		BNL28_VER		1.001		; Version No.[2014/04/23(NXE)]
; #define		BNL28_VER		1.002		; Version No.[2014/04/30(NXE)] <- PLC1 is ENABLE state
; #define		BNL28_VER		1.003		; Version No.[2014/04/30(NXE)]
; #define		BNL28_VER		1.004		; Version No.[2014/05/01(NXE)]
; #define		BNL28_VER		1.1			; Version No.[2014/05/27(NXE)]
; #define		BNL28_VER		1.11		; Version No.[2014/05/28(NXE)]
; #define		BNL28_VER		1.12		; Version No.[2014/05/29(NXE)]
; #define		BNL28_VER		1.13		; Version No.[2014/09/12(Hitz)]
; #define		BNL28_VER		1.14		; Version No.[2014/09/13(NXE)]
; #define		BNL28_VER		1.153		; Version No.[2014/09/15(NXE)]
; #define		BNL28_VER		1.154		; Version No.[2014/09/15(NXE)]
; #define		BNL28_VER		1.2			; Version No.[2014/09/26(NXE)]
; #define		BNL28_VER		1.21		; Version No.[2014/09/28(NXE)]
; #define		BNL28_VER		1.22		; Version No.[2014/09/29(Hitz)]
; #define		BNL28_VER		1.3			; Version No.[2014/10/13(BNL)]
; #define		BNL28_VER		1.31		; Version No.[2014/10/20(BNL)]
; #define		BNL28_VER		1.32		; Version No.[2014/10/23(BNL)]
; #define		BNL28_VER		1.4			; Version No.[2014/11/20(NXE)]
; #define		BNL28_VER		1.41		; Version No.[2014/11/25(NXE)]
; #define		BNL28_VER		1.42		; Version No.[2014/11/26(NXE)]
; #define		BNL28_VER		1.43		; Version No.[2014/12/17(NXE)]
; #define		BNL28_VER		1.431		; Version No.[2015/04/04(Hitz)]
; #define		BNL28_VER		1.44			; Version No.[2015/05/29(Hitz)]
#define		BNL28_VER		1.45			; Version No.[2015/06/19(Hitz)]


#define		VER_P_REG		P300		; Version register


; --------------------------------------
; Condition compile
; --------------------------------------
; #define		FSAVE_MODE				; Velocity, OFFSET value save data use
; #define		UPPER_MODE				; GAP upper phase axis uses
; #define		LOWER_MODE				; GAP lower phase axis uses
; #define		ALL_MODE				; GAP upper and lower phase axis use

; #define		DEVIATION_MODE			; Deviation fault processing (for 2.8m)
; #define		ADJUST_MODE				; Position correction processing (for 2.8m)

; #define		DEBUG_MODE				; for debug


; --------------------------------------
; Constant setting
; --------------------------------------
#define		STOP_AXIS			0		; Axis stops
#define		MOVE_AXIS			1		; Axis is moving

#define		NO__DIR				0		; Move direction is not set
#define		CW__DIR				1		; Move of CW direction
#define		CCW_DIR				2		; Move of CCW direction

#define		AMP_FAULT			1		; servo amplifier fault (M-reg Val)
#define		AMP_NORMAL			0		; servo amplifier normal (M-reg Val)

#define		OPEN__MODE			1		; Open-Loop Mode(M-reg Val)
#define		CLOSE_MODE			0		; Close-Loop Mode(M-reg Val)

#define		DVI_FAULT			1		; Position deviation fault (M-reg Val)
#define		DVI_ERROR			0		; Position deviation error
#define		DVI_NORMAL			1		; Position deviation normal

#define		SYS_INTLCK			0		; System is interlock state
#define		SYS_NORMAL			1		; System is normal

#define		EMERGENCY_STOP		0		; EMERGENCY-STOP button status =pushed (J6_IN1_7)

#define		PROG_RUN_STAT		1		; Motion program is running
#define		PROG_STP_STAT		0		; Motion program has stopped


#define		SERVO_RDY__ON		1		;  Servo-Ready ON
#define		SERVO_RDY_OFF		0		;  Servo-Ready OFF


#define		BISS_TMOUT			1		; BiSS-C time-out
#define		BISS_CRCER			1		; BiSS-C CRC check sum error
#define		BISS_ERROR			0		; BiSS-C fault
#define		BISS_NORMAL			1		; BiSS-C normal


#define		MOT_SCALE_CNV		1000000		; Multiplier of move value receiving from IOC (áo->nm)
#define		JACK_SCALE_CNV		1000000		; Multiplier of move value receiving from IOC (mm->nm)

#define		MOT_SPD_CNV			1000		; Factor of conversion velocity from IOC (áo/sec->ct/msec)
#define		JACK_SPD_CNV		1000		; Factor of conversion velocity from IOC (áo/sec->ct/msec)

#define		RETRY_CNT			0			; Number of position calculation retry
#define		MOT_LIN_ROT_CNV		1.00		; Linear -> rotary conversion factor (ct)[for GAP]
#define		JCK_LIN_ROT_CNV		1.00		; Linear -> rotary conversion factor (ct)[for JACK]

#define		GAP_1_OFFSET		0.0000		; GAP(#1) base position offset (mm)
#define		GAP_2_OFFSET		0.0000		; GAP(#2) base position offset (mm)
#define		GAP_3_OFFSET		0.0000		; GAP(#3) base position offset (mm)
#define		GAP_4_OFFSET		0.0000		; GAP(#4) base position offset (mm)


#define		MNT_DEVIATION		50000		; Position deviation permissible value (50000 cts:need review)
#define		SYS_DEVIATION		20000		; Position deviation permissible value (20000 cts:need review)
#define		ADJ_DEVIATION		10000		; Position deviation permissible value (10000 cts:need review)

#define		SEL_SPD_SLOW		1
#define		SEL_SPD_MIDL		2
#define		SEL_SPD_HIGH		3


#define		BEACON_ON			1			; warning beacon is on-status
#define		BEACON_OFF			0			; warning beacon is off-status
#define		CLEAR_ON			1			; Alarm-Clear on
#define		CLEAR_OFF			0			; Alarm-Clear off
#define		LIMIT_ON			1			; Limit Switch is on-status
#define		LIMIT_OFF			0			; Limit Switch is off-status

#define		LOCK_OCCUR			1			; Servo lock Occur
#define		UNLOCK_OCCUR		0			; Servo lock not Occur

#define		USR_MODE			0			; Identifier of user mode
#define		ENG_MODE			1			; Identifier of engineering mode
#define		MNT_MODE			2			; Identifier of maintenance mode
#define		SPA_MODE			3			; Identifier of maintenance mode (individual move)

; --------------------------------------
;	Pxx register variable definition
; --------------------------------------
; ------------------
; Common variables
; ------------------
#define		IOC_CHG_MODE_REG		P1000	; Change run mode
#define		ACTIVE_MODE_REG			P1001	; Run mode

#define		INITIALIZE_REG			P1003	; Initialization end
#define		DEVIATION_STAT_REG		P1004	; Position deviation
#define		SYS_INTLCK_REG			P1005	; Interlock state (consistency fault)
#define		BISS_STAT_REG			P1006	; BiSS-C status


#define		LOCK_1_STAT_REG			P0		; Servo lock issue state
#define		LOCK_2_STAT_REG			P1		; Servo lock issue state
#define		LOCK_3_STAT_REG			P2		; Servo lock issue state
#define		LOCK_4_STAT_REG			P3		; Servo lock issue state

#define		DEVIATION_VAL_REG		P10		; Position deviation maximum limit value

#define		FSAVE_CMD_REG			P12		; FSAVE execution flag

#define		EMERGENCY_STAT_REG		P14		; EMERGENCY-STOP status

#define		BISS_INIT_REG			P20		; BISS initialization setting status


#define		PRG_EXEC_POS			1		; Relative position move
#define		PRG_EXEC_JOG			2		; JOG move

#define		HOME_EXEC_0				0		; Initial state
#define		HOME_EXEC_1				1		; CLOSE direction high speed move [JOG]
#define		HOME_EXEC_2				2		; OPEN direction set value and low speed move [REF]
#define		HOME_EXEC_3				3		; CLOSE direction low speed move [JOG]
#define		HOME_EXEC_4				4		; 
#define		HOME_EXEC_5				5		; 
#define		HOME_EXEC_6				6		; 
#define		HOME_EXEC_7				7		; 
#define		HOME_FIX_DRV			20000	; 0.02mm(=20um=20000nm) move
#define		HOME_ADJ_DRV			6000	; 0.006mm(=6um=6000nm) move

#define		PRG_EXEC_REG			P70		; Axis move execution flag by motion program
#define		REF_POS_REG				P71		; relative move value
#define		ABS_POS_REG				P72		; Absolute position
#define		GAP_UPLIMIT_REG			P73		; GAP axis maximum software limit [for 1.5m]
#define		GAP_DNLIMIT_REG			P74		; GAP axis minimum software limit [for 1.5m]
#define		HOME_DRV_STG_REG		P75		; GAP axis HOME POSITION move status
#define		HOME_DRV_DIS_REG		P76		; GAP axis HOME POSITION move distance
#define		HOME_DRV_PRG_REG		P77		; GAP axis HOME POSITION move program (synchronous)
#define		HOME_ADJ_PRG_REG		P78		; GAP axis HOME POSITION move program (individual axis)


#define		TMP1_REG				P80		; Variable for work
#define		TMP2_REG				P81		; Variable for work
#define		TMP3_REG				P82		; Variable for work
#define		TMP4_REG				P83		; Variable for work
#define		TMP5_REG				P84		; Variable for work

#define		TMP6_REG				P85		; Variable for work
#define		TMP7_REG				P86		; Variable for work
#define		TMP8_REG				P87		; Variable for work
#define		TMP9_REG				P88		; Variable for work
#define		TMP10_REG				P89		; Variable for work
#define		TMP11_REG				P90		; Variable for work	; Add 2013/10/15(for Jog-Drive)
#define		TMP12_REG				P91		; Variable for work	; Add 2013/10/15(for Jog-Drive)
#define		TMP13_REG				P92		; Variable for work	; Add 2013/10/15(for Jog[+]-Drive)
#define		TMP14_REG				P93		; Variable for work	; Add 2013/10/15(for Jog[-]-Drive)
#define		TMP15_REG				P94		; Variable for work	; Add 2013/10/15(for GAPEva-Drive)
#define		TMP16_REG				P95		; Variable for work	; Add 2014/04/01

#define		GAP_1_MOV_REG			P100	; Variable for work
#define		GAP_1_JGP_REG			P101	; Variable for work
#define		GAP_1_JGM_REG			P102	; Variable for work
#define		GAP_1_STP_REG			P103	; Variable for work

#define		GAP_2_MOV_REG			P110	; Variable for work
#define		GAP_2_JGP_REG			P111	; Variable for work
#define		GAP_2_JGM_REG			P112	; Variable for work
#define		GAP_2_STP_REG			P113	; Variable for work

#define		GAP_3_MOV_REG			P120	; Variable for work
#define		GAP_3_JGP_REG			P121	; Variable for work
#define		GAP_3_JGM_REG			P122	; Variable for work
#define		GAP_3_STP_REG			P123	; Variable for work

#define		GAP_4_MOV_REG			P130	; Variable for work
#define		GAP_4_JGP_REG			P131	; Variable for work
#define		GAP_4_JGM_REG			P132	; Variable for work
#define		GAP_4_STP_REG			P133	; Variable for work


; ---------------------------------
; Add 2013.10.30(for separate mode)
; ---------------------------------
#define		GAP_5_MOV_REG			P140	; Variable for work
#define		GAP_5_JGP_REG			P141	; Variable for work
#define		GAP_5_JGM_REG			P142	; Variable for work
#define		GAP_5_STP_REG			P143	; Variable for work

#define		GAP_6_MOV_REG			P150	; Variable for work
#define		GAP_6_JGP_REG			P151	; Variable for work
#define		GAP_6_JGM_REG			P152	; Variable for work
#define		GAP_6_STP_REG			P153	; Variable for work

#define		GAP_7_MOV_REG			P160	; Variable for work
#define		GAP_7_JGP_REG			P161	; Variable for work
#define		GAP_7_JGM_REG			P162	; Variable for work
#define		GAP_7_STP_REG			P163	; Variable for work

#define		JCK_0_MOV_REG			P170	; Variable for work
#define		JCK_0_JGP_REG			P171	; Variable for work
#define		JCK_0_JGM_REG			P172	; Variable for work
#define		JCK_0_STP_REG			P173	; Variable for work

; #define		GAP_8_MOV_REG			P170	; Variable for work
; #define		GAP_8_JGP_REG			P171	; Variable for work
; #define		GAP_8_JGM_REG			P172	; Variable for work
; #define		GAP_8_STP_REG			P173	; Variable for work


; ----------------------------------
; Add 2013.11.13(for adjusting mode)
; ----------------------------------
#define		ADJ_RANGE_MAX			10000		; adjustable max range(10um=10000nm)
; #define		ADJ_RANGE_MIN			100			; adjustable min range(0.1um=100nm)
#define		ADJ_RANGE_MIN			200			; adjustable min range(0.1um=100nm)
; #define		ADJ_RETRY_MAX			10
#define		ADJ_RETRY_MAX			20
#define		FIN_RETRY_MAX			100			; Finish Counter
#define		VRT_RANGE_MAX			50000		; adjustable max range(50um=50000nm)

#define		ADJ_NORMAL				0
#define		ADJ_ERROR				1

#define		ADJ__START				1			; started adjusting mode
#define		ADJ_FINISH				0			; finished adjusting mode

#define		GAP_1_ADJ_DRV			$000001		; GAP[#1]
#define		GAP_2_ADJ_DRV			$000002		; GAP[#2]
#define		GAP_3_ADJ_DRV			$000004		; GAP[#3]
#define		GAP_4_ADJ_DRV			$000008		; GAP[#4]


#define		ADJ_DRIVE_REG			P600
#define		ADJ_STAT__REG			P601
#define		ADJ_MODE__REG			P602
#define		ADJ_COUNT_REG			P603
#define		ADJ_PREMD_REG			P604		; Last mode (Add:2013/12/04)
#define		FIN_COUNT_REG			P605		; Last move axis stop check counter
#define		ADJ_STOP__REG			P606		; Stop command acceptance register
#define		HLD_COUNT_REG			P607		; Stop check counter at JOG control
#define		ADJ_ERROR_REG			P608		; 10um-over judgment register

#define		GAP_0_ADJ_POS			P610		; GAP[#1-#4]
#define		GAP_1_ADJ_POS			P611		; GAP[#1]
#define		GAP_2_ADJ_POS			P612		; GAP[#2]
#define		GAP_3_ADJ_POS			P613		; GAP[#3]
#define		GAP_4_ADJ_POS			P614		; GAP[#4]
#define		ADJ_TMP_MAX_1			P615		; tmp(use PLC7 only)
#define		ADJ_TMP_MAX_2			P616		; tmp(use PLC7 only)
#define		ADJ_TMP_MIN_1			P617		; tmp(use PLC7 only)
#define		ADJ_TMP_MIN_2			P618		; tmp(use PLC7 only)

#define		GAP_UP_UP_VAL			P620		; GAP-UP-UP VAL
#define		GAP_DN_DN_VAL			P621		; GAP-DN-DN VAL
#define		GAP_UP_DN_VAL			P622		; GAP-UP-DN VAL
#define		GAP_DN_UP_VAL			P623		; GAP-DN-UP VAL

#define		ADJ_UP_AVE				P625		; tmp(use PLC7 only)
#define		ADJ_UP_DIV				P626		; tmp(use PLC7 only)

#define		ADJ_DN_AVE				P627		; tmp(use PLC7 only)
#define		ADJ_DN_DIV				P628		; tmp(use PLC7 only)

#define		DRIVE_MODE_REG			P630		; Axis move status register

#define		ADJ_FLLOW_REG			P635		; Deviation fault detection flag at correction move (Add:2014/09/28)

#define		VRT_UP_OFFSET_REG		P640		; Vertical Offset value [before GAP move command ] register (Add:2014/05/28)
#define		VRT_DN_OFFSET_REG		P641		; Vertical Offset value [before GAP move command ] register (Add:2014/05/28)
#define		VRT_AV_OFFSET_REG		P642		; Vertical Offset value [before GAP move command ] register (Add:2014/05/28)
#define		ADJ_VRT_UP_OF_REG		P645		; Vertical Offset value [after GAP move command ] register (Add:2014/05/28)
#define		ADJ_VRT_DN_OF_REG		P646		; Vertical Offset value [after GAP move command ] register (Add:2014/05/28)
#define		ADJ_VRT_AV_OF_REG		P647		; Vertical Offset value [after GAP move command ] register (Add:2014/05/28)
#define		ADJ_VRT_OFFST_REG		P648		; Vertical Offset value [Adjusting value] register (Add:2014/05/28)
#define		MEM_VRT_STPOS_REG		P649		; Vertical Offset value [Absolute position command value from IOC](Add:2014/05/28)
#define		MEM_GAP_STPOS_REG		P650		; GAP Position value [Absolute position command value from IOC](Add:2014/09/14)

; #define		ADJ_VRT_OFFST_MAX		5000		; Vertical Offset correction limit value
; #define		ADJ_VRT_OFFST_MIN		-5000		; Vertical Offset correction limit value
; #define		ADJ_GAP_OFFST_MAX		500			; GAP correction limit value (Rev:2014/09/12)
; #define		ADJ_GAP_OFFST_MIN		-500		; GAP correction limit value (Rev:2014/09/12)
#define		ADJ_VRT_OFFST_MAX		30000		; Vertical Offset correction limit value (Rev:2014/09/12)
#define		ADJ_VRT_OFFST_MIN		-30000		; Vertical Offset correction limit value (Rev:2014/09/12)
#define		ADJ_GAP_OFFST_MAX		200			; GAP correction limit value (Rev:2014/11/25)
#define		ADJ_GAP_OFFST_MIN		-200		; GAP correction limit value (Rev:2014/11/25)

; -----------------------------
#define		ALM_MT1_CLR_CNT_REG		P660		; Motor #1 alarm clear count (Add:2014/09/13)
#define		ALM_MT2_CLR_CNT_REG		P661		; Motor #2 alarm clear count (Add:2014/09/13)
#define		ALM_MT3_CLR_CNT_REG		P662		; Motor #3 alarm clear count (Add:2014/09/13)
#define		ALM_MT4_CLR_CNT_REG		P663		; Motor #4 alarm clear count (Add:2014/09/13)

#define		ALM_MT1_LST_STS_REG		P664		; Motor #1 alarm clear last status (Add:2014/09/13)
#define		ALM_MT2_LST_STS_REG		P665		; Motor #2 alarm clear last status (Add:2014/09/13)
#define		ALM_MT3_LST_STS_REG		P666		; Motor #3 alarm clear last status (Add:2014/09/13)
#define		ALM_MT4_LST_STS_REG		P667		; Motor #4 alarm clear last status (Add:2014/09/13)

#define		AMP_ALM_STS_REG			P670		; Motor amplifier alarm status (Add:2014/09/26)
#define		ALM_CLR_MAX_CNT			1000		; Alarm clear count maximum (Add:2014/09/13)
; -----------------------------

; --------------
; Add:2014/11/20
; Initialize in PLC1 (set disable)
; Communicate with EPICS-IOC by M4480[=P1480]
#define		COMP_SCAN_REG			P680		; Correction function use/unuse
#define		COMP_FLAG_REG			I51			; Skew compensation enable/disable [I register]
#define		COMP_01_VAL_REG			M169		;  #1 skew compensation amount [real axis]
#define		COMP_02_VAL_REG			M269		;  #2 skew compensation amount 
#define		COMP_03_VAL_REG			M369		;  #3 skew compensation amount 
#define		COMP_04_VAL_REG			M469		;  #4 skew compensation amount 
#define		COMP_17_VAL_REG			M1769		; #17 skew compensation amount [virtual axis]
#define		COMP_18_VAL_REG			M1869		; #18 skew compensation amount 
#define		COMP_20_VAL_REG			M2069		; #20 skew compensation amount 
#define		COMP_21_VAL_REG			M2169		; #21 skew compensation amount 
#define		COMP_SCAN_ENABLE		1			; Skew compensation table enable/unuse (Add:2014/11/20)
#define		COMP_SCAN_DISABLE		0			; Skew compensation table disable/use (Add:2014/11/20)
; Add:2014/11/20
; --------------


#define		DRIVE_STOP				0			; Axis move stop state
#define		GAP_DRIVE_MODE			1			; GAP move state
#define		JCK_DRIVE_MODE			2			; JACK-U move state
#define		HME_DRIVE_MODE			3			; GAP HOME position move state
#define		HOME_FAST_SPEED			250			; GAP axis home position move [high speed move](250ct/msec)
#define		HOME_MIDL_SPEED			5			; GAP axis home position move [middle speed move](5ct/msec)
#define		HOME_SLOW_SPEED			SPA_SPD		; GAP axis home position fine-tune move [low speed move](0.1ct/msec)


;
; M1=$00400
;
#define		M_Type					M3700
#define		M_Addr					M3701
#define		M_Type_a				M3702
#define		M_Addr_a				M3703

M_Type->X:$004FA0,0,24				; M4000 Address(X-register)
M_Addr->Y:$004FA0,0,24				; M4000 Address(Y-register)
M_Type_a->Y:$004E74,0,24			; M3700 Address
M_Addr_a->Y:$004E75,0,24			; M3701 Address


; ---------------------
; IOC <-> Brick
; range P1000 <-> P1499
; ---------------------
#define		IOC_RCV_RDY_REG			P1482		; ready flag for IOC[M4482](2015/06/18)
#define		RCV__READY_VAL			0			; ready
#define		RCV_NREADY_VAL			1			; not ready

#define		REQ_COMP_SCAN_REG		P1480	; Command to create skew compensation table from IOC	; Add:2014/11/20
#define		COMP_DISABLE__REG		P1481	; Command to create skew compensation table from IOC	; Add:2014/11/20

#define		REQ_IOC_KILL__REG		P1490	; Command to issue KILL command from IOC			; Add:2014/10/20
#define		REQ_IOC_ABORT_REG		P1491	; Command to issue ABORT command from IOC		; Add:2014/10/20

#define		REQ_JACK_RETRY_REG		P1492	; Vertical Offset move command retry count
#define		REQ_GAP__RETRY_REG		P1493	; GAP move command retry count
#define		REQ_VRT_ABSPOS_REG		P1494	; Vertical Offset move command value (absolute position)
#define		REQ_GAP_ABSPOS_REG		P1495	; GAP move command value (absolute position)

#define		REQ_INIT_END_REG		P1496	; Initial data request flag
#define		REQ_INIT_ANS_REG		P1497	; Initial data response flag
#define		REQ_INIT_REQ_REG		P1498	; Initial data request flag
#define		PMAC_SEQ_COUT_REG		P1499	; BRICK sequence-counter(on PLC2)
#define		IOC_GO_HOME_DRV_REG		P1403	; GAP axis HOME move command (#1-#4)
#define		IOC_SP_HOME_DRV_REG		P1404	; GAP axis HOME stop command (#1-#4)

#define		IOC_BRICK_RESET_REG		P1409	; BRICK-Controller software reset


#define		IOC_GAP_LIM_UP_REG		P1416	; GAP axis software limit [maximum value](#1-#4)
#define		IOC_GAP_LIM_DN_REG		P1426	; GAP axis software limit [minimum value](#1-#4)
#define		IOC_JCK_LIM_UP_REG		P1417	; JACK axis software limit [maximum value](#1-#4)
#define		IOC_JCK_LIM_DN_REG		P1427	; JACK axis software limit [minimum value](#1-#4)
#define		IOC_MOT_LIM_UP_REG		P1418	; Motor software limit [maximum value](#1-#4)
#define		IOC_MOT_LIM_DN_REG		P1428	; Motor software limit [minimum value](#1-#4)


#define		IOC_JCK_0_DRV_REG		P1010	; JACK move command (#1-#4)
#define		IOC_GAP_1_DRV_REG		P1020	; GAP move command (#1-#4)
#define		IOC_GAP_2_DRV_REG		P1030	; GAP move command (#1-#2)
#define		IOC_GAP_3_DRV_REG		P1040	; GAP move command (#3-#4)
#define		IOC_GAP_4_DRV_REG		P1050	; GAP move command (#1)
#define		IOC_GAP_5_DRV_REG		P1060	; GAP move command (#2)
#define		IOC_GAP_6_DRV_REG		P1070	; GAP move command (#3)
#define		IOC_GAP_7_DRV_REG		P1080	; GAP move command (#4)


#define		IOC_JCK_0_STP_REG		P1011	; JACK stop command (#1-#4)
#define		IOC_GAP_1_STP_REG		P1021	; GAP stop command (#1-#4)
#define		IOC_GAP_2_STP_REG		P1031	; GAP stop command (#1-#2)
#define		IOC_GAP_3_STP_REG		P1041	; GAP stop command (#3-#4)
#define		IOC_GAP_4_STP_REG		P1051	; GAP stop command (#1)
#define		IOC_GAP_5_STP_REG		P1061	; GAP stop command (#2)
#define		IOC_GAP_6_STP_REG		P1071	; GAP stop command (#3)
#define		IOC_GAP_7_STP_REG		P1081	; GAP stop command (#4)


#define		IOC_JCK_0_JGP_REG		P1014	; JACK move JOG[+] command (#1-#4)
#define		IOC_GAP_1_JGP_REG		P1024	; GAP move JOG[+] command (#1-#4)
#define		IOC_GAP_2_JGP_REG		P1034	; GAP move JOG[+] command (#1-#2)
#define		IOC_GAP_3_JGP_REG		P1044	; GAP move JOG[+] command (#3-#4)
#define		IOC_GAP_4_JGP_REG		P1054	; GAP move JOG[+] command (#1)
#define		IOC_GAP_5_JGP_REG		P1064	; GAP move JOG[+] command (#2)
#define		IOC_GAP_6_JGP_REG		P1074	; GAP move JOG[+] command (#3)
#define		IOC_GAP_7_JGP_REG		P1084	; GAP move JOG[+] command (#4)


#define		IOC_JCK_0_JGM_REG		P1015	; JACK move JOG[-] command (#1-#4)
#define		IOC_GAP_1_JGM_REG		P1025	; GAP move JOG[-] command (#1-#4)
#define		IOC_GAP_2_JGM_REG		P1035	; GAP move JOG[-] command (#1-#2)
#define		IOC_GAP_3_JGM_REG		P1045	; GAP move JOG[-] command (#3-#4)
#define		IOC_GAP_4_JGM_REG		P1055	; GAP move JOG[-] command (#1)
#define		IOC_GAP_5_JGM_REG		P1065	; GAP move JOG[-] command (#2)
#define		IOC_GAP_6_JGM_REG		P1075	; GAP move JOG[-] command (#3)
#define		IOC_GAP_7_JGM_REG		P1085	; GAP move JOG[-] command (#4)


#define		IOC_OFF_1_REG			P1012	; MOTOR #1 OFFSET(from IOC)
#define		IOC_OFF_2_REG			P1022	; MOTOR #2 OFFSET(from IOC)
#define		IOC_OFF_3_REG			P1032	; MOTOR #3 OFFSET(from IOC)
#define		IOC_OFF_4_REG			P1042	; MOTOR #4 OFFSET(from IOC)

#define		IOC_SPD_1_REG			P1013	; MOTOR SPEED(from IOC)
#define		IOC_SPD_2_REG			P1023	; MOTOR SPEED(not use)
#define		IOC_SPD_3_REG			P1033	; MOTOR SPEED(not use)
#define		IOC_SPD_4_REG			P1043	; MOTOR SPEED(not use)


#define		MOV_1_STAT_REG			P1016	; MOTOR #1 move status
#define		MOV_2_STAT_REG			P1026	; MOTOR #2 move status
#define		MOV_3_STAT_REG			P1036	; MOTOR #3 move status
#define		MOV_4_STAT_REG			P1046	; MOTOR #4 move status

#define		MOT_1_POS_REG			P1017	; MOTOR #1 position
#define		MOT_2_POS_REG			P1027	; MOTOR #2 position
#define		MOT_3_POS_REG			P1037	; MOTOR #3 position
#define		MOT_4_POS_REG			P1047	; MOTOR #4 position

; #define		INT_0_POS_REG			P1027	; Stage initial [#1-#4] position
; #define		INT_1_POS_REG			P1027	; Stage initial [#1] position
; #define		INT_2_POS_REG			P1037	; Stage initial [#2] position
; #define		INT_3_POS_REG			P1047	; Stage initial [#3] position
; #define		INT_4_POS_REG			P1057	; Stage initial [#4] position
; #define		GAP_0_POS_REG			P1027	; GAP axis [#1-#4] position
; #define		GAP_1_POS_REG			P1027	; GAP axis [#1] position
; #define		GAP_2_POS_REG			P1037	; GAP axis [#2] position
; #define		GAP_3_POS_REG			P1047	; GAP axis [#3] position
; #define		GAP_4_POS_REG			P1057	; GAP axis [#4] position
; #define		JCK_0_POS_REG			P1017	; JACK axis [#1-#4] position
; #define		JCK_1_POS_REG			P1067	; JACK axis [#1] position
; #define		JCK_2_POS_REG			P1067	; JACK axis [#2] position
; #define		JCK_3_POS_REG			P1067	; JACK axis [#3] position
; #define		JCK_4_POS_REG			P1067	; JACK axis [#4] position

#define		MOT_1_INT_REG			P1018	; Motor #1 interlock
#define		MOT_2_INT_REG			P1028	; Motor #2 interlock
#define		MOT_3_INT_REG			P1038	; Motor #3 interlock
#define		MOT_4_INT_REG			P1048	; Motor #4 interlock

#define		BISS_TMO_1_REG			P1019	; BiSS(#1) Time-out
#define		BISS_TMO_2_REG			P1029	; BiSS(#2) Time-out
#define		BISS_TMO_3_REG			P1039	; BiSS(#3) Time-out
#define		BISS_TMO_4_REG			P1049	; BiSS(#4) Time-out
; #define		BISS_TMO_1_REG			P1019	; BiSS(#1) Time-out
; #define		BISS_TMO_6_REG			P1069	; BiSS(#6) Time-out

#define		GAP__BRAKE_REG			P1402	; GAP BRAKE ON/OFF Command register
#define		GAP__BRAKE_STAT			P32		; GAP BRAKE ON/OFF Status register
#define		GAP__BRAKE_INIT			P34		; GAP BRAKE Initialize register


; -----------------------------
; GAP Interlock(Add 2013/09/30)
; -----------------------------
#define		GAP__INTLK_REG			P1405	; GAP INTERLOCK ENA/DIS Command register for IOC (= M4405)
#define		GAP__INTLK_STS			P1455	; GAP INTERLOCK ON/OFF Status register (= M4455)
#define		GAP__INTLK_SIG			M16		; GAP INTERLOCK SIGNAL PORT
#define		GAP__INTLK_ENA			1		; GAP INTERLOCK ENABLE
#define		GAP__INTLK_DIS			0		; GAP INTERLOCK DISABLE
#define		GAP__LOCK__SIG			0		; GAP INTERLOCK SIGNAL Status (= M16)
#define		GAP__INTLK_VAL			P41		; GAP INTERLOCK VALUE
#define		PRG_GAP__INTLK			P42		; status of evacuation program
#define		GAP__INTLK_SPD			P43		; HOLD of GAP-SPEED
#define		PRG_GAP__START			P44		; start of evacuation program

#define		GAP__INTLK_MEM			P8130	; GAP INTERLOCK(ï€éùóÃàÊ)

#define		GAP_SPARATE_SPD			P45		; Separate mode speed
#define		GAP_INTLK_POS			P46		; GAP Position
#define		GAP_INTLK_CHG			P47		; Change Interlock mode
#define		GAP_INTLK_DIR			P48		; Change Interlock direction


#define		GAP__BRK_ON_REG			P36		; GAP BRAKE-ON count register
#define		JACK_BRK_ON_REG			P37		; JACK BRAKE-ON count register
; #define		GAP__BRK_ON_MAX			1400	; GAP BRAKE-ON count(for 2.8m)
; #define		JACK_BRK_ON_MAX			1400	; JACK BRAKE-ON count(for 2.8m)
; #define		GAP__BRK_ON_MAX			100		; GAP BRAKE-ON count(for 2.8m)
; #define		JACK_BRK_ON_MAX			100		; JACK BRAKE-ON count(for 2.8m)
#define		GAP__BRK_ON_MAX			400		; GAP BRAKE-ON count(for 2.8m) 20150618
#define		JACK_BRK_ON_MAX			400		; JACK BRAKE-ON count(for 2.8m)

#define		GAP__BRK_ON_INI			0		; Initialize of GAP BRAKE-ON count(3000msec/444usec[=2.25kHz])
#define		JACK_BRK_ON_INI			0		; Initialize of JACK BRAKE-ON count(3000msec/444usec[=2.25kHz])
#define		SRV_LOCK_TIM_MIN		2
#define		SRV_LOCK_TIM_MAX		5
; #define		SRV_LOCK_ADJ_MIN		600		; start time of adjusting mode(min)
; #define		SRV_LOCK_ADJ_MAX		603		; start time of adjusting mode(max)
; #define		SRV_LOCK_ADJ_MIN		50		; start time of adjusting mode(min)
; #define		SRV_LOCK_ADJ_MAX		53		; start time of adjusting mode(max)
#define		SRV_LOCK_ADJ_MIN		300		; start time of adjusting mode(min) 20150618
#define		SRV_LOCK_ADJ_MAX		303		; start time of adjusting mode(max)


; ------------------------------
; Run-Time Error
; ------------------------------
#define		PRG1_RUN_ERR			M5182	; &1 Run-Time Error
#define		PRG1_WAR_ERR			M5188	; &1 Following Warning
#define		PRG1_FLW_ERR			M5189	; &1 Following Error
#define		PRG1_FLT_ERR			M5190	; &1 Amp Fault Error

#define		PRG2_RUN_ERR			M5282	; &2 Run-Time Error(<-not use)
#define		PRG2_WAR_ERR			M5288	; &2 Following Warning(<-not use)
#define		PRG2_FLW_ERR			M5289	; &2 Following Error(<-not use)
#define		PRG2_FLT_ERR			M5290	; &2 Amp Fault Error(<-not use)
#define		RUN_TIME_ERR			1		; Run-Time Error status


; ------------------
; Keeping variables
; ------------------
; P8107<->P8191 are available (to keep set value)
; ------------------
#define		MOT_1_OFFSET_REG		P8110		; MOTOR #1 OFFSET(keeping area)
#define		MOT_2_OFFSET_REG		P8111		; MOTOR #2 OFFSET(keeping area)
#define		MOT_3_OFFSET_REG		P8112		; MOTOR #3 OFFSET(keeping area)
#define		MOT_4_OFFSET_REG		P8113		; MOTOR #4 OFFSET(keeping area)

#define		MOT_SPEED_REG			P8120		; MOTOR #1<->#4 SPEED(keeping area)
#define		JCK_SPEED_REG			P8121		; JACK #1 SPEED(keeping area: not use)
#define		FSAVE_NUM_REG			P8122		; Number of times of FSAVE execution (keeping area)
#define		FCLEAR_NUM_REG			P8123		; Number of times of FCLEAR execution (keeping area

#define		GAP_SOFTLIM_UP_REG		P8132		; GAP SOFTWARE LIMIT(UPPER)
#define		GAP_SOFTLIM_DN_REG		P8133		; GAP SOFTWARE LIMIT(LOWER)
#define		JCK_SOFTLIM_UP_REG		P8134		; JACK SOFTWARE LIMIT(UPPER)
#define		JCK_SOFTLIM_DN_REG		P8135		; JACK SOFTWARE LIMIT(LOWER)


; ------------------
; Individual motor variables
; ------------------
#define		DIR_1_STAT_REG			P207		; GAP axis move direction
#define		MOT_1_D_REG				P208		; GAP axis lower value
#define		MOT_1_U_REG				P209		; GAP axis upper value
#define		MOT_1_TMP_REG			P210		; GAP axis temporary keeping
#define		MOT_1_DIR_REG			P211

#define		DIR_2_STAT_REG			P307		; GAP axis move direction
#define		MOT_2_D_REG				P308		; GAP axis lower value
#define		MOT_2_U_REG				P309		; GAP axis upper value
#define		MOT_2_TMP_REG			P310		; GAP axis temporary keeping
#define		MOT_2_DIR_REG			P311

#define		DIR_3_STAT_REG			P407		; GAP axis move direction
#define		MOT_3_D_REG				P408		; GAP axis lower value
#define		MOT_3_U_REG				P409		; GAP axis upper value
#define		MOT_3_TMP_REG			P410		; GAP axis temporary keeping
#define		MOT_3_DIR_REG			P411

#define		DIR_4_STAT_REG			P507		; GAP axis move direction
#define		MOT_4_D_REG				P508		; GAP axis lower value
#define		MOT_4_U_REG				P509		; GAP axis upper value
#define		MOT_4_TMP_REG			P510		; GAP axis temporary keeping
#define		MOT_4_DIR_REG			P511

; #define		JACK_DIR_STAT_REG		P107		; JACK axis move direction
; #define		JACK_D_REG				P108		; JACK axis lower value
; #define		JACK_U_REG				P109		; JACK axis upper value
; #define		JACK_TMP_REG			P110		; JACK axis temporary keeping




; --------------------------------------
;	Ixx registers variable definition
; --------------------------------------
#define		INTG_GAIN_MAX			INTEG_GAIN_DN+1000		; Gain adjustment value (maximum value)
#define		INTG_GAIN_MIN			INTEG_GAIN_DN-1000		; Gain adjustment value (minimum value)
#define		INC_GAIN_VAL			20						; Gain adjustment value (addition)
#define		DEC_GAIN_VAL			20						; Gain adjustment value (subtraction)


; ---------------------------
; Servo-Ready(Amp-Enable) output
; ---------------------------
#define		SRDY_1_OUT				M114
#define		SRDY_2_OUT				M214
#define		SRDY_3_OUT				M314
#define		SRDY_4_OUT				M414
#define		SRDY_5_OUT				M514
#define		SRDY_6_OUT				M614
#define		SRDY_7_OUT				M714
#define		SRDY_8_OUT				M814

#define		GAP_POS_LS				M121
#define		GAP_NEG_LS				M122


#define		PROP_1_GAIN				I0130		; MOTOR #1 proportion gain
#define		PROP_2_GAIN				I0230		; MOTOR #2 proportion gain
#define		PROP_3_GAIN				I0330		; MOTOR #3 proportion gain
#define		PROP_4_GAIN				I0430		; MOTOR #4 proportion gain
#define		PROP_5_GAIN				I0530		; MOTOR #5 proportion gain
#define		PROP_6_GAIN				I0630		; MOTOR #6 proportion gain
#define		PROP_7_GAIN				I0730		; MOTOR #7 proportion gain
#define		PROP_8_GAIN				I0830		; MOTOR #8 proportion gain

#define		PROP_17_GAIN			I1730		; MOTOR #17 proportion gain (virtual axis)
#define		PROP_18_GAIN			I1830		; MOTOR #18 proportion gain (virtual axis)
#define		PROP_19_GAIN			I1930		; MOTOR #19 proportion gain (virtual axis)
#define		PROP_20_GAIN			I2030		; MOTOR #20 proportion gain (virtual axis)
#define		PROP_21_GAIN			I2130		; MOTOR #21 proportion gain (virtual axis)
#define		PROP_22_GAIN			I2230		; MOTOR #22 proportion gain (virtual axis)
#define		PROP_23_GAIN			I2330		; MOTOR #23 proportion gain (virtual axis)
#define		PROP_24_GAIN			I2430		; MOTOR #24 proportion gain (virtual axis)


#define		DRIV_1_GAIN				I0131		; MOTOR #1 differential gain
#define		DRIV_2_GAIN				I0231		; MOTOR #2 differential gain
#define		DRIV_3_GAIN				I0331		; MOTOR #3 differential gain
#define		DRIV_4_GAIN				I0431		; MOTOR #4 differential gain
#define		DRIV_5_GAIN				I0531		; MOTOR #5 differential gain
#define		DRIV_6_GAIN				I0631		; MOTOR #6 differential gain
#define		DRIV_7_GAIN				I0731		; MOTOR #7 differential gain
#define		DRIV_8_GAIN				I0831		; MOTOR #8 differential gain

#define		DRIV_17_GAIN			I1731		; MOTOR #17 differential gain (virtual axis)
#define		DRIV_18_GAIN			I1831		; MOTOR #18 differential gain (virtual axis)
#define		DRIV_19_GAIN			I1931		; MOTOR #19 differential gain (virtual axis)
#define		DRIV_20_GAIN			I2031		; MOTOR #20 differential gain (virtual axis)
#define		DRIV_21_GAIN			I2131		; MOTOR #21 differential gain (virtual axis)
#define		DRIV_22_GAIN			I2231		; MOTOR #22 differential gain (virtual axis)
#define		DRIV_23_GAIN			I2331		; MOTOR #23 differential gain (virtual axis)
#define		DRIV_24_GAIN			I2431		; MOTOR #24 differential gain (virtual axis)


#define		INTG_1_GAIN				I0133		; MOTOR #1 integral gain
#define		INTG_2_GAIN				I0233		; MOTOR #2 integral gain
#define		INTG_3_GAIN				I0333		; MOTOR #3 integral gain
#define		INTG_4_GAIN				I0433		; MOTOR #4 integral gain
#define		INTG_5_GAIN				I0533		; MOTOR #5 integral gain
#define		INTG_6_GAIN				I0633		; MOTOR #6 integral gain
#define		INTG_7_GAIN				I0733		; MOTOR #7 integral gain
#define		INTG_8_GAIN				I0833		; MOTOR #8 integral gain

#define		INTG_17_GAIN			I1733		; MOTOR #17 integral gain (virtual axis)
#define		INTG_18_GAIN			I1833		; MOTOR #18 integral gain (virtual axis)
#define		INTG_19_GAIN			I1933		; MOTOR #19 integral gain (virtual axis)
#define		INTG_20_GAIN			I2033		; MOTOR #20 integral gain (virtual axis)
#define		INTG_21_GAIN			I2133		; MOTOR #21 integral gain (virtual axis)
#define		INTG_22_GAIN			I2233		; MOTOR #22 integral gain (virtual axis)
#define		INTG_23_GAIN			I2333		; MOTOR #23 integral gain (virtual axis)
#define		INTG_24_GAIN			I2433		; MOTOR #24 integral gain (virtual axis)

; ----------
; At normal move 
; ----------
#define		MOTOR_1_JOG				I0116		; MOTOR #1 program maximum speed
#define		MOTOR_2_JOG				I0216		; MOTOR #2 program maximum speed
#define		MOTOR_3_JOG				I0316		; MOTOR #3 program maximum speed
#define		MOTOR_4_JOG				I0416		; MOTOR #4 program maximum speed
#define		MOTOR_5_JOG				I0516		; MOTOR #5 program maximum speed
#define		MOTOR_6_JOG				I0616		; MOTOR #6 program maximum speed
#define		MOTOR_7_JOG				I0716		; MOTOR #7 program maximum speed
#define		MOTOR_8_JOG				I0816		; MOTOR #8 program maximum speed

#define		MOTOR_17_JOG			I1716		; MOTOR #17 program maximum speed
#define		MOTOR_18_JOG			I1816		; MOTOR #18 program maximum speed
#define		MOTOR_19_JOG			I1916		; MOTOR #19 program maximum speed
#define		MOTOR_20_JOG			I2016		; MOTOR #20 program maximum speed
#define		MOTOR_21_JOG			I2116		; MOTOR #21 program maximum speed
#define		MOTOR_22_JOG			I2216		; MOTOR #22 program maximum speed
#define		MOTOR_23_JOG			I2316		; MOTOR #23 program maximum speed
#define		MOTOR_24_JOG			I2416		; MOTOR #24 program maximum speed


; ---------
; At JOG move
; ---------
#define		MOTOR_1_JOG_JOG			I0122		; MOTOR #1 JOG speed
#define		MOTOR_2_JOG_JOG			I0222		; MOTOR #2 JOG speed
#define		MOTOR_3_JOG_JOG			I0322		; MOTOR #3 JOG speed
#define		MOTOR_4_JOG_JOG			I0422		; MOTOR #4 JOG speed
#define		MOTOR_5_JOG_JOG			I0522		; MOTOR #5 JOG speed
#define		MOTOR_6_JOG_JOG			I0622		; MOTOR #6 JOG speed
#define		MOTOR_7_JOG_JOG			I0722		; MOTOR #7 JOG speed
#define		MOTOR_8_JOG_JOG			I0822		; MOTOR #8 JOG speed

#define		MOTOR_17_JOG_JOG		I1722		; MOTOR #17 JOG speed
#define		MOTOR_18_JOG_JOG		I1822		; MOTOR #18 JOG speed
#define		MOTOR_19_JOG_JOG		I1922		; MOTOR #19 JOG speed
#define		MOTOR_20_JOG_JOG		I2022		; MOTOR #20 JOG speed
#define		MOTOR_21_JOG_JOG		I2122		; MOTOR #21 JOG speed
#define		MOTOR_22_JOG_JOG		I2222		; MOTOR #22 JOG speed
#define		MOTOR_23_JOG_JOG		I2322		; MOTOR #23 JOG speed
#define		MOTOR_24_JOG_JOG		I2422		; MOTOR #24 JOG speed



; --------------------------------------
; Motor move status
; --------------------------------------
#define		MOT_MOV_1_FNC		IF(MOT_SPDZ_1_REG = 1 AND MOT_INP_1_REG = 1) MOV_1_STAT_REG=STOP_AXIS ELSE MOV_1_STAT_REG=MOVE_AXIS ENDIF			; ãÏìÆèÛë‘ÇÃê›íË(MOTOR #1)
#define		MOT_MOV_2_FNC		IF(MOT_SPDZ_2_REG = 1 AND MOT_INP_2_REG = 1) MOV_2_STAT_REG=STOP_AXIS ELSE MOV_2_STAT_REG=MOVE_AXIS ENDIF			; ãÏìÆèÛë‘ÇÃê›íË(MOTOR #2)
#define		MOT_MOV_3_FNC		IF(MOT_SPDZ_3_REG = 1 AND MOT_INP_3_REG = 1) MOV_3_STAT_REG=STOP_AXIS ELSE MOV_3_STAT_REG=MOVE_AXIS ENDIF			; ãÏìÆèÛë‘ÇÃê›íË(MOTOR #3)
#define		MOT_MOV_4_FNC		IF(MOT_SPDZ_4_REG = 1 AND MOT_INP_4_REG = 1) MOV_4_STAT_REG=STOP_AXIS ELSE MOV_4_STAT_REG=MOVE_AXIS ENDIF			; ãÏìÆèÛë‘ÇÃê›íË(MOTOR #4)


; --------------------------------------
; Motor move direction
; --------------------------------------
; ---------------------------
; the following is compile error
; ---------------------------
; #define		MOT_DIR_1_FNC		IF(MOT_ACC_1_REG > 0) DIR_1_STAT_REG=CW__DIR ELSE IF(MOT_ACC_1_REG < 0) DIR_1_STAT_REG=CCW_DIR ELSE DIR_1_STAT_REG=NO__DIR ENDIF ENDIF
; #define		MOT_DIR_2_FNC		IF(MOT_ACC_2_REG > 0) DIR_2_STAT_REG=CW__DIR ELSE IF(MOT_ACC_2_REG < 0) DIR_2_STAT_REG=CCW_DIR ELSE DIR_2_STAT_REG=NO__DIR ENDIF ENDIF
; #define		MOT_DIR_3_FNC		IF(MOT_ACC_3_REG > 0) DIR_3_STAT_REG=CW__DIR ELSE IF(MOT_ACC_3_REG < 0) DIR_3_STAT_REG=CCW_DIR ELSE DIR_3_STAT_REG=NO__DIR ENDIF ENDIF
; #define		MOT_DIR_4_FNC		IF(MOT_ACC_4_REG > 0) DIR_4_STAT_REG=CW__DIR ELSE IF(MOT_ACC_4_REG < 0) DIR_4_STAT_REG=CCW_DIR ELSE DIR_4_STAT_REG=NO__DIR ENDIF ENDIF
; ---------------------------
; -------------------------------
; the following is not compile error
; -------------------------------
#define		MOT_DIR_1_FNC		IF(MOT_ACC_1_REG > 0) DIR_1_STAT_REG=CW__DIR ELSE IF(MOT_ACC_1_REG < 0) DIR_1_STAT_REG=CCW_DIR ENDIF ENDIF
#define		MOT_DIR_2_FNC		IF(MOT_ACC_2_REG > 0) DIR_2_STAT_REG=CW__DIR ELSE IF(MOT_ACC_2_REG < 0) DIR_2_STAT_REG=CCW_DIR ENDIF ENDIF
#define		MOT_DIR_3_FNC		IF(MOT_ACC_3_REG > 0) DIR_3_STAT_REG=CW__DIR ELSE IF(MOT_ACC_3_REG < 0) DIR_3_STAT_REG=CCW_DIR ENDIF ENDIF
#define		MOT_DIR_4_FNC		IF(MOT_ACC_4_REG > 0) DIR_4_STAT_REG=CW__DIR ELSE IF(MOT_ACC_4_REG < 0) DIR_4_STAT_REG=CCW_DIR ENDIF ENDIF



; =======================================
;	Coordinate system setting
;	#1  <-> #4  : Real Axis
;		#1,#2:GAP(UPPER)
;		#3,#4:GAP(LOWER)
;	#17 <-> #22 : Virtual Axis
;		#17,#18:GAP(UPPER)
;		#20,#21:GAP(LOWER)
;		#19,#22:Spare
;		BiSS:1cnt=1nm
; =======================================
; Coordinate system &1(GAP)
; =======================================
&1
#1->X				; Real Axis #1(Upper)
#17->X				; Virtual Axis #17
#2->A				; Real Axis #2(Upper)
#18->A				; Virtual Axis #18

#3->Y				; Real Axis #3(Lower)
#20->Y				; Virtual Axis #20
#4->B				; Real Axis #4(Lower)
#21->B				; Virtual Axis #21


; =======================================
; Coordinate system &2(JACK) <- not use
; =======================================
; &2
; #1->Z				; Real Axis #1(Jack)




; Coordinate system1 (&1) status bits
M5180->X:$002040,0,1		; &1 Program-running bit
M5181->Y:$00203F,21,1		; &1 Circle-radius-error bit
M5182->Y:$00203F,22,1		; &1 Run-time-error bit
M5184->X:$002040,0,4		; &1 Continuous motion request
M5187->Y:$00203F,17,1		; &1 In-position bit (AND of motors)
M5188->Y:$00203F,18,1		; &1 Warning-following-error bit (OR)
M5189->Y:$00203F,19,1		; &1 Fatal-following-error bit (OR)
M5190->Y:$00203F,20,1		; &1 Amp-fault-error bit (OR of motors)


; Coordinate system 2 (&2) status bit
; M5280->X:$002140,0,1		; &2 Program-running bit
; M5281->Y:$00213F,21,1		; &2 Circle-radius-error bit
; M5282->Y:$00213F,22,1		; &2 Run-time-error bit
; M5284->X:$002140,0,4		; &2 Continuous motion request
; M5287->Y:$00213F,17,1		; &2 In-position bit (AND of motors)
; M5288->Y:$00213F,18,1		; &2 Warning-following-error bit (OR
; M5289->Y:$00213F,19,1		; &2 Fatal-following-error bit (OR)
; M5290->Y:$00213F,20,1		; &2 Amp-fault-error bit (OR of motors)


ENABLE PLC1



; ======================================
; ======================================
;	Initialize
;		PLC1
; ======================================
; ======================================
OPEN PLC1 CLEAR

P8000 = P8000 + 1		; for Debug

	DISABLE PLC0			; Disable PLC0
	DISABLE PLC2..31		; Disable PLC2<->31
	DISABLE PLCC0..31		; Disable PLCC0<->31


	WAIT_TIMER_FNC			; Wait(1000msec)

	; --------------------------------------
	; Initialize data
	; --------------------------------------
	VER_P_REG         = BNL28_VER			; Version No.(P300)

	REQ_INIT_REQ_REG    = 0					; Init Data request
	REQ_INIT_ANS_REG    = 0					; Init Data answer
	PMAC_SEQ_COUT_REG   = 0					; Sequence counter

	SRDY_1_OUT = SERVO_RDY_OFF				; Servo OFF[#1](Add 2014/05/27)
	SRDY_2_OUT = SERVO_RDY_OFF				; Servo OFF[#2](Add 2014/05/27)
	SRDY_3_OUT = SERVO_RDY_OFF				; Servo OFF[#3](Add 2014/05/27)
	SRDY_4_OUT = SERVO_RDY_OFF				; Servo OFF[#4](Add 2014/05/27)

	ALM_MT1_CLR_CNT_REG = 0					; Alarm clear count initial setting (Add:2014/09/13)
	ALM_MT2_CLR_CNT_REG = 0					; Alarm clear count initial setting (Add:2014/09/13)
	ALM_MT3_CLR_CNT_REG = 0					; Alarm clear count initial setting (Add:2014/09/13)
	ALM_MT4_CLR_CNT_REG = 0					; Alarm clear count initial setting (Add:2014/09/13)
	ALM_MT1_LST_STS_REG = 0					; Alarm clear register newest state (Add:2014/09/14)
	ALM_MT2_LST_STS_REG = 0					; Alarm clear register newest state (Add:2014/09/14)
	ALM_MT3_LST_STS_REG = 0					; Alarm clear register newest state (Add:2014/09/14)
	ALM_MT4_LST_STS_REG = 0					; Alarm clear register newest state (Add:2014/09/14)

	AMP_ALM_STS_REG     = 0					; Amplifier alarm state

	IOC_BRICK_RESET_REG = 0					; BRICK-CONTROLLER RESET

	IOC_GAP_1_DRV_REG = 0					; GAP move command (#1-#4)
	IOC_GAP_2_DRV_REG = 0					; GAP move command (#1-#2)
	IOC_GAP_3_DRV_REG = 0					; GAP move command (#3-#4)

	IOC_GAP_4_DRV_REG = 0					; GAP move command (#1)
	IOC_GAP_5_DRV_REG = 0					; GAP move command (#2)
	IOC_GAP_6_DRV_REG = 0					; GAP move command (#3)
	IOC_GAP_7_DRV_REG = 0					; GAP move command (#4)
;	IOC_JACK_DRV_REG  = 0					; JACK move command (#1)

	IOC_GAP_1_STP_REG = 0					; GAP move command (#1-#4)
	IOC_GAP_2_STP_REG = 0					; GAP move command (#1-#2)
	IOC_GAP_3_STP_REG = 0					; GAP move command (#3-#4)

	IOC_GAP_4_STP_REG = 0					; GAP stop command (#1)
	IOC_GAP_5_STP_REG = 0					; GAP stop command (#2)
	IOC_GAP_6_STP_REG = 0					; GAP stop command (#3)
	IOC_GAP_7_STP_REG = 0					; GAP stop command (#4)
;	IOC_JACK_STP_REG  = 0					; JACK stop command (#1)

; ---------
; for Debug
	P7200 = 0
	P7201 = 0
	P7210 = 0
	P7211 = 0
	P7220 = 0
	P7221 = 0
	P7230 = 0
	P7231 = 0

	P7240 = 0
	P7241 = 0
	P7250 = 0
	P7251 = 0
	P7260 = 0
	P7261 = 0
	P7270 = 0
	P7271 = 0
; for Debug
; ---------


; --------------
; Rev:2014/10/10
;
;	IOC_OFF_1_REG    = 0					; GAP #1 OFFSET(from IOC)
;	IOC_OFF_2_REG    = 0					; GAP #2 OFFSET(from IOC)
;	IOC_OFF_3_REG    = 0					; GAP #3 OFFSET(from IOC)
;	IOC_OFF_4_REG    = 0					; GAP #4 OFFSET(from IOC)
;;	IOC_OFF_1_REG    = 0					; JACK #1 OFFSET(from IOC)
;;	IOC_OFF_6_REG    = 0					; JACK #2 OFFSET(from IOC)

;	IOC_SPD_1_REG    = 0					; GAP SPEED(from IOC)
;	IOC_SPD_2_REG    = 0					; GAP SPEED
;	IOC_SPD_3_REG    = 0					; GAP SPEED
;	IOC_SPD_4_REG    = 0					; GAP SPEED
;;	IOC_JACK_SPD_REG = 0					; JACK SPEED(from IOC)

	IOC_OFF_1_REG    = GAP1_OFFSET			; GAP #1 OFFSET(from IOC)
	IOC_OFF_2_REG    = GAP2_OFFSET			; GAP #2 OFFSET(from IOC)
	IOC_OFF_3_REG    = GAP3_OFFSET			; GAP #3 OFFSET(from IOC)
	IOC_OFF_4_REG    = GAP4_OFFSET			; GAP #4 OFFSET(from IOC)
;	IOC_OFF_1_REG    = 0					; JACK #1 OFFSET(from IOC)
;	IOC_OFF_6_REG    = 0					; JACK #2 OFFSET(from IOC)

	IOC_SPD_1_REG    = GAP_DEF_SPD			; GAP SPEED(from IOC)
	IOC_SPD_2_REG    = 0					; GAP SPEED
	IOC_SPD_3_REG    = 0					; GAP SPEED
	IOC_SPD_4_REG    = 0					; GAP SPEED
;	IOC_JACK_SPD_REG = JCK_DEF_SPD			; JACK SPEED(from IOC)

	GAP__INTLK_REG   = GAP_DEF_EVA			; GAP Evacuation

;
; Rev:2014/10/10
; --------------

	IOC_GAP_1_DRV_REG = 0					;
	IOC_GAP_2_DRV_REG = 0					;
	IOC_GAP_3_DRV_REG = 0					;
	IOC_GAP_4_DRV_REG = 0					;
	IOC_GAP_5_DRV_REG = 0					;
	IOC_GAP_6_DRV_REG = 0					;
	IOC_GAP_7_DRV_REG = 0					;
	IOC_JCK_0_DRV_REG = 0					;


	IOC_GAP_1_JGP_REG = 0					; GAP move JOG[+] command (#1-#4)
	IOC_GAP_2_JGP_REG = 0					; GAP move JOG[+] command (#1-#2)
	IOC_GAP_3_JGP_REG = 0					; GAP move JOG[+] command (#3-#4)
	IOC_GAP_4_JGP_REG = 0					; GAP move JOG[+] command (#1)
	IOC_GAP_5_JGP_REG = 0					; GAP move JOG[+] command (#2)
	IOC_GAP_6_JGP_REG = 0					; GAP move JOG[+] command (#3)
	IOC_GAP_7_JGP_REG = 0					; GAP move JOG[+] command (#4)
	IOC_JCK_0_JGP_REG = 0					; JACK move JOG[+] command (#1)

	IOC_GAP_1_JGM_REG = 0					; GAP move JOG[-] command (#1-#4)
	IOC_GAP_2_JGM_REG = 0					; GAP move JOG[-] command (#1-#2)
	IOC_GAP_3_JGM_REG = 0					; GAP move JOG[-] command (#3-#4)
	IOC_GAP_4_JGM_REG = 0					; GAP move JOG[-] command (#2)
	IOC_GAP_5_JGM_REG = 0					; GAP move JOG[-] command (#3)
	IOC_GAP_6_JGM_REG = 0					; GAP move JOG[-] command (#4)
	IOC_GAP_7_JGM_REG = 0					; GAP move JOG[-] command (#5)
	IOC_JCK_0_JGM_REG = 0					; JACK move JOG[-] command (#1)

	IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617

	GAP_SPARATE_SPD = 0						; GAP axis velocity at separate mode
	GAP__INTLK_SPD  = 0						; gap evacuation speed
	PRG_EXEC_REG    = 0						; program execute status

	ADJ_STAT__REG   = ADJ_NORMAL
	ADJ_MODE__REG   = ADJ_FINISH
	ADJ_PREMD_REG   = ADJ_FINISH
	ADJ_STOP__REG   = 0

; --------------
; Add:2014/09/28
	REQ_JACK_RETRY_REG = 0					; move command retry count
	REQ_GAP__RETRY_REG = 0					; move command retry count
; Add:2014/09/28
; --------------

; --------------------------------
; Delete Auto Servo-ON[2013/09/02]
; --------------------------------
;	JACK_BRAKE_INIT = 0						; JACK BRAKE Initialize
;	GAP__BRAKE_INIT = 0						; GAP BRAKE Initialize

;	JACK_BRAKE_INIT = 1						; JACK BRAKE Initialize
;	JACK_BRAKE_STAT = SERVO_RDY__ON
	GAP__BRAKE_INIT = 1						; GAP BRAKE Initialize
	GAP__BRAKE_STAT = SERVO_RDY__ON
	GAP__BRAKE_REG  = SERVO_RDY__ON			; Add 2014/05/27

; --------------------------------
; Initialize count(Add 2013/09/30)
; --------------------------------
;	JACK_BRK_ON_REG = JACK_BRK_ON_INI
	GAP__BRK_ON_REG = GAP__BRK_ON_INI


P8001 = P8001 + 1		; for Debug

	; --------------------------------------
	;	set M-register
	;	M0 = X/Y:$004000
	;	M4000 = X/Y:$004FA0
	;	P0 = L:$006000
	;	P1000 = L:$0063E8
	;	M4000 = P1000Ç∆Ç∑ÇÈ
	; --------------------------------------
	WAIT_TIMER_FNC			; Wait(1000msec)
	TMP5_REG = 0
	TMP5_REG = 0
	M_Type   = $EC0000		; L-register
	M_Addr   = $0063E8		; Base Address = P1000 Address
	M_Type_a = $004FA0		; M4000 Address
	M_Addr_a = $004FA0		; M4000 Address
;	WHILE( TMP5_REG < 1000 )
	WHILE( TMP5_REG < 500 )
		M_Type   = $EC0000					; L-register
		M_Addr   = $0063E8  + TMP5_REG		; Base Address = P1000 Address
		M_Type_a = M_Type_a + 1
		M_Addr_a = M_Addr_a + 1
		TMP5_REG = TMP5_REG + 1
	ENDWHILE
	TMP5_REG = 0

	REQ_IOC_KILL__REG = 0		; Add:2014/10/20
	REQ_IOC_ABORT_REG = 0		; Add:2014/10/20

P8002 = P8002 + 1		; for Debug

; --------------
; Del:2014/10/13
;
;; -----------------------
;; request initialize data
;; -----------------------
;	REQ_INIT_REQ_REG = 1
;	REQ_INIT_ANS_REG = 0
;	REQ_INIT_END_REG = 0
;P8020 = P8020 + 1		; for Debug
;
;	WHILE( REQ_INIT_ANS_REG != -1 )
;		HOLD_TIMER_FNC
;	ENDWHILE
;
;P8021 = P8021 + 1		; for Debug
;	REQ_INIT_END_REG = 1
;	REQ_INIT_ANS_REG = 0
;	REQ_INIT_REQ_REG = 0
;
;
;	; ----------------------------------
;	; Measure against IOC sending zero of which reason is not clear.  
;	; ----------------------------------
;	IF( IOC_OFF_4_REG = 0 OR IOC_OFF_3_REG = 0 OR IOC_OFF_2_REG = 0 OR IOC_OFF_1_REG = 0 OR IOC_SPD_1_REG = 0 )
;P8022 = P8022 + 1		; for Debug
;
;		WHILE( REQ_INIT_ANS_REG != 0 )
;			HOLD_TIMER_FNC
;		ENDWHILE
;
;P8023 = P8023 + 1		; for Debug
;		REQ_INIT_REQ_REG = 1
;		REQ_INIT_ANS_REG = 0
;		REQ_INIT_END_REG = 0
;
;P8020 = P8020 + 1		; for Debug
;		WHILE( REQ_INIT_ANS_REG != -1 )
;			HOLD_TIMER_FNC
;		ENDWHILE
;
;P8021 = P8021 + 1		; for Debug
;		REQ_INIT_END_REG = 1
;		REQ_INIT_ANS_REG = 0
;		REQ_INIT_REQ_REG = 0
;	ELSE
;	ENDIF
;
; Del:2014/10/13
; --------------


	; Receive initial data from IOC
	MOT_SPEED_REG    = IOC_SPD_1_REG		; Speed
	JCK_SPEED_REG    = IOC_SPD_1_REG		; Speed(not use)
	MOT_4_OFFSET_REG = IOC_OFF_4_REG		; OFFSET[#4]
	MOT_3_OFFSET_REG = IOC_OFF_3_REG		; OFFSET[#3]
	MOT_2_OFFSET_REG = IOC_OFF_2_REG		; OFFSET[#2]
	MOT_1_OFFSET_REG = IOC_OFF_1_REG		; OFFSET{#1]
	GAP__INTLK_MEM   = GAP__INTLK_REG		; GAP evacuation function


; ----------------
; read memory data
; ----------------
;	CMD"FREAD"								; set data from keeping area (OFFSETÅASPEED)

	IF( MOT_SPEED_REG != 0 )
		IOC_SPD_1_REG = MOT_SPEED_REG

;		TMP1_REG = IOC_SPD_1_REG * MOT_SPD_CNV
		TMP1_REG = ( IOC_SPD_1_REG * MOT_SPD_CNV ) * MOT_LIN_ROT_CNV
		IF( TMP1_REG > SPD_MAX )
			TMP1_REG = SPD_MAX
		ENDIF

		TMP2_REG = 2 * SPD_MIN
		IF( TMP1_REG < SPD_MIN )
			TMP1_REG = SPD_MIN
		ENDIF

; --------
; speed x1(start)
; --------
		TMP2_REG      = 1
		MOTOR_1_JOG   = TMP1_REG * TMP2_REG
		MOTOR_2_JOG   = TMP1_REG * TMP2_REG
		MOTOR_3_JOG   = TMP1_REG * TMP2_REG
		MOTOR_4_JOG   = TMP1_REG * TMP2_REG
		MOTOR_17_JOG  = TMP1_REG * TMP2_REG
		MOTOR_18_JOG  = TMP1_REG * TMP2_REG
		MOTOR_20_JOG  = TMP1_REG * TMP2_REG
		MOTOR_21_JOG  = TMP1_REG * TMP2_REG

		MOTOR_1_JOG_JOG  = TMP1_REG * TMP2_REG
		MOTOR_2_JOG_JOG  = TMP1_REG * TMP2_REG
		MOTOR_3_JOG_JOG  = TMP1_REG * TMP2_REG
		MOTOR_4_JOG_JOG  = TMP1_REG * TMP2_REG
		MOTOR_17_JOG_JOG = TMP1_REG * TMP2_REG
		MOTOR_18_JOG_JOG = TMP1_REG * TMP2_REG
		MOTOR_20_JOG_JOG = TMP1_REG * TMP2_REG
		MOTOR_21_JOG_JOG = TMP1_REG * TMP2_REG
; --------
; speed x1(end)
; --------

	ELSE

; --------
; speed x1(start)
; --------
		TMP1_REG      = MOTOR_1_JOG;
; --------
; speed x1(end)
; --------


;		MOT_SPEED_REG = TMP1_REG * GAP_SPD_CNV
		MOT_SPEED_REG = ( TMP1_REG / MOT_SPD_CNV ) / MOT_LIN_ROT_CNV
		IOC_SPD_1_REG = MOT_SPEED_REG

	ENDIF


	IOC_OFF_4_REG = MOT_4_OFFSET_REG
	IOC_OFF_3_REG = MOT_3_OFFSET_REG
	IOC_OFF_2_REG = MOT_2_OFFSET_REG
	IOC_OFF_1_REG = MOT_1_OFFSET_REG

	; ----------------------------------
	; read GAP INTERLOCK(Add 2013/09/30)
	; ----------------------------------
	GAP__INTLK_REG = GAP__INTLK_MEM			; GAP evacuation function
	GAP__INTLK_SPD = MOTOR_1_JOG			; GAP velocity of evacuation
	PRG_GAP__INTLK = 0						; Clear GAP evacuation status
	PRG_GAP__START = 0						; Clear GAP evacuation program start status
	P330 = 0								; Use P-variable(PRG20)
	P331 = 0								; Use P-variable(PRG10&PRG14)
	P332 = 0								; Use P-variable(PRG10&PRG14)
	P333 = 0								; Use P-variable(PRG10&PRG14)
	P341 = 0								; Use P-variable(PRG10&PRG14)
	P342 = 0								; Use P-variable(PRG10&PRG14)
	P343 = 0								; Use P-variable(PRG10&PRG14)


; --------------
; Add:2014/11/20
	REQ_COMP_SCAN_REG = COMP_SCAN_DISABLE		; disable skew compensation table creation 
	COMP_SCAN_REG     = COMP_SCAN_DISABLE		; use skew compensation table
	COMP_FLAG_REG     = COMP_SCAN_DISABLE		; disable skew compensation
	COMP_01_VAL_REG   = 0
	COMP_17_VAL_REG   = 0
	COMP_03_VAL_REG   = 0
	COMP_20_VAL_REG   = 0
; Add:2014/11/20
; --------------
	; --------------------------------------
	;	X axis definition
	; --------------------------------------
	; --------------------------------------
	;	#17 I variables setting
	; --------------------------------------
	I1700 = MOTOR_ACTIVE				; Motor Activation
	I1702 = DAC_OUTPUT_CH01_REG			; Command Output Address
	I1706 = MOTOR_FOLW					; Position Following Enable and Mode

	; --------------------------------------
	;	#1 I variables setting
	; --------------------------------------
	I0102 = DAC_OFFSET_CH18_REG			; Command Output Address
	I0103 = BISS_ADD_1_2				; Position Loop Feedback Address
	I0104 = BISS_ADD_1_2				; Velocity Loop Feedback Address
	I0106 = MOTOR_FOLW					; Position Following Enable and Mode

	I0108 = I1708						; Position Scale Factor
	I0109 = I1708						; Velocity-Loop Scale Factor

	I0124 = MOTOR_FLAG_VAL				; Flag Mode Control

	I0130 = (PROPO_GAIN_UP)				; PID Proportional Gain

	; --------------------------------------
	;	A axis definition
	; --------------------------------------
	; --------------------------------------
	;	#18 I variable setting
	; --------------------------------------
	I1800 = MOTOR_ACTIVE				; Motor Activation
	I1802 = DAC_OUTPUT_CH02_REG			; Command Output Address
	I1806 = MOTOR_FOLW					; Position Following Enable and Mode

	; --------------------------------------
	;	#2 I variables setting
	; --------------------------------------
	I0202 = DAC_OFFSET_CH17_REG			; Command Output Address
	I0203 = BISS_SUB_1_2				; Position Loop Feedback Address
	I0204 = BISS_SUB_1_2				; Velocity Loop Feedback Address
	I0206 = MOTOR_FOLW					; Position Following Enable and Mode

	I0208 = I1708						; Position Scale Factor
	I0209 = I1708						; Velocity-Loop Scale Factor

	I0224 = MOTOR_FLAG_VAL				; Flag Mode Control

	I0230 = (2*PROPO_GAIN_UP)			; PID Proportional Gain

	; --------------------------------------
	;	Y axis definition
	; --------------------------------------
	; --------------------------------------
	;	#20 I variables setting
	; --------------------------------------
	I2000 = MOTOR_ACTIVE				; Motor Activation
	I2002 = DAC_OUTPUT_CH03_REG			; Command Output Address
	I2006 = MOTOR_FOLW					; Position Following Enable and Mode

	; --------------------------------------
	;	#3 I variables setting
	; --------------------------------------
	I0302 = DAC_OFFSET_CH21_REG			; Command Output Address
	I0303 = BISS_ADD_3_4				; Position Loop Feedback Address
	I0304 = BISS_ADD_3_4				; Velocity Loop Feedback Address
	I0306 = MOTOR_FOLW					; Position Following Enable and Mode

	I0308 = I2008						; Position Scale Factor
	I0309 = I2008						; Velocity-Loop Scale Factor

	I0324 = MOTOR_FLAG_VAL				; Flag Mode Control

	I0330 = (PROPO_GAIN_DN)				; PID Proportional Gain


	; --------------------------------------
	;	B axis definition
	; --------------------------------------
	; --------------------------------------
	;	#21 I variables setting
	; --------------------------------------
	I2100 = MOTOR_ACTIVE				; Motor Activation
	I2102 = DAC_OUTPUT_CH04_REG			; Command Output Address
	I2106 = MOTOR_FOLW					; Position Following Enable and Mode

	; --------------------------------------
	;	#4 I variables setting
	; --------------------------------------
	I0402 = DAC_OFFSET_CH20_REG			; Command Output Address
	I0403 = BISS_SUB_3_4				; Position Loop Feedback Address
	I0404 = BISS_SUB_3_4				; Velocity Loop Feedback Address
	I0406 = MOTOR_FOLW					; Position Following Enable and Mode

	I0408 = I2008						; Position Scale Factor
	I0409 = I2008						; Velocity-Loop Scale Factor

	I0424 = MOTOR_FLAG_VAL				; Flag Mode Control

	I0430 = (2*PROPO_GAIN_DN)			; PID Proportional Gain

	INITIALIZE_REG     = SYS_INTLCK			; Initialization end state
	EMERGENCY_STAT_REG = SYS_NORMAL			; EMERGENCY=STOP button pushed status (=not pushed [normal])
	ACTIVE_MODE_REG    = USR_MODE			; Run mode = user-mode
	IOC_CHG_MODE_REG   = USR_MODE			; Command run mode = user-mode
	SYS_INTLCK_REG     = SYS_NORMAL			; Interlock (consistency fault) = normal
	DEVIATION_STAT_REG = DVI_NORMAL			; Deviation error = normal
	DEVIATION_VAL_REG  = SYS_DEVIATION		; Position deviation value = SYSTEM value
	BISS_STAT_REG      = BISS_NORMAL		; BiSS-C Timeout = normal
	LOCK_1_STAT_REG    = LOCK_OCCUR			; Servo lock issue status = lock
	LOCK_2_STAT_REG    = LOCK_OCCUR			; Servo lock issue status = lock
	LOCK_3_STAT_REG    = LOCK_OCCUR			; Servo lock issue status = lock
	LOCK_4_STAT_REG    = LOCK_OCCUR			; Servo lock issue status = lock
	BISS_INIT_REG      = 0					; BISS initialization status = not initialized

	GAP_UPLIMIT_REG    = 0					; GAP axis maximum software limit
	GAP_DNLIMIT_REG    = 0					; GAP axis minimum software limit

	HOME_ADJ_PRG_REG   = HOME_EXEC_0		; Add:2014/04/23
	DRIVE_MODE_REG     = DRIVE_STOP			; Add 2014/04/30


	; --------------------------------------
	;	set M-register
	;	M0 = X/Y:$004000
	;	M4000 = X/Y:$004FA0
	;	P0 = L:$006000
	;	P1000 = L:$0063E8
	;	M4000 = P1000
	; --------------------------------------
;	WAIT_TIMER_FNC			; Wait(1000msec)
;	TMP5_REG = 0
;	TMP5_REG = 0
;	M_Type   = $EC0000		; L-register
;	M_Addr   = $0063E8		; Base Address = P1000 Address
;	M_Type_a = $004FA0		; M4000 Address
;	M_Addr_a = $004FA0		; M4000 Address
;;	WHILE( TMP5_REG < 1000 )
;	WHILE( TMP5_REG < 500 )
;		M_Type   = $EC0000					; L-register
;		M_Addr   = $0063E8  + TMP5_REG		; Base Address = P1000 Address
;		M_Type_a = M_Type_a + 1
;		M_Addr_a = M_Addr_a + 1
;		TMP5_REG = TMP5_REG + 1
;	ENDWHILE
;	TMP5_REG = 0



P8003 = P8003 + 1		; for Debug

	; Coordinate system 1 (&1) status bits
	CMD"M5180->X:$002040,0,1"		; &1 Program-running bit
	CMD"M5181->Y:$00203F,21,1"		; &1 Circle-radius-error bit
	CMD"M5182->Y:$00203F,22,1"		; &1 Run-time-error bit
	CMD"M5184->X:$002040,0,4"		; &1 Continuous motion request
	CMD"M5187->Y:$00203F,17,1"		; &1 In-position bit (AND of motors)
	CMD"M5188->Y:$00203F,18,1"		; &1 Warning-following-error bit (OR)
	CMD"M5189->Y:$00203F,19,1"		; &1 Fatal-following-error bit (OR)
	CMD"M5190->Y:$00203F,20,1"		; &1 Amp-fault-error bit (OR of motors)

P8004 = P8004 + 1		; for Debug

	; Coordinate system 2 (&2) status bits
;	CMD"M5280->X:$002140,0,1"		; &2 Program-running bit
;	CMD"M5281->Y:$00213F,21,1"		; &2 Circle-radius-error bit
;	CMD"M5282->Y:$00213F,22,1"		; &2 Run-time-error bit
;	CMD"M5284->X:$002140,0,4"		; &2 Continuous motion request
;	CMD"M5287->Y:$00213F,17,1"		; &2 In-position bit (AND of motors)
;	CMD"M5288->Y:$00213F,18,1"		; &2 Warning-following-error bit (OR)
;	CMD"M5289->Y:$00213F,19,1"		; &2 Fatal-following-error bit (OR)
;	CMD"M5290->Y:$00213F,20,1"		; &2 Amp-fault-error bit (OR of motors)

	WAIT_TIMER_FNC			; Wait(1000msec)

; ---------
; for Debug
; P8005 = P8005 + 1		; for Debug
; IF( I5 != 2 )			; for Debug(USED PLC1..31)
; 	P8006 = P8006 + 1	; for Debug
; ELSE					; for Debug
; ENDIF					; for Debug
; for Debug
; ---------

	ENABLE PLC2			; BiSS Processing
	ENABLE PLC3			; System Check
	ENABLE PLC4			; Servo Ready Processing
	ENABLE PLC5			; Receiving Command Processing
	ENABLE PLC6			; Motor Status Processing
	ENABLE PLC7			; start adjusting gap position

P8007 = P8007 + 1		; for Debug

;	DISABLE PLC2
;	DISABLE PLC3
;	DISABLE PLC4
;	DISABLE PLC5
;	DISABLE PLC6
;	DISABLE PLC7

P8008 = P8008 + 1		; for Debug

	DISABLE PLC1		; Disable PLC1

P8009 = P8009 + 1		; for Debug

CLOSE


; ======================================
; ======================================
;	calculate BiSS-C data
;		PLC2
; ======================================
; ======================================
OPEN PLC2 CLEAR

P8010 = P8010 + 1				; for Debug
IF( P8010 > 2262 )				; for Debug(2262=1000msec/442usec)
	P8010 = 0					; for Debug
	P8011 = P8011 + 1			; for Debug
	IF( P8011 > 10000000 )		; for Debug
		P8011 = 0				; for Debug
	ELSE						; for Debug
	ENDIF						; for Debug
	PMAC_SEQ_COUT_REG = P8011	; for Debug
ELSE							; for Debug
ENDIF							; for Debug

	IF( BISS_INIT_REG = 0 )
		REQ_INIT_END_REG = 0					; Set 1 in  PLC1. After start, set 0 in PLC2
		BISS_C_TIMER_FNC						; wait(500msec)
		BISS_C_TIMER_FNC						; wait(500msec)

		CMD"WX:BISS_GLB_1_4_X_REG,BISS_GLB_DAT"	; setup BiSS(ch1-4)
		CMD"WX:BISS_GLB_5_8_X_REG,BISS_GLB_DAT"	; setup BiSS(ch5-8)

		CMD"WX:BISS_CH1_X_REG,BISS_CHA_DAT"		; setup BiSS(ch1)
		CMD"WX:BISS_CH2_X_REG,BISS_CHA_DAT"		; setup BiSS(ch2)
		CMD"WX:BISS_CH3_X_REG,BISS_CHA_DAT"		; setup BiSS(ch3)
		CMD"WX:BISS_CH4_X_REG,BISS_CHA_DAT"		; setup BiSS(ch4)
		CMD"WX:BISS_CH5_X_REG,BISS_CHA_DAT"		; setup BiSS(ch5)
		CMD"WX:BISS_CH6_X_REG,BISS_CHA_DAT"		; setup BiSS(ch6)
		CMD"WX:BISS_CH7_X_REG,BISS_CHA_DAT"		; setup BiSS(ch7)
		CMD"WX:BISS_CH8_X_REG,BISS_CHA_DAT"		; setup BiSS(ch8)

		BISS_INIT_REG = 1

		BISS_C_TIMER_FNC						; wait(500msec)

		M162 = 0								; MOT[#1] axis initial value (real axis)
		M262 = 0								; MOT[#2] axis initial value (real axis)
		M362 = 0								; MOT[#3] axis initial value (real axis)
		M462 = 0								; MOT[#4] axis initial value (real axis)
		M1762 = 0								; MOT[#17] axis initial value (MOT[#1] virtual axis)
		M1862 = 0								; MOT[#18] axis initial value (MOT[#2] virtual axis)
		M2062 = 0								; MOT[#20] axis initial value (MOT[#3] virtual axis)
		M2162 = 0								; MOT[#21] axis initial value (MOT[#4] virtual axis)

	ELSE
	ENDIF


	BISS_STAT_REG  = BISS_NORMAL		; BiSS-C Normal

	BISS_TMO_1_REG = BISS_NORMAL		; GAP(#1)
	BISS_TMO_2_REG = BISS_NORMAL		; GAP(#2)
	BISS_TMO_3_REG = BISS_NORMAL		; GAP(#3)
	BISS_TMO_4_REG = BISS_NORMAL		; GAP(#4)

	; -----------
	; BiSS-C Timeout
	; -----------
	IF( BISS_1_TMOUT_REG = BISS_TMOUT OR BISS_2_TMOUT_REG = BISS_TMOUT OR BISS_3_TMOUT_REG = BISS_TMOUT OR BISS_4_TMOUT_REG = BISS_TMOUT )

		BISS_STAT_REG = BISS_ERROR		; BiSS-C Error

		; -------
		; MOT[#1]
		; -------
		IF( BISS_1_TMOUT_REG = BISS_TMOUT )
			BISS_TMO_1_REG = BISS_ERROR
		ELSE
		ENDIF

		; -------
		; MOT[#2]
		; -------
		IF( BISS_2_TMOUT_REG = BISS_TMOUT )
			BISS_TMO_2_REG = BISS_ERROR
		ELSE
		ENDIF

		; -------
		; MOT[#3]
		; -------
		IF( BISS_3_TMOUT_REG = BISS_TMOUT )
			BISS_TMO_3_REG = BISS_ERROR
		ELSE
		ENDIF

		; -------
		; MOT[#4]
		; -------
		IF( BISS_4_TMOUT_REG = BISS_TMOUT )
			BISS_TMO_4_REG = BISS_ERROR
		ELSE
		ENDIF

	ELSE

	ENDIF


	; ----------------
	; BiSS-C CRC Error
	; ----------------
;	IF( BISS_1_CRCER_REG = BISS_CRCER OR BISS_2_CRCER_REG = BISS_CRCER OR BISS_3_CRCER_REG = BISS_CRCER OR BISS_4_CRCER_REG = BISS_CRCER )
;
;		BISS_STAT_REG = BISS_ERROR		; BiSS-C Error
;
;		; -------
;		; MOT[#1]
;		; -------
;		IF( BISS_1_CRCER_REG = BISS_CRCER )
;			BISS_TMO_1_REG = BISS_ERROR
;		ELSE
;;			BISS_TMO_1_REG = BISS_NORMAL
;		ENDIF
;
;		; -------
;		; MOT[#2]
;		; -------
;		IF( BISS_2_CRCER_REG = BISS_CRCER )
;			BISS_TMO_2_REG = BISS_ERROR
;		ELSE
;;			BISS_TMO_2_REG = BISS_NORMAL
;		ENDIF
;
;		; -------
;		; MOT[#3]
;		; -------
;		IF( BISS_3_CRCER_REG = BISS_CRCER )
;			BISS_TMO_3_REG = BISS_ERROR
;		ELSE
;;			BISS_TMO_3_REG = BISS_NORMAL
;		ENDIF
;
;		; -------
;		; MOT[#4]
;		; -------
;		IF( BISS_4_CRCER_REG = BISS_CRCER )
;			BISS_TMO_4_REG = BISS_ERROR
;		ELSE
;;			BISS_TMO_4_REG = BISS_NORMAL
;		ENDIF
;	ELSE
;	ENDIF


	; -----------------------
	; check received data
	; -----------------------
	TMP1_REG = 0
	TMP1_REG = 0
	; -------------------
	; Biss(#1)[GAP-UPPER]
	; -------------------
	IF( BISS_1_U_REG = $00 AND BISS_1_D_REG = $000000 )
		TMP1_REG = TMP1_REG + 1
;		BISS_TMO_1_REG = BISS_CRCER			; GAP(#1)
		BISS_TMO_1_REG = BISS_ERROR			; GAP(#1)
	ELSE
		IF( BISS_1_U_REG = $FF AND BISS_1_D_REG = $FFFFFF )
			TMP1_REG = TMP1_REG + 1
;			BISS_TMO_1_REG = BISS_TMOUT		; GAP(#1)
			BISS_TMO_1_REG = BISS_ERROR		; GAP(#1)
		ELSE
		ENDIF
	ENDIF
	; -------------------
	; Biss(#2)[GAP-UPPER]
	; -------------------
	IF( BISS_2_U_REG = $00 AND BISS_2_D_REG = $000000 )
		TMP1_REG = TMP1_REG + 1
;		BISS_TMO_2_REG = BISS_CRCER			; GAP(#2)
		BISS_TMO_2_REG = BISS_ERROR			; GAP(#2)
	ELSE
		IF( BISS_2_U_REG = $FF AND BISS_2_D_REG = $FFFFFF )
			TMP1_REG = TMP1_REG + 1
;			BISS_TMO_2_REG = BISS_TMOUT		; GAP(#2)
			BISS_TMO_2_REG = BISS_ERROR		; GAP(#2)
		ELSE
		ENDIF
	ENDIF

	; -------------------
	; Biss(#3)[GAP-LOWER]
	; -------------------
	IF( BISS_3_U_REG = $00 AND BISS_3_D_REG = $000000 )
		TMP1_REG = TMP1_REG + 1
;		BISS_TMO_3_REG = BISS_CRCER			; GAP(#3)
		BISS_TMO_3_REG = BISS_ERROR			; GAP(#3)
	ELSE
		IF( BISS_3_U_REG = $FF AND BISS_3_D_REG = $FFFFFF )
			TMP1_REG = TMP1_REG + 1
;			BISS_TMO_3_REG = BISS_TMOUT		; GAP(#3)
			BISS_TMO_3_REG = BISS_ERROR		; GAP(#3)
		ELSE
		ENDIF
	ENDIF
	; -------------------
	; Biss(#4)[GAP-LOWER]
	; -------------------
	IF( BISS_4_U_REG = $00 AND BISS_4_D_REG = $000000 )
		TMP1_REG = TMP1_REG + 1
;		BISS_TMO_4_REG = BISS_CRCER			; GAP(#4)
		BISS_TMO_4_REG = BISS_ERROR			; GAP(#4)
	ELSE
		IF( BISS_4_U_REG = $FF AND BISS_4_D_REG = $FFFFFF )
			TMP1_REG = TMP1_REG + 1
;			BISS_TMO_4_REG = BISS_TMOUT		; GAP(#4)
			BISS_TMO_4_REG = BISS_ERROR		; GAP(#4)
		ELSE
		ENDIF
	ENDIF


	IF( TMP1_REG != 0 )
		INITIALIZE_REG = SYS_INTLCK			; Initialization finished state
		BISS_STAT_REG  = BISS_ERROR			; BiSS-C Timeout
	ELSE
	ENDIF


	; ----------------
	;	When BiSS communication is normal
	; ----------------
	IF( BISS_STAT_REG = BISS_NORMAL )

		; -----------
		;	MOT(#1)
		;	At positeve case
		; -----------
		MOT_1_U_REG = BISS_1_U_REG & $0000FF
		IF( MOT_1_U_REG < $80 )
			MOT_1_POS_REG = (BISS_1_U_REG * $1000000 + BISS_1_D_REG)

		; -----------
		;	At negative case (calculate with two's complement)
		; -----------
		ELSE
			MOT_1_D_REG   = BISS_1_D_REG ^ $FFFFFF
			MOT_1_TMP_REG = BISS_1_U_REG ^ $0000FF
			MOT_1_POS_REG = (BISS_1_U_REG * $1000000 + BISS_1_D_REG + 1)
		ENDIF

;		M162  = (MOT_1_POS_REG + MOT_1_OFFSET_REG) * (I0108 * 32)		; 0.001um = 1nm
		M1062 = (MOT_1_POS_REG + MOT_1_OFFSET_REG) * (I0108 * 32)		; 0.001um = 1nm

		; -----------
		;	MOT(#2)
		;	At positive case
		; -----------
		MOT_2_U_REG = BISS_2_U_REG & $0000FF
		IF( MOT_2_U_REG < $80 )
			MOT_2_POS_REG = (BISS_2_U_REG * $1000000 + BISS_2_D_REG)

		; -----------
		;	At negative case (calculate with two's complement)
		; -----------
		ELSE
			MOT_2_D_REG   = BISS_2_D_REG ^ $FFFFFF
			MOT_2_TMP_REG = BISS_2_U_REG ^ $0000FF
			MOT_2_POS_REG = (BISS_2_U_REG * $1000000 + BISS_2_D_REG + 1)
		ENDIF

;		M262  = (MOT_2_POS_REG + MOT_2_OFFSET_REG) * (I0208 * 32)		; 0.001um = 1nm
		M1162 = (MOT_2_POS_REG + MOT_2_OFFSET_REG) * (I0208 * 32)		; 0.001um = 1nm


		; -----------
		;	MOT(#3)
		;	At positive case
		; -----------
		MOT_3_U_REG = BISS_3_U_REG & $0000FF
		IF( MOT_3_U_REG < $80 )
			MOT_3_POS_REG = (BISS_3_U_REG * $1000000 + BISS_3_D_REG)

		; -----------
		;	At negative case(calculate with two's complement)
		; -----------
		ELSE
			MOT_3_D_REG   = BISS_3_D_REG ^ $FFFFFF
			MOT_3_TMP_REG = BISS_3_U_REG ^ $0000FF
			MOT_3_POS_REG = (BISS_3_U_REG * $1000000 + BISS_3_D_REG + 1)
		ENDIF

;		M362  = (MOT_3_POS_REG + MOT_3_OFFSET_REG) * (I0308 * 32)		; 0.001um = 1nm
		M1262 = (MOT_3_POS_REG + MOT_3_OFFSET_REG) * (I0308 * 32)		; 0.001um = 1nm

		; -----------
		;	MOT(#4)
		;	At positive case
		; -----------
		MOT_4_U_REG = BISS_4_U_REG & $0000FF
		IF( MOT_4_U_REG < $80 )
			MOT_4_POS_REG = (BISS_4_U_REG * $1000000 + BISS_4_D_REG)

		; -----------
		;	At negative case (calculate with two's complement)
		; -----------
		ELSE
			MOT_4_D_REG   = BISS_4_D_REG ^ $FFFFFF
			MOT_4_TMP_REG = BISS_4_U_REG ^ $0000FF
			MOT_4_POS_REG = (BISS_4_U_REG * $1000000 + BISS_4_D_REG + 1)
		ENDIF

;		M462  = (MOT_4_POS_REG + MOT_4_OFFSET_REG) * (I0408 * 32)		; 0.001um = 1nm
		M1362 = (MOT_4_POS_REG + MOT_4_OFFSET_REG) * (I0408 * 32)		; 0.001um = 1nm


		; -----------------------------------
		; Initialization of Rotary Encoder data 
		; -----------------------------------
		IF( BISS_INIT_REG = 1 )
			SV_RDY_TIMER_FNC					; Wait (20msec) Add:2014/04/30

			; --------------------------------------------------
			; Add for ROT get update cycle to IOC (Add 2013/10/13)
			; --------------------------------------------------
			TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
			TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
			TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

			M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
			M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
			M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
			M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

			M1762 = M162
			M1862 = M262
			M2062 = M362
			M2162 = M462

;			MOT_1_POS_REG = ( MOT_1_OFFSET_REG - MOT_1_POS_REG )
;			MOT_2_POS_REG = ( MOT_2_OFFSET_REG - MOT_2_POS_REG )
;			MOT_3_POS_REG = ( MOT_3_OFFSET_REG - MOT_3_POS_REG )
;			MOT_4_POS_REG = ( MOT_4_OFFSET_REG - MOT_4_POS_REG )
;;			INT_0_POS_REG = ( INT_1_POS_REG + INT_2_POS_REG + INT_3_POS_REG + INT_4_POS_REG ) / 2

			BISS_INIT_REG = 2

		ELSE		; if(BISS_INIT_REG)
		ENDIF		; if(BISS_INIT_REG)

		INITIALIZE_REG = SYS_NORMAL


; ---------
; for Debug
	IF( BISS_1_TMOUT_REG = BISS_TMOUT AND P7242 = 0 )
		P7240 = P7240 + 1
	ELSE
		P7241 = P7241 + 1
	ENDIF
	IF( BISS_2_TMOUT_REG = BISS_TMOUT AND P7252 = 0 )
		P7250 = P7250 + 1
	ELSE
		P7251 = P7251 + 1
	ENDIF
	IF( BISS_3_TMOUT_REG = BISS_TMOUT AND P7262 = 0 )
		P7260 = P7260 + 1
	ELSE
		P7261 = P7261 + 1
	ENDIF
	IF( BISS_4_TMOUT_REG = BISS_TMOUT AND P7272 = 0 )
		P7270 = P7270 + 1
	ELSE
		P7271 = P7271 + 1
	ENDIF


	IF( BISS_1_CRCER_REG = BISS_CRCER AND P7202 = 0 )
		P7200 = P7200 + 1
	ELSE
		P7201 = P7201 + 1
	ENDIF
	IF( BISS_2_CRCER_REG = BISS_CRCER AND P7212 = 0)
		P7210 = P7210 + 1
	ELSE
		P7211 = P7211 + 1
	ENDIF
	IF( BISS_3_CRCER_REG = BISS_CRCER AND P7222 = 0 )
		P7220 = P7220 + 1
	ELSE
		P7221 = P7221 + 1
	ENDIF
	IF( BISS_4_CRCER_REG = BISS_CRCER AND P7232 = 0 )
		P7230 = P7230 + 1
	ELSE
		P7231 = P7231 + 1
	ENDIF


	P7202 = BISS_1_CRCER_REG
	P7212 = BISS_2_CRCER_REG
	P7222 = BISS_3_CRCER_REG
	P7232 = BISS_4_CRCER_REG

	P7242 = BISS_1_TMOUT_REG
	P7252 = BISS_2_TMOUT_REG
	P7262 = BISS_3_TMOUT_REG
	P7272 = BISS_4_TMOUT_REG
; for Debug
; ---------

; --------------
; Add:2014/11/20
	TMP1_REG = (MOT_1_OFFSET_REG - MOT_1_POS_REG)
	TMP2_REG = (MOT_2_OFFSET_REG - MOT_2_POS_REG)
	TMP3_REG = (MOT_3_OFFSET_REG - MOT_3_POS_REG)
	TMP4_REG = (MOT_4_OFFSET_REG - MOT_4_POS_REG)

	M962  = ( TMP1_REG + TMP2_REG + TMP3_REG + TMP4_REG ) * 96 * 32 / 2		; GAP POSITION
	M1462 = ( TMP1_REG + TMP2_REG - TMP3_REG - TMP4_REG ) * 96 * 32 / 4		; VERTICAL OFFSET

	M2262 = ( TMP1_REG - TMP3_REG ) * 96 * 32 / 2		; VERTICAL OFFSET(UpStream)
	M2362 = ( TMP2_REG - TMP4_REG ) * 96 * 32 / 2		; VERTICAL OFFSET(DownStream)
; Add:2014/11/20
; --------------

	ELSE		; if(BISS_NORMAL)

		INITIALIZE_REG = SYS_INTLCK

	ENDIF		; if(BISS_NORMAL)

CLOSE



; ======================================
; ======================================
;	check SYSTEM-Status
;		PLC3
; ======================================
; ======================================
OPEN PLC3 CLEAR


	TMP2_REG = 0
	TMP2_REG = 0

	; ------------------------------
	; Get EMERGENCY-STOP button status
	; from J6_IN1_7
	; ------------------------------
	IF( EMERGENCY_REG = EMERGENCY_STOP )
		IF( EMERGENCY_STAT_REG != EMERGENCY_STOP )
P6909 = P6909 + 1		; for Debug

			EMERGENCY_STAT_REG = EMERGENCY_STOP		; EMERGENCY STOP button was pushed

			TMP2_REG = 1
		ELSE
		ENDIF
	ELSE
		IF( EMERGENCY_STAT_REG = EMERGENCY_STOP )
			EMERGENCY_STAT_REG = SYS_NORMAL			; EMERGENCY STOP button was released
		ELSE
		ENDIF

	ENDIF

	; --------------------------------------
	;	check servo amp fault
	;	Rev 2013/10/09
	; --------------------------------------
	TMP1_REG = 0								; Add 2013/10/09
	TMP1_REG = 0								; Add 2013/10/09

	; ----------
	; MOT[#1-#4]
	; ----------
;	IF( PRG1_FLT_ERR = AMP_FAULT )
	IF( AMP_FLT_1_REG = AMP_FAULT OR AMP_FLT_2_REG = AMP_FAULT OR AMP_FLT_3_REG = AMP_FAULT OR AMP_FLT_4_REG = AMP_FAULT )
		IF( INITIALIZE_REG = SYS_NORMAL )
P6910 = P6910 + 1		; for Debug

			INITIALIZE_REG = SYS_INTLCK

			TMP2_REG = 1
		ELSE
		ENDIF
	ELSE			; if(AMP_FAULT)
;		INITIALIZE_REG = SYS_NORMAL
		TMP1_REG       = TMP1_REG + 1					; Add 2013/10/09
	ENDIF			; if(AMP_FAULT)

	IF( TMP1_REG = 1 )
		INITIALIZE_REG = SYS_NORMAL
	ELSE
	ENDIF

	; --------------------------------------
	;	check deviation error
	;	Rev 2013/10/09
	; --------------------------------------
	TMP1_REG = 0								; Add 2013/10/09
	TMP1_REG = 0								; Add 2013/10/09
	; ----------
	; MOT[#1-#4]
	; ----------
	IF( PRG1_FLW_ERR = DVI_FAULT )
		IF( DEVIATION_STAT_REG = DVI_NORMAL )
P6912 = P6912 + 1		; for Debug

			DEVIATION_STAT_REG = DVI_ERROR

			TMP2_REG = 1
		ELSE
		ENDIF
	ELSE			; if(DVI_FAULT)
;		DEVIATION_STAT_REG = DVI_NORMAL
		TMP1_REG = TMP1_REG + 1					; Add 2013/10/09
	ENDIF			; if(DVI_FAULT)

	IF( TMP1_REG = 1 )
		DEVIATION_STAT_REG = DVI_NORMAL
	ELSE
	ENDIF

; --------------
; Add:2014/09/26
	; ---------------
	; Amp Alarm(Mx23)
	; ---------------
	IF( AMP_ALM_1_REG = AMP_FAULT OR AMP_ALM_2_REG = AMP_FAULT OR AMP_ALM_3_REG = AMP_FAULT OR AMP_ALM_4_REG = AMP_FAULT )
		IF( MOT_SRDY_1_REG = SERVO_RDY__ON OR MOT_SRDY_2_REG = SERVO_RDY__ON OR MOT_SRDY_3_REG = SERVO_RDY__ON OR MOT_SRDY_4_REG = SERVO_RDY__ON )
			IF( AMP_ALM_STS_REG = 0 )
P6900 = P6900 + 1		; for Debug
				AMP_ALM_STS_REG = 1

				TMP2_REG = 1

			ELSE
			ENDIF

		ELSE		; if(MOT_SRDY_x_REG=SERVO_RDY__ON)

			IF( AMP_ALM_STS_REG > 0 )
P6901 = P6901 + 1		; for Debug
				AMP_ALM_STS_REG = 0
			ELSE
			ENDIF
		ENDIF		; if(MOT_SRDY_x_REG=SERVO_RDY__ON)

	ELSE		; if(AMP_ALM_1_REG=AMP_FAULT)

		IF( AMP_ALM_STS_REG > 0 )
P6902 = P6902 + 1		; for Debug
			AMP_ALM_STS_REG = 0
		ELSE
		ENDIF

	ENDIF		; if(AMP_ALM_1_REG=AMP_FAULT)
; Add:2014/09/26
; --------------


	IF( TMP2_REG = 1 )
P6908 = P6908 + 1		; for Debug

		CMD^K

		SRDY_1_OUT = SERVO_RDY_OFF				; Servo OFF[#1](Add 2013/10/08)
		SRDY_2_OUT = SERVO_RDY_OFF				; Servo OFF[#2](Add 2013/10/08)
		SRDY_3_OUT = SERVO_RDY_OFF				; Servo OFF[#3](Add 2013/10/08)
		SRDY_4_OUT = SERVO_RDY_OFF				; Servo OFF[#4](Add 2013/10/08)

		LOCK_1_STAT_REG = UNLOCK_OCCUR
		LOCK_2_STAT_REG = UNLOCK_OCCUR
		LOCK_3_STAT_REG = UNLOCK_OCCUR
		LOCK_4_STAT_REG = UNLOCK_OCCUR

		GAP__BRK_ON_REG = GAP__BRK_ON_INI		; clear count
		GAP__BRAKE_REG  = SERVO_RDY__ON			; set brake-on
		GAP__BRAKE_STAT = GAP__BRAKE_REG		; set brake-on
		DRIVE_MODE_REG  = DRIVE_STOP			; Add 2014/04/30

		PRG_EXEC_REG    = 0

; --------------
; Add:2014/11/20
		COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
		COMP_01_VAL_REG = 0
		COMP_17_VAL_REG = 0
		COMP_03_VAL_REG = 0
		COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------

		IF( PRG_GAP__INTLK = 1 )				; execute GAP-Eva program
			PRG_GAP__INTLK = 0					; clear GAP-Eva
			PRG_GAP__START = 0

			MOTOR_1_JOG  = GAP__INTLK_SPD		; set speed
			MOTOR_2_JOG  = GAP__INTLK_SPD
			MOTOR_3_JOG  = GAP__INTLK_SPD
			MOTOR_4_JOG  = GAP__INTLK_SPD
			MOTOR_17_JOG = GAP__INTLK_SPD
			MOTOR_18_JOG = GAP__INTLK_SPD
			MOTOR_20_JOG = GAP__INTLK_SPD
			MOTOR_21_JOG = GAP__INTLK_SPD

			MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_17_JOG_JOG = GAP__INTLK_SPD
			MOTOR_18_JOG_JOG = GAP__INTLK_SPD
			MOTOR_20_JOG_JOG = GAP__INTLK_SPD
			MOTOR_21_JOG_JOG = GAP__INTLK_SPD

		ELSE
		ENDIF

		; -------------------------------
		; separate mode or adjusting mode
		; -------------------------------
		IF( ACTIVE_MODE_REG = SPA_MODE OR ADJ_MODE__REG = ADJ__START )
			IF( ADJ_MODE__REG = ADJ__START )
P6913 = P6913 + 1		; for Debug
				ADJ_MODE__REG = ADJ_FINISH
				ADJ_PREMD_REG = ADJ_FINISH
				ADJ_COUNT_REG = ADJ_RETRY_MAX + 1
			ELSE
			ENDIF

			IF( GAP_SPARATE_SPD != 0 )
;			IF( GAP_SPARATE_SPD != 0 AND GAP_SPARATE_SPD != SPA_SPD )
				MOTOR_1_JOG  = GAP_SPARATE_SPD			; Restore velocity setting
				MOTOR_2_JOG  = GAP_SPARATE_SPD
				MOTOR_3_JOG  = GAP_SPARATE_SPD
				MOTOR_4_JOG  = GAP_SPARATE_SPD
				MOTOR_17_JOG = GAP_SPARATE_SPD
				MOTOR_18_JOG = GAP_SPARATE_SPD
				MOTOR_20_JOG = GAP_SPARATE_SPD
				MOTOR_21_JOG = GAP_SPARATE_SPD

				MOTOR_1_JOG_JOG  = GAP_SPARATE_SPD		; Restore velocity setting
				MOTOR_2_JOG_JOG  = GAP_SPARATE_SPD
				MOTOR_3_JOG_JOG  = GAP_SPARATE_SPD
				MOTOR_4_JOG_JOG  = GAP_SPARATE_SPD
				MOTOR_17_JOG_JOG = GAP_SPARATE_SPD
				MOTOR_18_JOG_JOG = GAP_SPARATE_SPD
				MOTOR_20_JOG_JOG = GAP_SPARATE_SPD
				MOTOR_21_JOG_JOG = GAP_SPARATE_SPD

				GAP_SPARATE_SPD = 0
			ELSE
			ENDIF

			; --------------------------------------
			;	X axis definition
			; --------------------------------------
			; --------------------------------------
			;	#17 I variables setting
			; --------------------------------------
			I1700 = MOTOR_ACTIVE				; Motor Activation
			I1702 = DAC_OUTPUT_CH01_REG			; Command Output Address
			I1706 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#1 I variables setting
			; --------------------------------------
			I0102 = DAC_OFFSET_CH18_REG			; Command Output Address
			I0103 = BISS_ADD_1_2				; Position Loop Feedback Address
			I0104 = BISS_ADD_1_2				; Velocity Loop Feedback Address
			I0106 = MOTOR_FOLW					; Position Following Enable and Mode

			I0108 = I1708						; Position Scale Factor
			I0109 = I1708						; Velocity-Loop Scale Factor

			I0124 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0130 = (PROPO_GAIN_UP)				; PID Proportional Gain

			; --------------------------------------
			;	A axis definition
			; --------------------------------------
			; --------------------------------------
			;	#18 I variables setting
			; --------------------------------------
			I1800 = MOTOR_ACTIVE				; Motor Activation
			I1802 = DAC_OUTPUT_CH02_REG			; Command Output Address
			I1806 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#2 I variables setting
			; --------------------------------------
			I0202 = DAC_OFFSET_CH17_REG			; Command Output Address
			I0203 = BISS_SUB_1_2				; Position Loop Feedback Address
			I0204 = BISS_SUB_1_2				; Velocity Loop Feedback Address
			I0206 = MOTOR_FOLW					; Position Following Enable and Mode

			I0208 = I1708						; Position Scale Factor
			I0209 = I1708						; Velocity-Loop Scale Factor

			I0224 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0230 = (2*PROPO_GAIN_UP)			; PID Proportional Gain

			; --------------------------------------
			;	Y axis definition
			; --------------------------------------
			; --------------------------------------
			;	#20 I variables setting
			; --------------------------------------
			I2000 = MOTOR_ACTIVE				; Motor Activation
			I2002 = DAC_OUTPUT_CH03_REG			; Command Output Address
			I2006 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#3 I variables setting
			; --------------------------------------
			I0302 = DAC_OFFSET_CH21_REG			; Command Output Address
			I0303 = BISS_ADD_3_4				; Position Loop Feedback Address
			I0304 = BISS_ADD_3_4				; Velocity Loop Feedback Address
			I0306 = MOTOR_FOLW					; Position Following Enable and Mode

			I0308 = I2008						; Position Scale Factor
			I0309 = I2008						; Velocity-Loop Scale Factor

			I0324 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0330 = (PROPO_GAIN_DN)				; PID Proportional Gain


			; --------------------------------------
			;	B axis definition
			; --------------------------------------
			; --------------------------------------
			;	#21 I variables setting
			; --------------------------------------
			I2100 = MOTOR_ACTIVE				; Motor Activation
			I2102 = DAC_OUTPUT_CH04_REG			; Command Output Address
			I2106 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#4 I variables setting
			; --------------------------------------
			I0402 = DAC_OFFSET_CH20_REG			; Command Output Address
			I0403 = BISS_SUB_3_4				; Position Loop Feedback Address
			I0404 = BISS_SUB_3_4				; Velocity Loop Feedback Address
			I0406 = MOTOR_FOLW					; Position Following Enable and Mode

			I0408 = I2008						; Position Scale Factor
			I0409 = I2008						; Velocity-Loop Scale Factor

			I0424 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0430 = (2*PROPO_GAIN_DN)			; PID Proportional Gain

; --------------
; Add:2015/05/29 Remedy for stack

		SV_RDY_TIMER_FNC

		TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
		TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
		TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

		M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
		M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
		M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
		M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

		M1762 = M162
		M1862 = M262
		M2062 = M362
		M2162 = M462

		SV_RDY_TIMER_FNC

; Add:2015/05/29
; --------------

		ELSE
		ENDIF

		IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617

	ELSE
	ENDIF


	; ------------------------------
	; Run-time Error
	; ------------------------------
	; -----------------------------
	; &1 Run-Time Error[GAP(#1-#4)]
	; -----------------------------
	IF( TMP2_REG = 0 )
		IF( ACTIVE_MODE_REG != SPA_MODE AND ADJ_MODE__REG != ADJ__START )
			IF( SRDY_1_OUT = SERVO_RDY__ON AND SRDY_2_OUT = SERVO_RDY__ON AND SRDY_3_OUT = SERVO_RDY__ON AND SRDY_4_OUT = SERVO_RDY__ON )
				IF( PRG1_RUN_ERR = RUN_TIME_ERR )
					CMD^K

					SRDY_1_OUT = SERVO_RDY_OFF				; Servo OFF[#1]
					SRDY_2_OUT = SERVO_RDY_OFF				; Servo OFF[#2]
					SRDY_3_OUT = SERVO_RDY_OFF				; Servo OFF[#3]
					SRDY_4_OUT = SERVO_RDY_OFF				; Servo OFF[#4]

					LOCK_1_STAT_REG = UNLOCK_OCCUR
					LOCK_2_STAT_REG = UNLOCK_OCCUR
					LOCK_3_STAT_REG = UNLOCK_OCCUR
					LOCK_4_STAT_REG = UNLOCK_OCCUR

					GAP__BRAKE_STAT = SERVO_RDY__ON
					GAP__BRAKE_REG  = SERVO_RDY__ON
					GAP__BRK_ON_REG = GAP__BRK_ON_INI
					DRIVE_MODE_REG  = DRIVE_STOP			; Add 2014/04/30

					IF( PRG_GAP__INTLK = 1 )				; execute GAP-Eva program
						PRG_GAP__INTLK = 0					; clear GAP-Eva
						PRG_GAP__START = 0

						MOTOR_1_JOG  = GAP__INTLK_SPD
						MOTOR_2_JOG  = GAP__INTLK_SPD
						MOTOR_3_JOG  = GAP__INTLK_SPD
						MOTOR_4_JOG  = GAP__INTLK_SPD
						MOTOR_17_JOG = GAP__INTLK_SPD
						MOTOR_18_JOG = GAP__INTLK_SPD
						MOTOR_20_JOG = GAP__INTLK_SPD
						MOTOR_21_JOG = GAP__INTLK_SPD

						MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
						MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
						MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
						MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
						MOTOR_17_JOG_JOG = GAP__INTLK_SPD
						MOTOR_18_JOG_JOG = GAP__INTLK_SPD
						MOTOR_20_JOG_JOG = GAP__INTLK_SPD
						MOTOR_21_JOG_JOG = GAP__INTLK_SPD
					ELSE
					ENDIF

					PRG_EXEC_REG    = 0

; --------------
; Add:2014/11/20
					COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
					COMP_01_VAL_REG = 0
					COMP_17_VAL_REG = 0
					COMP_03_VAL_REG = 0
					COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------

					IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617

				ELSE
				ENDIF
			ELSE
			ENDIF

		ELSE		; if(!SPA_MODE & !ADJ__START)

			IF( SRDY_1_OUT = SERVO_RDY__ON OR SRDY_2_OUT = SERVO_RDY__ON OR SRDY_3_OUT = SERVO_RDY__ON OR SRDY_4_OUT = SERVO_RDY__ON )
				IF( PRG1_RUN_ERR = RUN_TIME_ERR )

					CMD^K

					IF( SRDY_1_OUT = SERVO_RDY__ON )
						SRDY_1_OUT = SERVO_RDY_OFF			; Servo OFF[#1]
						LOCK_1_STAT_REG = UNLOCK_OCCUR
					ELSE
					ENDIF

					IF( SRDY_2_OUT = SERVO_RDY__ON )
						SRDY_2_OUT = SERVO_RDY_OFF			; Servo OFF[#2]
						LOCK_2_STAT_REG = UNLOCK_OCCUR
					ELSE
					ENDIF

					IF( SRDY_3_OUT = SERVO_RDY__ON )
						SRDY_3_OUT = SERVO_RDY_OFF			; Servo OFF[#3]
						LOCK_3_STAT_REG = UNLOCK_OCCUR
					ELSE
					ENDIF

					IF( SRDY_4_OUT = SERVO_RDY__ON )
						SRDY_4_OUT = SERVO_RDY_OFF			; Servo OFF[#4]
						LOCK_4_STAT_REG = UNLOCK_OCCUR
					ELSE
					ENDIF

					GAP__BRAKE_STAT = SERVO_RDY__ON
					GAP__BRAKE_REG  = SERVO_RDY__ON
					GAP__BRK_ON_REG = GAP__BRK_ON_INI

					PRG_EXEC_REG    = 0

; --------------
; Add:2014/11/20
					COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
					COMP_01_VAL_REG = 0
					COMP_17_VAL_REG = 0
					COMP_03_VAL_REG = 0
					COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------


					IF( ADJ_MODE__REG = ADJ__START )
P6914 = P6914 + 1		; for Debug
						ADJ_MODE__REG = ADJ_FINISH
						ADJ_COUNT_REG = ADJ_RETRY_MAX + 1
					ELSE
					ENDIF

					IF( GAP_SPARATE_SPD != 0 )
;					IF( GAP_SPARATE_SPD != 0 AND GAP_SPARATE_SPD != SPA_SPD )
						MOTOR_1_JOG  = GAP_SPARATE_SPD			; Restore velocity setting
						MOTOR_2_JOG  = GAP_SPARATE_SPD
						MOTOR_3_JOG  = GAP_SPARATE_SPD
						MOTOR_4_JOG  = GAP_SPARATE_SPD
						MOTOR_17_JOG = GAP_SPARATE_SPD
						MOTOR_18_JOG = GAP_SPARATE_SPD
						MOTOR_20_JOG = GAP_SPARATE_SPD
						MOTOR_21_JOG = GAP_SPARATE_SPD

						MOTOR_1_JOG_JOG  = GAP_SPARATE_SPD		; Restore velocity setting
						MOTOR_2_JOG_JOG  = GAP_SPARATE_SPD
						MOTOR_3_JOG_JOG  = GAP_SPARATE_SPD
						MOTOR_4_JOG_JOG  = GAP_SPARATE_SPD
						MOTOR_17_JOG_JOG = GAP_SPARATE_SPD
						MOTOR_18_JOG_JOG = GAP_SPARATE_SPD
						MOTOR_20_JOG_JOG = GAP_SPARATE_SPD
						MOTOR_21_JOG_JOG = GAP_SPARATE_SPD

						GAP_SPARATE_SPD = 0
					ELSE
					ENDIF

					; --------------------------------------
					;	X axis definition
					; --------------------------------------
					; --------------------------------------
					;	#17 I variables setting
					; --------------------------------------
					I1700 = MOTOR_ACTIVE				; Motor Activation
					I1702 = DAC_OUTPUT_CH01_REG			; Command Output Address
					I1706 = MOTOR_FOLW					; Position Following Enable and Mode

					; --------------------------------------
					;	#1 I variables setting
					; --------------------------------------
					I0102 = DAC_OFFSET_CH18_REG			; Motor Activation
					I0103 = BISS_ADD_1_2				; Position Loop Feedback Address
					I0104 = BISS_ADD_1_2				; Velocity Loop Feedback Address
					I0106 = MOTOR_FOLW					; Position Following Enable and Mode

					I0108 = I1708						; Position Scale Factor
					I0109 = I1708						; Velocity-Loop Scale Factor

					I0124 = MOTOR_FLAG_VAL				; Flag Mode Control

					I0130 = (PROPO_GAIN_UP)				; PID Proportional Gain

					; --------------------------------------
					;	A axis definition
					; --------------------------------------
					; --------------------------------------
					;	#18 I variables setting
					; --------------------------------------
					I1800 = MOTOR_ACTIVE				; Motor Activation
					I1802 = DAC_OUTPUT_CH02_REG			; Command Output Address
					I1806 = MOTOR_FOLW					; Position Following Enable and Mode

					; --------------------------------------
					;	#2 I variables setting
					; --------------------------------------
					I0202 = DAC_OFFSET_CH17_REG			; Command Output Address
					I0203 = BISS_SUB_1_2				; Position Loop Feedback Address
					I0204 = BISS_SUB_1_2				; Velocity Loop Feedback Address
					I0206 = MOTOR_FOLW					; Position Following Enable and Mode

					I0208 = I1708						; Position Scale Factor
					I0209 = I1708						; Velocity-Loop Scale Factor

					I0224 = MOTOR_FLAG_VAL				; Flag Mode Control

					I0230 = (2*PROPO_GAIN_UP)			; PID Proportional Gain

					; --------------------------------------
					;	Y axis definition
					; --------------------------------------
					; --------------------------------------
					;	#20 I variables setting
					; --------------------------------------
					I2000 = MOTOR_ACTIVE				; Motor Activation
					I2002 = DAC_OUTPUT_CH03_REG			; Command Output Address
					I2006 = MOTOR_FOLW					; Position Following Enable and Mode

					; --------------------------------------
					;	#3 I variables setting
					; --------------------------------------
					I0302 = DAC_OFFSET_CH21_REG			; Command Output Address
					I0303 = BISS_ADD_3_4				; Position Loop Feedback Address
					I0304 = BISS_ADD_3_4				; Velocity Loop Feedback Address
					I0306 = MOTOR_FOLW					; Position Following Enable and Mode

					I0308 = I2008						; Position Scale Factor
					I0309 = I2008						; Velocity-Loop Scale Factor

					I0324 = MOTOR_FLAG_VAL				; Flag Mode Control

					I0330 = (PROPO_GAIN_DN)				; PID Proportional Gain


					; --------------------------------------
					;	B axis definition
					; --------------------------------------
					; --------------------------------------
					;	#21 I variables setting
					; --------------------------------------
					I2100 = MOTOR_ACTIVE				; Motor Activation
					I2102 = DAC_OUTPUT_CH04_REG			; Command Output Address
					I2106 = MOTOR_FOLW					; Position Following Enable and Mode

					; --------------------------------------
					;	#4 I variables setting
					; --------------------------------------
					I0402 = DAC_OFFSET_CH20_REG			; Command Output Address
					I0403 = BISS_SUB_3_4				; Position Loop Feedback Address
					I0404 = BISS_SUB_3_4				; Velocity Loop Feedback Address
					I0406 = MOTOR_FOLW					; Position Following Enable and Mode

					I0408 = I2008						; Position Scale Factor
					I0409 = I2008						; Velocity-Loop Scale Factor

					I0424 = MOTOR_FLAG_VAL				; Flag Mode Control

					I0430 = (2*PROPO_GAIN_DN)			; PID Proportional Gain

; --------------
; Add:2015/05/29 Remedy for stack

		SV_RDY_TIMER_FNC

		TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
		TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
		TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

		M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
		M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
		M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
		M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

		M1762 = M162
		M1862 = M262
		M2062 = M362
		M2162 = M462

		SV_RDY_TIMER_FNC

; Add:2015/05/29
; --------------

					IOC_RCV_RDY_REG = RCV__READY_VAL		; ready 20150617

				ELSE
				ENDIF
			ELSE
			ENDIF

		ENDIF		; if(!SPA_MODE & !ADJ__START)
	ELSE
	ENDIF


CLOSE



; ======================================
; ======================================
;	check Servo-Ready
;		PLC4
; ======================================
; ======================================
OPEN PLC4 CLEAR


	TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
	TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
	TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

	; ---------
	; MOTOR(#1)
	; ---------
	IF( MOT_SRDY_1_REG = SERVO_RDY__ON )
		IF( SRDY_1_OUT = SERVO_RDY_OFF AND GAP__BRAKE_INIT = 0 )
P7500 = P7500 + 1		; for Debug

			SRDY_1_OUT    = SERVO_RDY__ON		; Servo ON[#1]
			CMD"#1J/#2J/#17J/#18J/"				; Servo-Lock
			CMD"#3J/#4J/#20J/#21J/"				; Servo-Lock
			LOCK_1_STAT_REG = LOCK_OCCUR
			SV_RDY_TIMER_FNC					; Wait (20msec)

		ELSE
		ENDIF

	ELSE
	ENDIF

	; ---------
	; MOTOR(#2)
	; ---------
	IF( MOT_SRDY_2_REG = SERVO_RDY__ON )
		IF( SRDY_2_OUT = SERVO_RDY_OFF AND GAP__BRAKE_INIT = 0 )
P7501 = P7501 + 1		; for Debug

			SRDY_2_OUT      = SERVO_RDY__ON		; Servo ON[#2]
			CMD"#1J/#2J/#17J/#18J/"				; Servo-Lock
			CMD"#3J/#4J/#20J/#21J/"				; Servo-Lock
			LOCK_2_STAT_REG = LOCK_OCCUR
			SV_RDY_TIMER_FNC					; wait (20msec)

		ELSE
		ENDIF

	ELSE
	ENDIF

	; ---------
	; MOTOR(#3)
	; ---------
	IF( MOT_SRDY_3_REG = SERVO_RDY__ON )
		IF( SRDY_3_OUT = SERVO_RDY_OFF AND GAP__BRAKE_INIT = 0 )
P7502 = P7502 + 1		; for Debug

			SRDY_3_OUT      = SERVO_RDY__ON		; Servo ON[#3]
			CMD"#1J/#2J/#17J/#18J/"				; Servo-Lock
			CMD"#3J/#4J/#20J/#21J/"				; Servo-Lock
			LOCK_3_STAT_REG = LOCK_OCCUR
			SV_RDY_TIMER_FNC					; wait (20msec)

		ELSE
		ENDIF

	ELSE
	ENDIF

	; ---------
	; MOTOR(#4)
	; ---------
	IF( MOT_SRDY_4_REG = SERVO_RDY__ON )
		IF( SRDY_4_OUT = SERVO_RDY_OFF AND GAP__BRAKE_INIT = 0 )
P7503 = P7503 + 1		; for Debug

			SRDY_4_OUT      = SERVO_RDY__ON		; Servo ON[#4]
			CMD"#1J/#2J/#17J/#18J/"				; Servo-Lock
			CMD"#3J/#4J/#20J/#21J/"				; Servo-Lock
			LOCK_4_STAT_REG = LOCK_OCCUR
			SV_RDY_TIMER_FNC					; wait (20msec)

		ELSE
		ENDIF

	ELSE
	ENDIF


	; ---------------------
	; Once at power on
	; ---------------------
	IF( SRDY_1_OUT = SERVO_RDY__ON )
		IF( SRDY_2_OUT = SERVO_RDY__ON )
			IF( SRDY_3_OUT = SERVO_RDY__ON )
				IF( SRDY_4_OUT = SERVO_RDY__ON )
					IF( GAP__BRAKE_INIT = 0 )
						GAP__BRAKE_INIT = 1
						GAP__BRAKE_REG  = SERVO_RDY_OFF		; Add 2013/09/30
						GAP__BRAKE_STAT = SERVO_RDY_OFF
					ELSE
					ENDIF
				ELSE
				ENDIF
			ELSE
			ENDIF
		ELSE
		ENDIF
	ELSE
	ENDIF


; ------------
; MOTOR(#1-#4)
; ------------
	TMP7_REG = 0
	TMP7_REG = 0
;	IF( SRDY_1_OUT = SERVO_RDY__ON AND MOT_SRDY_1_REG = SERVO_RDY_OFF )
	IF( MOT_SRDY_1_REG = SERVO_RDY_OFF )
		TMP7_REG = 1
	ELSE
;		IF( SRDY_2_OUT = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY_OFF )
		IF( MOT_SRDY_2_REG = SERVO_RDY_OFF )
			TMP7_REG = 1
		ELSE
;			IF( SRDY_3_OUT = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY_OFF )
			IF( MOT_SRDY_3_REG = SERVO_RDY_OFF )
				TMP7_REG = 1
			ELSE
;				IF( SRDY_4_OUT = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY_OFF )
				IF( MOT_SRDY_4_REG = SERVO_RDY_OFF )
					TMP7_REG = 1
				ELSE
				ENDIF
			ENDIF
		ENDIF
	ENDIF


	IF( TMP7_REG > 0 )
		CMD^K

		SRDY_1_OUT = SERVO_RDY_OFF
		SRDY_2_OUT = SERVO_RDY_OFF
		SRDY_3_OUT = SERVO_RDY_OFF
		SRDY_4_OUT = SERVO_RDY_OFF

		LOCK_1_STAT_REG = UNLOCK_OCCUR
		LOCK_2_STAT_REG = UNLOCK_OCCUR
		LOCK_3_STAT_REG = UNLOCK_OCCUR
		LOCK_4_STAT_REG = UNLOCK_OCCUR

		GAP__BRAKE_STAT = SERVO_RDY__ON
		GAP__BRAKE_REG  = SERVO_RDY__ON
		GAP__BRK_ON_REG = GAP__BRK_ON_INI		; Add 2013/09/30

		PRG_EXEC_REG    = 0

; --------------
; Add:2014/11/20
		COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
		COMP_01_VAL_REG = 0
		COMP_17_VAL_REG = 0
		COMP_03_VAL_REG = 0
		COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------

		IF( PRG_GAP__INTLK = 1 )				; execute GAP-Eva program
			PRG_GAP__INTLK = 0					; clear GAP-Eva
			PRG_GAP__START = 0

			MOTOR_1_JOG  = GAP__INTLK_SPD		; set speed
			MOTOR_2_JOG  = GAP__INTLK_SPD
			MOTOR_3_JOG  = GAP__INTLK_SPD
			MOTOR_4_JOG  = GAP__INTLK_SPD
			MOTOR_17_JOG = GAP__INTLK_SPD
			MOTOR_18_JOG = GAP__INTLK_SPD
			MOTOR_20_JOG = GAP__INTLK_SPD
			MOTOR_21_JOG = GAP__INTLK_SPD

			MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_17_JOG_JOG = GAP__INTLK_SPD
			MOTOR_18_JOG_JOG = GAP__INTLK_SPD
			MOTOR_20_JOG_JOG = GAP__INTLK_SPD
			MOTOR_21_JOG_JOG = GAP__INTLK_SPD

		ELSE
		ENDIF

		IF( ACTIVE_MODE_REG = SPA_MODE OR ADJ_MODE__REG = ADJ__START )
			IF( ADJ_MODE__REG = ADJ__START )
P6915 = P6915 + 1		; for Debug
				ADJ_MODE__REG = ADJ_FINISH
				ADJ_PREMD_REG = ADJ_FINISH
				ADJ_COUNT_REG = ADJ_RETRY_MAX + 1
			ELSE
			ENDIF

			IF( GAP_SPARATE_SPD != 0 )
;			IF( GAP_SPARATE_SPD != 0 AND GAP_SPARATE_SPD != SPA_SPD )
				MOTOR_1_JOG  = GAP_SPARATE_SPD			; Restore velocity setting
				MOTOR_2_JOG  = GAP_SPARATE_SPD
				MOTOR_3_JOG  = GAP_SPARATE_SPD
				MOTOR_4_JOG  = GAP_SPARATE_SPD
				MOTOR_17_JOG = GAP_SPARATE_SPD
				MOTOR_18_JOG = GAP_SPARATE_SPD
				MOTOR_20_JOG = GAP_SPARATE_SPD
				MOTOR_21_JOG = GAP_SPARATE_SPD

				MOTOR_1_JOG_JOG  = GAP_SPARATE_SPD		; Restore velocity setting
				MOTOR_2_JOG_JOG  = GAP_SPARATE_SPD
				MOTOR_3_JOG_JOG  = GAP_SPARATE_SPD
				MOTOR_4_JOG_JOG  = GAP_SPARATE_SPD
				MOTOR_17_JOG_JOG = GAP_SPARATE_SPD
				MOTOR_18_JOG_JOG = GAP_SPARATE_SPD
				MOTOR_20_JOG_JOG = GAP_SPARATE_SPD
				MOTOR_21_JOG_JOG = GAP_SPARATE_SPD

				GAP_SPARATE_SPD = 0
			ELSE
			ENDIF

			; --------------------------------------
			;	X axis definition
			; --------------------------------------
			; --------------------------------------
			;	#17 I variables setting
			; --------------------------------------
			I1700 = MOTOR_ACTIVE				; Motor Activation
			I1702 = DAC_OUTPUT_CH01_REG			; Command Output Address
			I1706 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#1 I variables setting
			; --------------------------------------
			I0102 = DAC_OFFSET_CH18_REG			; Command Output Address
			I0103 = BISS_ADD_1_2				; Position Loop Feedback Address
			I0104 = BISS_ADD_1_2				; Velocity Loop Feedback Address
			I0106 = MOTOR_FOLW					; Position Following Enable and Mode

			I0108 = I1708						; Position Scale Factor
			I0109 = I1708						; Velocity-Loop Scale Factor

			I0124 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0130 = (PROPO_GAIN_UP)				; PID Proportional Gain

			; --------------------------------------
			;	A axis definition
			; --------------------------------------
			; --------------------------------------
			;	#18 I variables setting
			; --------------------------------------
			I1800 = MOTOR_ACTIVE				; Motor Activation
			I1802 = DAC_OUTPUT_CH02_REG			; Command Output Address
			I1806 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#2 I variables setting
			; --------------------------------------
			I0202 = DAC_OFFSET_CH17_REG			; Command Output Address
			I0203 = BISS_SUB_1_2				; Position Loop Feedback Address
			I0204 = BISS_SUB_1_2				; Velocity Loop Feedback Address
			I0206 = MOTOR_FOLW					; Position Following Enable and Mode

			I0208 = I1708						; Position Scale Factor
			I0209 = I1708						; Velocity-Loop Scale Factor

			I0224 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0230 = (2*PROPO_GAIN_UP)			; PID Proportional Gain

			; --------------------------------------
			;	Y axis definition
			; --------------------------------------
			; --------------------------------------
			;	#20 I variables setting
			; --------------------------------------
			I2000 = MOTOR_ACTIVE				; Motor Activation
			I2002 = DAC_OUTPUT_CH03_REG			; Command Output Address
			I2006 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#3 I variables setting
			; --------------------------------------
			I0302 = DAC_OFFSET_CH21_REG			; Command Output Address
			I0303 = BISS_ADD_3_4				; Position Loop Feedback Address
			I0304 = BISS_ADD_3_4				; Velocity Loop Feedback Address
			I0306 = MOTOR_FOLW					; Position Following Enable and Mode

			I0308 = I2008						; Position Scale Factor
			I0309 = I2008						; Velocity-Loop Scale Factor

			I0324 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0330 = (PROPO_GAIN_DN)				; PID Proportional Gain


			; --------------------------------------
			;	B axis definition
			; --------------------------------------
			; --------------------------------------
			;	#21 I variables setting
			; --------------------------------------
			I2100 = MOTOR_ACTIVE				; Motor Activation
			I2102 = DAC_OUTPUT_CH04_REG			; Command Output Address
			I2106 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#4ÇÃIïœêîê›íË
			; --------------------------------------
			I0402 = DAC_OFFSET_CH20_REG			; Command Output Address
			I0403 = BISS_SUB_3_4				; Position Loop Feedback Address
			I0404 = BISS_SUB_3_4				; Velocity Loop Feedback Address
			I0406 = MOTOR_FOLW					; Position Following Enable and Mode

			I0408 = I2008						; Position Scale Factor
			I0409 = I2008						; Velocity-Loop Scale Factor

			I0424 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0430 = (2*PROPO_GAIN_DN)			; PID Proportional Gain

; --------------
; Add:2015/05/29 Remedy for stack

		SV_RDY_TIMER_FNC

		TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
		TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
		TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

		M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
		M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
		M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
		M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

		M1762 = M162
		M1862 = M262
		M2062 = M362
		M2162 = M462

		SV_RDY_TIMER_FNC

; Add:2015/05/29
; --------------

			IOC_RCV_RDY_REG = RCV__READY_VAL		; ready 20150617

		ELSE
		ENDIF

	ELSE
	ENDIF


CLOSE



; ======================================
; ======================================
;	check receive-command from IOC
;		PLC5
; ======================================
; ======================================
OPEN PLC5 CLEAR


; P6600 = P6600 + 1		; for Debug

; --------------
; Add:2014/10/20
	; ------------
	; Kill request
	; ------------
	IF( REQ_IOC_KILL__REG = 1 )

		IOC_RCV_RDY_REG = RCV_NREADY_VAL		; not ready 20150617

		CMD^K

		TMP4_REG = 0
		TMP5_REG = 0

		IF( SRDY_1_OUT = SERVO_RDY__ON )
			SRDY_1_OUT = SERVO_RDY_OFF
			TMP4_REG = 1
		ELSE
		ENDIF
		IF( SRDY_2_OUT = SERVO_RDY__ON )
			SRDY_2_OUT = SERVO_RDY_OFF
			TMP4_REG = 1
		ELSE
		ENDIF
		IF( SRDY_3_OUT = SERVO_RDY__ON )
			SRDY_3_OUT = SERVO_RDY_OFF
			TMP5_REG = 1
		ELSE
		ENDIF
		IF( SRDY_4_OUT = SERVO_RDY__ON )
			SRDY_4_OUT = SERVO_RDY_OFF
			TMP5_REG = 1
		ELSE
		ENDIF

		IF( TMP4_REG = 1 )
			CMD"#1J/#2J/#17J/#18J/"
		ELSE
		ENDIF
		IF( TMP5_REG = 1 )
			CMD"#3J/#4J/#20J/#21J/"
		ELSE
		ENDIF

; --------------
; Add:2014/11/20
		COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
		COMP_01_VAL_REG = 0
		COMP_17_VAL_REG = 0
		COMP_03_VAL_REG = 0
		COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------

		IF( INITIALIZE_REG != SYS_NORMAL )
			INITIALIZE_REG = SYS_NORMAL
		ELSE
		ENDIF
		IF( DEVIATION_STAT_REG != DVI_NORMAL )
			DEVIATION_STAT_REG = DVI_NORMAL
		ELSE
		ENDIF

		REQ_IOC_KILL__REG = 0

		IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617

	ELSE
	ENDIF

	; -------------
	; Abort request
	; -------------
	IF( REQ_IOC_ABORT_REG = 1 )

		IOC_RCV_RDY_REG = RCV_NREADY_VAL		; not ready 20150617 

		CMD^A

		TMP4_REG = 0
		TMP5_REG = 0

		IF( SRDY_1_OUT = SERVO_RDY__ON )
			SRDY_1_OUT = SERVO_RDY_OFF
			TMP4_REG = 1
		ELSE
		ENDIF
		IF( SRDY_2_OUT = SERVO_RDY__ON )
			SRDY_2_OUT = SERVO_RDY_OFF
			TMP4_REG = 1
		ELSE
		ENDIF
		IF( SRDY_3_OUT = SERVO_RDY__ON )
			SRDY_3_OUT = SERVO_RDY_OFF
			TMP5_REG = 1
		ELSE
		ENDIF
		IF( SRDY_4_OUT = SERVO_RDY__ON )
			SRDY_4_OUT = SERVO_RDY_OFF
			TMP5_REG = 1
		ELSE
		ENDIF

		IF( TMP4_REG = 1 )
			CMD"#1J/#2J/#17J/#18J/"
		ELSE
		ENDIF
		IF( TMP5_REG = 1 )
			CMD"#3J/#4J/#20J/#21J/"
		ELSE
		ENDIF

; --------------
; Add:2014/11/20
		COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
		COMP_01_VAL_REG = 0
		COMP_17_VAL_REG = 0
		COMP_03_VAL_REG = 0
		COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------

		IF( INITIALIZE_REG != SYS_NORMAL )
			INITIALIZE_REG = SYS_NORMAL
		ELSE
		ENDIF
		IF( DEVIATION_STAT_REG != DVI_NORMAL )
			DEVIATION_STAT_REG = DVI_NORMAL
		ELSE
		ENDIF

		REQ_IOC_ABORT_REG = 0

		IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617

	ELSE
	ENDIF

; Add:2014/10/20
; --------------

	; ------------------------------------
	; receive COMMAND from IOC (for SYSTEM)
	; ------------------------------------
	IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )

; --------------
; Add:2014/11/20
		IF( REQ_COMP_SCAN_REG = COMP_SCAN_ENABLE )
			COMP_SCAN_REG = COMP_SCAN_ENABLE			; set I51=0 at position set move 
		ELSE
			COMP_SCAN_REG = COMP_SCAN_DISABLE			; set I51=1 at position set move
		ENDIF
; Add:2014/11/20
; --------------

		; -------------------
		; ALARM-CLEAR COMMAND
		; -------------------
;		Alarm clear is controlled by IOC
;		The following is a processing at not receiving 0 from IOC
		; -------
		; MOT[#1]
		; -------
		IF( AMP_ALM_1_CLR_REG = 1 )
			ALM_MT1_CLR_CNT_REG = ALM_MT1_CLR_CNT_REG + 1
			IF( ALM_MT1_CLR_CNT_REG > ALM_CLR_MAX_CNT )
				ALM_MT1_CLR_CNT_REG = 0
				AMP_ALM_1_CLR_REG   = 0
			ELSE
			ENDIF
		ELSE
		ENDIF
		; -------
		; MOT[#2]
		; -------
		IF( AMP_ALM_2_CLR_REG = 1 )
			ALM_MT2_CLR_CNT_REG = ALM_MT2_CLR_CNT_REG + 1
			IF( ALM_MT2_CLR_CNT_REG > ALM_CLR_MAX_CNT )
				ALM_MT2_CLR_CNT_REG = 0
				AMP_ALM_2_CLR_REG   = 0
			ELSE
			ENDIF
		ELSE
		ENDIF
		; -------
		; MOT[#3]
		; -------
		IF( AMP_ALM_3_CLR_REG = 1 )
			ALM_MT3_CLR_CNT_REG = ALM_MT3_CLR_CNT_REG + 1
			IF( ALM_MT3_CLR_CNT_REG > ALM_CLR_MAX_CNT )
				ALM_MT3_CLR_CNT_REG = 0
				AMP_ALM_3_CLR_REG   = 0
			ELSE
			ENDIF
		ELSE
		ENDIF
		; -------
		; MOT[#4]
		; -------
		IF( AMP_ALM_4_CLR_REG = 1 )
			ALM_MT4_CLR_CNT_REG = ALM_MT4_CLR_CNT_REG + 1
			IF( ALM_MT4_CLR_CNT_REG > ALM_CLR_MAX_CNT )
				ALM_MT4_CLR_CNT_REG = 0
				AMP_ALM_4_CLR_REG   = 0
			ELSE
			ENDIF
		ELSE
		ENDIF

		TMP1_REG = 0
		TMP1_REG = 0
		; -------
		; MOT[#1]
		; -------
		IF( AMP_ALM_1_CLR_REG = 1 AND ALM_MT1_LST_STS_REG = 0 )
			ALM_MT1_CLR_CNT_REG = 0
		ELSE
		ENDIF
		IF( AMP_ALM_1_CLR_REG = 0 AND ALM_MT1_LST_STS_REG = 1 )
			TMP1_REG = 1
		ELSE
		ENDIF
		; -------
		; MOT[#2]
		; -------
		IF( AMP_ALM_2_CLR_REG = 1 AND ALM_MT2_LST_STS_REG = 0 )
			ALM_MT2_CLR_CNT_REG = 0
		ELSE
		ENDIF
		IF( AMP_ALM_2_CLR_REG = 0 AND ALM_MT2_LST_STS_REG = 1 )
			TMP1_REG = 1
		ELSE
		ENDIF
		; -------
		; MOT[#3]
		; -------
		IF( AMP_ALM_3_CLR_REG = 1 AND ALM_MT3_LST_STS_REG = 0 )
			ALM_MT3_CLR_CNT_REG = 0
		ELSE
		ENDIF
		IF( AMP_ALM_3_CLR_REG = 0 AND ALM_MT3_LST_STS_REG = 1 )
			TMP1_REG = 1
		ELSE
		ENDIF
		; -------
		; MOT[#4]
		; -------
		IF( AMP_ALM_4_CLR_REG = 1 AND ALM_MT4_LST_STS_REG = 0 )
			ALM_MT4_CLR_CNT_REG = 0
		ELSE
		ENDIF
		IF( AMP_ALM_4_CLR_REG = 0 AND ALM_MT4_LST_STS_REG = 1 )
			TMP1_REG = 1
		ELSE
		ENDIF

		IF( TMP1_REG = 1 )

			; Check servo ready at this point
			IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
P6904 = P6904 + 1
				KILL_TIMER_FNC				; 100msec wait
				CMD^K						; Kill
				KILL_TIMER_FNC				; 100msec wait
				CMD^A						; Abort

			ELSE
			ENDIF

			; --------------------------------------
			; Abort if Amplifier fault or deviation error in coordinate system 1
			; (Add:2014/09/14)
			; --------------------------------------
			IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
				; Check servo ready at this point
				IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
P6903 = P6903 + 1
					CMD^A						; Abort
					KILL_TIMER_FNC				; 100msec wait
					CMD^K						; Kill
					KILL_TIMER_FNC				; 100msec wait

					INITIALIZE_REG     = SYS_NORMAL
					DEVIATION_STAT_REG = DVI_NORMAL
				ELSE
				ENDIF
			ELSE
			ENDIF

; --------------
; Add:2014/11/20
			COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
			COMP_01_VAL_REG = 0
			COMP_17_VAL_REG = 0
			COMP_03_VAL_REG = 0
			COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------

		ELSE
		ENDIF


		; ------------------------------
		; Save latest status of alarm clear
		; ------------------------------
		ALM_MT1_LST_STS_REG = AMP_ALM_1_CLR_REG
		ALM_MT2_LST_STS_REG = AMP_ALM_2_CLR_REG
		ALM_MT3_LST_STS_REG = AMP_ALM_3_CLR_REG
		ALM_MT4_LST_STS_REG = AMP_ALM_4_CLR_REG


		; ----------------------
		; reset BRICK-CONTROLLER
		; ----------------------
		IF( IOC_BRICK_RESET_REG != 0 )
			IOC_BRICK_RESET_REG = 0
			CMD"$$$"
		ELSE
		ENDIF


		; -------------------
		; CHANGE-MODE COMMAND
		; -------------------
		IF( ACTIVE_MODE_REG != IOC_CHG_MODE_REG )
			ACTIVE_MODE_REG = IOC_CHG_MODE_REG

			; -----------------------------
			; user mode or engineering mode or maintenance mode
			; Rev 2013/10/31
			; -----------------------------
			IF( ACTIVE_MODE_REG != SPA_MODE )

				; ---------------------
				; stopped GAP Interlock
				; Rev 2013/11/13(not adjusting mode)
				; ---------------------
				IF( PRG_GAP__INTLK = 0 AND PRG_GAP__START = 0 AND ADJ_MODE__REG != ADJ__START )

					IF( ACTIVE_MODE_REG = MNT_MODE )
						DEVIATION_VAL_REG = MNT_DEVIATION		; Set position deviation value
					ELSE
						DEVIATION_VAL_REG = SYS_DEVIATION		; Set position deviation value
					ENDIF

					IF( GAP_SPARATE_SPD != 0 )
;					IF( GAP_SPARATE_SPD != 0 AND GAP_SPARATE_SPD != SPA_SPD )

						MOTOR_1_JOG  = GAP_SPARATE_SPD			; Restore velocity setting
						MOTOR_2_JOG  = GAP_SPARATE_SPD
						MOTOR_3_JOG  = GAP_SPARATE_SPD
						MOTOR_4_JOG  = GAP_SPARATE_SPD
						MOTOR_17_JOG = GAP_SPARATE_SPD
						MOTOR_18_JOG = GAP_SPARATE_SPD
						MOTOR_20_JOG = GAP_SPARATE_SPD
						MOTOR_21_JOG = GAP_SPARATE_SPD

						MOTOR_1_JOG_JOG  = GAP_SPARATE_SPD		; Restore velocity setting
						MOTOR_2_JOG_JOG  = GAP_SPARATE_SPD
						MOTOR_3_JOG_JOG  = GAP_SPARATE_SPD
						MOTOR_4_JOG_JOG  = GAP_SPARATE_SPD
						MOTOR_17_JOG_JOG = GAP_SPARATE_SPD
						MOTOR_18_JOG_JOG = GAP_SPARATE_SPD
						MOTOR_20_JOG_JOG = GAP_SPARATE_SPD
						MOTOR_21_JOG_JOG = GAP_SPARATE_SPD

						GAP_SPARATE_SPD = 0
					ELSE
					ENDIF

; --------------
; Add:2014/11/20
					COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
					COMP_01_VAL_REG = 0
					COMP_17_VAL_REG = 0
					COMP_03_VAL_REG = 0
					COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------
					; --------------------------------------
					;	X axis definition
					; --------------------------------------
					; --------------------------------------
					;	#17 I variables setting
					; --------------------------------------
					I1700 = MOTOR_ACTIVE				; Motor Activation
					I1702 = DAC_OUTPUT_CH01_REG			; Command Output Address
					I1706 = MOTOR_FOLW					; Position Following Enable and Mode

					; --------------------------------------
					;	#1 I variable setting
					; --------------------------------------
					I0102 = DAC_OFFSET_CH18_REG			; Command Output Address
					I0103 = BISS_ADD_1_2				; Position Loop Feedback Address
					I0104 = BISS_ADD_1_2				; Velocity Loop Feedback Address
					I0106 = MOTOR_FOLW					; Position Following Enable and Mode

					I0108 = I1708						; Position Scale Factor
					I0109 = I1708						; Velocity-Loop Scale Factor

					I0124 = MOTOR_FLAG_VAL				; Flag Mode Control

					I0130 = (PROPO_GAIN_UP)				; PID Proportional Gain
;					I0131 = DERIV_GAIN_UP				; PID Derivative Gain
;					I0132 = SPEED_GAIN_UP				; PID Velocity Feedforward Gain
;					I0133 = INTEG_GAIN_UP				; PID Integral Gain
;					I0135 = ACC_FF_GAIN_UP				; PID Acceleration Feedforward Gain

					; --------------------------------------
					;	A axis definition
					; --------------------------------------
					; --------------------------------------
					;	#18 I variables setting
					; --------------------------------------
					I1800 = MOTOR_ACTIVE				; Motor Activation
					I1802 = DAC_OUTPUT_CH02_REG			; Command Output Address
					I1806 = MOTOR_FOLW					; Position Following Enable and Mode

					; --------------------------------------
					;	#2 I variables setting
					; --------------------------------------
					I0202 = DAC_OFFSET_CH17_REG			; Command Output Address
					I0203 = BISS_SUB_1_2				; Position Loop Feedback Address
					I0204 = BISS_SUB_1_2				; Velocity Loop Feedback Address
					I0206 = MOTOR_FOLW					; Position Following Enable and Mode

					I0208 = I1708						; Position Scale Factor
					I0209 = I1708						; Velocity-Loop Scale Factor

					I0224 = MOTOR_FLAG_VAL				; Flag Mode Control

					I0230 = (2*PROPO_GAIN_UP)			; PID Proportional Gain
;					I0231 = DERIV_GAIN_UP				; PID Derivative Gain
;					I0232 = SPEED_GAIN_UP				; PID Velocity Feedforward Gain
;					I0233 = INTEG_GAIN_UP				; PID Integral Gain
;					I0235 = ACC_FF_GAIN_UP				; PID Acceleration Feedforward Gain

					; --------------------------------------
					;	Y axis definition
					; --------------------------------------
					; --------------------------------------
					;	#20 I variables
					; --------------------------------------
					I2000 = MOTOR_ACTIVE				; Motor Activation
					I2002 = DAC_OUTPUT_CH03_REG			; Command Output Address
					I2006 = MOTOR_FOLW					; Position Following Enable and Mode

					; --------------------------------------
					;	#3 I variables
					; --------------------------------------
					I0302 = DAC_OFFSET_CH21_REG			; Command Output Address
					I0303 = BISS_ADD_3_4				; Position Loop Feedback Address
					I0304 = BISS_ADD_3_4				; Velocity Loop Feedback Address
					I0306 = MOTOR_FOLW					; Position Following Enable and Mode

					I0308 = I2008						; Position Scale Factor
					I0309 = I2008						; Velocity-Loop Scale Factor

					I0324 = MOTOR_FLAG_VAL				; Flag Mode Control

					I0330 = (PROPO_GAIN_DN)				; PID Proportional Gain
;					I0331 = DERIV_GAIN_DN				; PID Derivative Gain
;					I0332 = SPEED_GAIN_DN				; PID Velocity Feedforward Gain
;					I0333 = INTEG_GAIN_DN				; PID Integral Gain
;					I0335 = ACC_FF_GAIN_DN				; PID Acceleration Feedforward Gain


					; --------------------------------------
					;	B axis definition
					; --------------------------------------
					; --------------------------------------
					;	#21 I variables setting
					; --------------------------------------
					I2100 = MOTOR_ACTIVE				; Motor Activation
					I2102 = DAC_OUTPUT_CH04_REG			; Command Output Address
					I2106 = MOTOR_FOLW					; Position Following Enable and Mode

					; --------------------------------------
					;	#4 I variables setting
					; --------------------------------------
					I0402 = DAC_OFFSET_CH20_REG			; Command Output Address
					I0403 = BISS_SUB_3_4				; Position Loop Feedback Address
					I0404 = BISS_SUB_3_4				; Velocity Loop Feedback Address
					I0406 = MOTOR_FOLW					; Position Following Enable and Mode

					I0408 = I2008						; Position Scale Factor
					I0409 = I2008						; Velocity-Loop Scale Factor

					I0424 = MOTOR_FLAG_VAL				; Flag Mode Control

					I0430 = (2*PROPO_GAIN_DN)			; PID Proportional Gain
;					I0431 = DERIV_GAIN_DN				; PID Derivative Gain
;					I0432 = SPEED_GAIN_DN				; PID Velocity Feedforward Gain
;					I0433 = INTEG_GAIN_DN				; PID Integral Gain
;					I0435 = ACC_FF_GAIN_DN				; PID Acceleration Feedforward Gain

;					IF( M1762 != M162 )
;						M1762 = M162
;					ELSE
;					ENDIF
;					IF( M1862 != M262 )
;						M1862 = M262
;					ELSE
;					ENDIF
;					IF( M2062 != M362 )
;						M2062 = M362
;					ELSE
;					ENDIF
;					IF( M2162 != M462 )
;						M2162 = M462
;					ELSE
;					ENDIF

; --------------
; Add:2015/05/29 remedy for stack

		SV_RDY_TIMER_FNC

		TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
		TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
		TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

		M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
		M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
		M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
		M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

		M1762 = M162
		M1862 = M262
		M2062 = M362
		M2162 = M462

		SV_RDY_TIMER_FNC

; Add:2015/05/29
; --------------

					IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617

				ELSE		; if(!GAP_INTLOCK)
				ENDIF		; if(!GAP_INTLOCK)

			; ----------------
			; separate mode
			; ----------------
			ELSE			; if(!SPA_MODE)

				; ---------------------
				; stopped GAP Interlock
				; ---------------------
				IF( PRG_GAP__INTLK = 0 AND PRG_GAP__START = 0 )

					DEVIATION_VAL_REG = MNT_DEVIATION		; Set position deviation value
					GAP_SPARATE_SPD   = MOTOR_1_JOG			; Store present velocity

					MOTOR_1_JOG  = SPA_SPD					; Set velocity setting of separate motor mode
					MOTOR_2_JOG  = SPA_SPD
					MOTOR_3_JOG  = SPA_SPD
					MOTOR_4_JOG  = SPA_SPD
					MOTOR_17_JOG = SPA_SPD
					MOTOR_18_JOG = SPA_SPD
					MOTOR_20_JOG = SPA_SPD
					MOTOR_21_JOG = SPA_SPD

					MOTOR_1_JOG_JOG  = SPA_SPD				; Set velocity setting of separate motor mode
					MOTOR_2_JOG_JOG  = SPA_SPD
					MOTOR_3_JOG_JOG  = SPA_SPD
					MOTOR_4_JOG_JOG  = SPA_SPD
					MOTOR_17_JOG_JOG = SPA_SPD
					MOTOR_18_JOG_JOG = SPA_SPD
					MOTOR_20_JOG_JOG = SPA_SPD
					MOTOR_21_JOG_JOG = SPA_SPD

; --------------
; Add:2014/11/20
					COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
					COMP_01_VAL_REG = 0
					COMP_17_VAL_REG = 0
					COMP_03_VAL_REG = 0
					COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------
					; --------------------------------------
					;	X axis definition
					; --------------------------------------
					; --------------------------------------
					;	#17 I variables setting
					; --------------------------------------
					I1700 = MOTOR_INACTV				; Motor Inactivation
					I1702 = DAC_OFFSET_CH18_REG			; Command Output Address
					I1706 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

					; --------------------------------------
					;	#1 I variables setting
					; --------------------------------------
					I0102 = DAC_OUTPUT_CH01_REG			; Command Output Address
					I0103 = ROT_ENC_1					; Position Loop Feedback Address
					I0104 = ROT_ENC_1					; Velocity Loop Feedback Address
					I0106 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

					I0108 = MNT_POS_CNV_RATE			; Position Scale Factor
					I0109 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor

					I0124 = MNT_FLAG_VAL				; Flag Mode Control

					I0130 = (PROPO_GAIN_UP)				; PID Proportional Gain
;					I0131 = DERIV_GAIN_UP				; PID Derivative Gain
;					I0132 = SPEED_GAIN_UP				; PID Velocity Feedforward Gain
;					I0133 = INTEG_GAIN_UP				; PID Integral Gain
;					I0135 = ACC_FF_GAIN_UP				; PID Acceleration Feedforward Gain


					; --------------------------------------
					;	A axis definition
					; --------------------------------------
					; --------------------------------------
					;	#18 I variables setting
					; --------------------------------------
					I1800 = MOTOR_INACTV				; 
					I1802 = DAC_OFFSET_CH17_REG			; 
					I1806 = MNT_MOTOR_FOLW				; 

					; --------------------------------------
					;	#2 I variables setting
					; --------------------------------------
					I0202 = DAC_OUTPUT_CH02_REG			; Command Output Address
					I0203 = ROT_ENC_2					; Position Loop Feedback Address
					I0204 = ROT_ENC_2					; Velocity Loop Feedback Address
					I0206 = MNT_MOTOR_FOLW				; Position Following Enable and Mode	

					I0208 = MNT_POS_CNV_RATE			; Position Scale Factor
					I0209 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor

					I0224 = MNT_FLAG_VAL				; Flag Mode Control

					I0230 = (PROPO_GAIN_UP)				; PID Proportional Gain
;					I0231 = DERIV_GAIN_UP				; PID Derivative Gain
;					I0232 = SPEED_GAIN_UP				; PID Velocity Feedforward Gain
;					I0233 = INTEG_GAIN_UP				; PID Integral Gain
;					I0235 = ACC_FF_GAIN_UP				; PID Acceleration Feedforward Gain


					; --------------------------------------
					;	Y axis definition
					; --------------------------------------
					; --------------------------------------
					;	#20 I variables setting
					; --------------------------------------
					I2000 = MOTOR_INACTV				; 
					I2002 = DAC_OFFSET_CH21_REG			; 
					I2006 = MNT_MOTOR_FOLW				; 

					; --------------------------------------
					;	#3 I variables setting
					; --------------------------------------
					I0302 = DAC_OUTPUT_CH03_REG			; Command Output Address
					I0303 = ROT_ENC_3					; Position Loop Feedback Address
					I0304 = ROT_ENC_3					; Velocity Loop Feedback Address
					I0306 = MNT_MOTOR_FOLW				; Position Following Enable and Mode	

					I0308 = MNT_POS_CNV_RATE			; Position Scale Factor
					I0309 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor

					I0324 = MNT_FLAG_VAL				; Flag Mode Control

					I0330 = (PROPO_GAIN_DN)				; PID Proportional Gain
;					I0331 = DERIV_GAIN_DN				; PID Derivative Gain
;					I0332 = SPEED_GAIN_DN				; PID Velocity Feedforward Gain
;					I0333 = INTEG_GAIN_DN				; PID Integral Gain
;					I0335 = ACC_FF_GAIN_DN				; PID Acceleration Feedforward Gain

					; --------------------------------------
					;	B axis definition
					; --------------------------------------
					; --------------------------------------
					;	#21 I variables setting
					; --------------------------------------
					I2100 = MOTOR_INACTV				; Motor Activation
					I2102 = DAC_OFFSET_CH20_REG			; Command Output Address
					I2106 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

					; --------------------------------------
					;	#4 I variables setting
					; --------------------------------------
					I0402 = DAC_OUTPUT_CH04_REG			; Command Output Address
					I0403 = ROT_ENC_4					; Position Loop Feedback Address
					I0404 = ROT_ENC_4					; Velocity Loop Feedback Address
					I0406 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

					I0408 = MNT_POS_CNV_RATE			; Position Scale Factor
					I0409 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor

					I0424 = MNT_FLAG_VAL				; Flag Mode Control

					I0430 = (PROPO_GAIN_DN)				; PID Proportional Gain
;					I0431 = DERIV_GAIN_DN				; PID Derivative Gain
;					I0432 = SPEED_GAIN_DN				; PID Velocity Feedforward Gain
;					I0433 = INTEG_GAIN_DN				; PID Integral Gain
;					I0435 = ACC_FF_GAIN_DN				; PID Acceleration Feedforward Gain

; --------------
; Add:2015/05/29 ÉXÉ^ÉbÉNëŒçÙ

		SV_RDY_TIMER_FNC

		TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
		TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
		TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

		M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
		M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
		M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
		M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

		M1762 = M162
		M1862 = M262
		M2062 = M362
		M2162 = M462

		SV_RDY_TIMER_FNC

; Add:2015/05/29
; --------------

					IOC_RCV_RDY_REG = RCV__READY_VAL		; ready 20150617

				ELSE		; if(!GAP_INTLOCK)
				ENDIF		; if(!GAP_INTLOCK)

			ENDIF		; if(!SPA_MODE)

		ELSE		; if(ACTIVE_MODE_REG)
		ENDIF		; if(ACTIVE_MODE_REG)


		FSAVE_CMD_REG = 0

		; ------------------
		; Change OFFSET DATA
		; ------------------
		IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
			IF( IOC_OFF_1_REG != MOT_1_OFFSET_REG AND IOC_OFF_1_REG != 0 )
				MOT_1_OFFSET_REG = IOC_OFF_1_REG

				TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
				TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
				TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

				M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
				M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
				M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
				M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

				M1762 = M162
				M1862 = M262
				M2062 = M362
				M2162 = M462

				FSAVE_CMD_REG    = 2
			ELSE
			ENDIF

			IF( IOC_OFF_2_REG != MOT_2_OFFSET_REG AND IOC_OFF_2_REG != 0 )
				MOT_2_OFFSET_REG = IOC_OFF_2_REG

				TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
				TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
				TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

				M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
				M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
				M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
				M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

				M1762 = M162
				M1862 = M262
				M2062 = M362
				M2162 = M462

				FSAVE_CMD_REG    = 2
			ELSE
			ENDIF

			IF( IOC_OFF_3_REG != MOT_3_OFFSET_REG AND IOC_OFF_3_REG != 0 )
				MOT_3_OFFSET_REG = IOC_OFF_3_REG

				TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
				TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
				TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

				M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
				M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
				M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
				M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

				M1762 = M162
				M1862 = M262
				M2062 = M362
				M2162 = M462

				FSAVE_CMD_REG    = 2
			ELSE
			ENDIF

			IF( IOC_OFF_4_REG != MOT_4_OFFSET_REG AND IOC_OFF_4_REG != 0 )
				MOT_4_OFFSET_REG = IOC_OFF_4_REG

				TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
				TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
				TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

				M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
				M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
				M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
				M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

				M1762 = M162
				M1862 = M262
				M2062 = M362
				M2162 = M462

				FSAVE_CMD_REG    = 2
			ELSE
			ENDIF
		ELSE
		ENDIF


		; ---------------------
		; Change Software Limit
		; ---------------------
		; ---------------
		; GAP UPPER LIMIT
		; ---------------
		IF( IOC_GAP_LIM_UP_REG != GAP_SOFTLIM_UP_REG AND IOC_GAP_LIM_UP_REG > 0 )
			GAP_SOFTLIM_UP_REG = IOC_GAP_LIM_UP_REG
			FSAVE_CMD_REG      = 1
		ELSE
		ENDIF

		; ---------------
		; GAP LOWER LIMIT
		; ---------------
		IF( IOC_GAP_LIM_DN_REG != GAP_SOFTLIM_DN_REG AND IOC_GAP_LIM_DN_REG > 0 )
			GAP_SOFTLIM_DN_REG = IOC_GAP_LIM_DN_REG
			FSAVE_CMD_REG      = 1
		ELSE
		ENDIF

		; ----------------
		; JACK UPPER LIMIT
		; ----------------
		IF( IOC_JCK_LIM_UP_REG != JCK_SOFTLIM_UP_REG AND IOC_JCK_LIM_UP_REG > 0 )
			JCK_SOFTLIM_UP_REG = IOC_JCK_LIM_UP_REG
			FSAVE_CMD_REG      = 1
		ELSE
		ENDIF

		; ----------------
		; JACK LOWER LIMIT
		; ----------------
		IF( IOC_JCK_LIM_DN_REG != JCK_SOFTLIM_DN_REG AND IOC_JCK_LIM_DN_REG > 0 )
			JCK_SOFTLIM_DN_REG = IOC_JCK_LIM_DN_REG
			FSAVE_CMD_REG      = 1
		ELSE
		ENDIF


		; -----------------
		; Change SPEED DATA
		; -----------------
		; ----------
		; MOT[#1-#4]
		; ----------
		IF( IOC_SPD_1_REG != MOT_SPEED_REG AND IOC_SPD_1_REG > 0 )

			TMP1_REG = ( IOC_SPD_1_REG * MOT_SPD_CNV ) * MOT_LIN_ROT_CNV
			IF( TMP1_REG > SPD_MAX )
				TMP1_REG = SPD_MAX
			ENDIF

			IF( TMP1_REG < SPD_MIN )
				TMP1_REG = SPD_MIN
			ENDIF


			MOT_SPEED_REG = IOC_SPD_1_REG
			JCK_SPEED_REG = IOC_SPD_1_REG


; --------
; speed x1(start)
; --------
			TMP2_REG     = 1
			MOTOR_1_JOG  = TMP1_REG * TMP2_REG
			MOTOR_2_JOG  = TMP1_REG * TMP2_REG
			MOTOR_3_JOG  = TMP1_REG * TMP2_REG
			MOTOR_4_JOG  = TMP1_REG * TMP2_REG
			MOTOR_17_JOG = TMP1_REG * TMP2_REG
			MOTOR_18_JOG = TMP1_REG * TMP2_REG
			MOTOR_20_JOG = TMP1_REG * TMP2_REG
			MOTOR_21_JOG = TMP1_REG * TMP2_REG

			MOTOR_1_JOG_JOG  = TMP1_REG * TMP2_REG
			MOTOR_2_JOG_JOG  = TMP1_REG * TMP2_REG
			MOTOR_3_JOG_JOG  = TMP1_REG * TMP2_REG
			MOTOR_4_JOG_JOG  = TMP1_REG * TMP2_REG
			MOTOR_17_JOG_JOG = TMP1_REG * TMP2_REG
			MOTOR_18_JOG_JOG = TMP1_REG * TMP2_REG
			MOTOR_20_JOG_JOG = TMP1_REG * TMP2_REG
			MOTOR_21_JOG_JOG = TMP1_REG * TMP2_REG
; --------
; speed x1(end)
; --------

			FSAVE_CMD_REG = 1

		ELSE
		ENDIF


		; -----------------------------
		; GAP INTERLOCK(Add 2013/09/30)
		; -----------------------------
		IF( GAP__INTLK_REG != GAP__INTLK_MEM )
			GAP__INTLK_MEM = GAP__INTLK_REG
			FSAVE_CMD_REG  = 1
		ELSE
		ENDIF

		; ---------
		; Data Save
		; ---------
		IF( FSAVE_CMD_REG > 0 )
			; ----------------
			; save OFFSET DATA
			; ----------------
			IF( FSAVE_CMD_REG = 2 )
				FSAVE_CMD_REG = 0				; Add 2014/05/14
;				CMD"SAVE"
				SV_RDY_TIMER_FNC				; Wait (20msec)
;				WAIT_TIMER_FNC					; Wait (1000msec)
			ELSE
			ENDIF

			; ---------------
			; save other DATA
			; ---------------
			IF( FSAVE_CMD_REG = 1 )
				FSAVE_CMD_REG = 0				; Add 2014/05/14
;				CMD"SAVE"
				SV_RDY_TIMER_FNC				; Wait (20msec)
			ELSE
			ENDIF

;			IF( FSAVE_ERR_REG = 1 )
;				FCLEAR_NUM_REG = FCLEAR_NUM_REG + 1
;				CMD"FCLEAR"
;				CMD"FSAVECLEAR"
;			ELSE
;			ENDIF
;
;			FSAVE_NUM_REG = FSAVE_NUM_REG + 1
;			CMD"FSAVE"
		ELSE
		ENDIF

	ELSE		; if(AXIS STOP)
	ENDIF		; if(AXIS STOP)


	; ---------------------------------
	; receive COMMAND from IOC (for GAP)
	; ---------------------------------
	; -----------------------------
	; user mode or engineering mode
	; Add not adjusting mode
	; -----------------------------
	IF( ACTIVE_MODE_REG = USR_MODE OR ACTIVE_MODE_REG = ENG_MODE )

		; -------------
		; DRIVE COMMAND
		; -------------
		IF( ADJ_MODE__REG != ADJ__START )

			; ----------
			; GAP[#1-#4]
			; ----------
			IF( IOC_GAP_1_DRV_REG != 0 OR IOC_GAP_1_JGP_REG != 0 OR IOC_GAP_1_JGM_REG != 0 )

; --------------
; Add:2014/11/26
DEVIATION_STAT_REG = DVI_NORMAL

IF( M1762 = M162 AND M1862 = M262 AND M2062 = M362 AND M2162 = M462 )
; Add:2014/11/26
; --------------
				; --------------------------------------
				; Abort if Amp Fault or following error in coordinate system 1
				; (Add:2014/09/14)
				; --------------------------------------
				IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
					CMD^A						; Abort
					KILL_TIMER_FNC				; 100msec wait
					CMD^K						; Kill
					KILL_TIMER_FNC				; 100msec wait

					INITIALIZE_REG     = SYS_NORMAL
					DEVIATION_STAT_REG = DVI_NORMAL
				ELSE
				ENDIF

; --------------
; Add:2014/09/28
; Store setting value at move command
;				IF( REQ_GAP__RETRY_REG = 0 )
				TMP2_REG = REQ_GAP__RETRY_REG & $000040
				IF( TMP2_REG = $000000 )
					; ----------------------------------------------
					; Vertical offset setpoint from IOC is changed? [unit=mm]
					; ----------------------------------------------
					IF( MEM_VRT_STPOS_REG != REQ_VRT_ABSPOS_REG )
						MEM_VRT_STPOS_REG = REQ_VRT_ABSPOS_REG
					ELSE
					ENDIF
					; --------------------------------------------------
					; Gap setpoint form IOC is changed? [unit=mm](Add:2014/09/14)
					; --------------------------------------------------
					IF( MEM_GAP_STPOS_REG != REQ_GAP_ABSPOS_REG )
						MEM_GAP_STPOS_REG = REQ_GAP_ABSPOS_REG
					ELSE
					ENDIF
				ELSE
				ENDIF
; Add:2014/09/28
; --------------

P6506 = 0		; for Debug

				IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
					IF( PROG_STAT_REG = PROG_STP_STAT AND P330 = 0 )
						IF( GAP__INTLK_VAL = GAP__INTLK_DIS )
							TMP8_REG = 0
							TMP8_REG = 0

							; ------------------------------------
							; calc Vertical offset(Add:2014/05/28)
							; ------------------------------------
							; --------
							; Upstream
							; --------
							TMP4_REG = ( MOT_1_OFFSET_REG - MOT_1_POS_REG )
							TMP5_REG = ( MOT_3_OFFSET_REG - MOT_3_POS_REG )
							VRT_UP_OFFSET_REG = ( TMP4_REG - TMP5_REG ) / 2
							; ----------
							; Downstream
							; ----------
							TMP4_REG = ( MOT_2_OFFSET_REG - MOT_2_POS_REG )
							TMP5_REG = ( MOT_4_OFFSET_REG - MOT_4_POS_REG )
							VRT_DN_OFFSET_REG = ( TMP4_REG - TMP5_REG ) / 2
							; -------
							; Average
							; -------
							VRT_AV_OFFSET_REG = ( VRT_UP_OFFSET_REG + VRT_DN_OFFSET_REG ) / 2

							GAP_1_MOV_REG = IOC_GAP_1_DRV_REG
							GAP_1_JGP_REG = IOC_GAP_1_JGP_REG
							GAP_1_JGM_REG = IOC_GAP_1_JGM_REG

							; ----
							; Open
							; ----
							IF( IOC_GAP_1_DRV_REG > 0 OR IOC_GAP_1_JGP_REG != 0 )
								IF( OPEN_KILL_1_REG = LIMIT_OFF OR OPEN_KILL_2_REG = LIMIT_OFF )
									TMP8_REG = 1
								ELSE
								ENDIF
							ELSE
							ENDIF
							; -----
							; Close
							; -----
							IF( IOC_GAP_1_DRV_REG < 0 OR IOC_GAP_1_JGM_REG != 0 )
;								IF( CLOSE_KILL_1_REG = LIMIT_OFF OR CLOSE_KILL_2_REG = LIMIT_OFF )
								IF( CLOSE_KILL_1_REG = LIMIT_OFF OR CLOSE_KILL_2_REG = LIMIT_OFF OR GAP_CLOSE_KILL_REG = LIMIT_OFF )
									TMP8_REG = 1
								ELSE
								ENDIF
							ELSE
							ENDIF

							; ---------------
							; not detected LS
							; ---------------
							IF( TMP8_REG = 0 )
P6300 = P6300 + 1		; for Debug
								; ---------
								; over 10um
								; ---------
								; ----------
								; MOT[#3-#4]
								; ----------
								TMP4_REG = ( MOT_3_OFFSET_REG - MOT_3_POS_REG )
								TMP5_REG = ( MOT_4_OFFSET_REG - MOT_4_POS_REG )
								TMP6_REG = TMP4_REG - TMP5_REG
								IF( TMP6_REG < 0 )
									GAP_DN_DN_VAL = TMP6_REG * -1
								ELSE
									GAP_DN_DN_VAL = TMP6_REG * 1
								ENDIF
								; ----------
								; MOT[#1-#2]
								; ----------
								TMP4_REG = ( MOT_1_OFFSET_REG - MOT_1_POS_REG )
								TMP5_REG = ( MOT_2_OFFSET_REG - MOT_2_POS_REG )
								TMP6_REG = TMP4_REG - TMP5_REG
								IF( TMP6_REG < 0 )
									GAP_UP_UP_VAL = TMP6_REG * -1
								ELSE
									GAP_UP_UP_VAL = TMP6_REG * 1
								ENDIF
; --------------
; Del:2014/10/17
;								; ----------
;								; MOT[#1-#3]
;								; ----------
;								TMP4_REG = ( MOT_1_OFFSET_REG - MOT_1_POS_REG )
;								TMP5_REG = ( MOT_3_OFFSET_REG - MOT_3_POS_REG )
;								TMP6_REG = TMP4_REG - TMP5_REG
;								IF( TMP6_REG < 0 )
;									GAP_UP_DN_VAL = TMP6_REG * -1
;								ELSE
;									GAP_UP_DN_VAL = TMP6_REG * 1
;								ENDIF
;								; ----------
;								; MOT[#2-#4]
;								; ----------
;								TMP4_REG = ( MOT_2_OFFSET_REG - MOT_2_POS_REG )
;								TMP5_REG = ( MOT_4_OFFSET_REG - MOT_4_POS_REG )
;								TMP6_REG = TMP4_REG - TMP5_REG
;								IF( TMP6_REG < 0 )
;									GAP_DN_UP_VAL = TMP6_REG * -1
;								ELSE
;									GAP_DN_UP_VAL = TMP6_REG * 1
;								ENDIF
; Del:2014/10/17
; --------------

								ADJ_ERROR_REG = $000000
								ADJ_ERROR_REG = $000000
								; ----------------
								; GAP-UP-UP[#1-#2]
								; ----------------
								IF( ADJ_RANGE_MAX < GAP_UP_UP_VAL )			; over range[10um]
									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_1_ADJ_DRV
									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_2_ADJ_DRV
								ELSE
								ENDIF
								; ----------------
								; GAP-DN-DN[#3-#4]
								; ----------------
								IF( ADJ_RANGE_MAX < GAP_DN_DN_VAL )			; over range[10um]
									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_3_ADJ_DRV
									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_4_ADJ_DRV
								ELSE
								ENDIF
; ---
; Del
;								; ----------------
;								; GAP-UP-DN[#1-#3]
;								; ----------------
;								IF( ADJ_RANGE_MAX < GAP_UP_DN_VAL )			; over range[10um]
;;								IF( VRT_RANGE_MAX < GAP_UP_DN_VAL )			; over range[50um]
;									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_1_ADJ_DRV
;									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_3_ADJ_DRV
;								ELSE
;								ENDIF
;								; ----------------
;								; GAP-DN-UP[#2-#4]
;								; ----------------
;								IF( ADJ_RANGE_MAX < GAP_DN_UP_VAL )			; over range[10um]
;;								IF( VRT_RANGE_MAX < GAP_DN_UP_VAL )			; over range[50um]
;									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_2_ADJ_DRV
;									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_4_ADJ_DRV
;								ELSE
;								ENDIF
; Del
; ---

								; ----------
								; under 10um
								; ----------
								IF( ADJ_ERROR_REG = $000000 )

									GAP__BRK_ON_REG = GAP__BRK_ON_INI		; clear count

									REF_POS_REG	= ( IOC_GAP_1_DRV_REG / 2 ) / MOT_LIN_ROT_CNV
									TMP3_REG    = M1062 /( I0108 * 32 )

									TMP7_REG    = TMP3_REG - REF_POS_REG
									TMP1_REG    = INT( TMP7_REG / 100 )
									TMP2_REG    = TMP1_REG * 100
									ABS_POS_REG = TMP2_REG

									; ---------------------------------------------
									; turns Servo-on from Servo-off(Add 2013/09/30)
									; ---------------------------------------------
									IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
										TMP9_REG = 0
										TMP9_REG = 0

										; -------
										; MOT[#1]
										; -------
										IF( SRDY_1_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
P6102 = P6102 + 1		; for Debug
										ELSE
										ENDIF
										; -------
										; MOT[#2]
										; -------
										IF( SRDY_2_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
P6103 = P6103 + 1		; for Debug
										ELSE
										ENDIF
										; -------
										; MOT[#3]
										; -------
										IF( SRDY_3_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
P6104 = P6104 + 1		; for Debug
										ELSE
										ENDIF
										; -------
										; MOT[#4]
										; -------
										IF( SRDY_4_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
P6105 = P6105 + 1		; for Debug
										ELSE
										ENDIF


										IF( TMP9_REG = 1 )
P6106 = P6106 + 1		; for Debug
; --------------
; Add:2014/11/20
											IF( IOC_GAP_1_DRV_REG != 0 )
												IF( COMP_SCAN_REG = COMP_SCAN_DISABLE )		; Set I51=1 at setpoint move
;													COMP_FLAG_REG = COMP_SCAN_ENABLE		; Disable skew compensation
													IF( COMP_DISABLE__REG = 0 )
														COMP_FLAG_REG = COMP_SCAN_ENABLE	; Disable skew compensation
													ELSE
														COMP_FLAG_REG = COMP_SCAN_DISABLE	; Disable skew compensation
													ENDIF
												ELSE
													COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
													COMP_01_VAL_REG = 0
													COMP_17_VAL_REG = 0
													COMP_03_VAL_REG = 0
													COMP_20_VAL_REG = 0
												ENDIF
											ELSE
												COMP_FLAG_REG   = COMP_SCAN_DISABLE			; Disable skew compensation
												COMP_01_VAL_REG = 0
												COMP_17_VAL_REG = 0
												COMP_03_VAL_REG = 0
												COMP_20_VAL_REG = 0
											ENDIF
; Add:2014/11/20
; --------------

											SRDY_1_OUT = SERVO_RDY__ON
											SRDY_2_OUT = SERVO_RDY__ON
											SRDY_3_OUT = SERVO_RDY__ON
											SRDY_4_OUT = SERVO_RDY__ON

											SV_RDY_TIMER_FNC				; Wait (20msec)
											CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
											CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock

											GAP__BRAKE_REG  = SERVO_RDY_OFF
											GAP__BRAKE_STAT = GAP__BRAKE_REG
											LOCK_1_STAT_REG = LOCK_OCCUR
											LOCK_2_STAT_REG = LOCK_OCCUR
											LOCK_3_STAT_REG = LOCK_OCCUR
											LOCK_4_STAT_REG = LOCK_OCCUR

											BRK_OFF_TIMER_FNC				; Wait (100msec)
										ELSE
										ENDIF
									ELSE									; Add 2013/09/30
									ENDIF									; Add 2013/09/30
P6112 = P6111					; for Debug (Command value at two times before)
P6111 = P710					; for Debug (Command value at last time)
P710  = IOC_GAP_1_DRV_REG		; for Debug (Command value at this time)

P6100 = P6100 + 1				; for Debug
P6101 = ADJ_ERROR_REG			; for Debug

; --------------
; Add 2014/09/27
IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
;	IF( PRG_EXEC_REG = 0 ) comment out 20150529

									IOC_RCV_RDY_REG = RCV_NREADY_VAL		; not ready 20150617

									CMD"&1B10R"								; Execute a motion program (&1)
;	ELSE
;	ENDIF
ELSE
ENDIF
; Add 2014/09/27
; --------------
								ELSE				; if(ADJ_ERROR_REG)
								ENDIF				; if(ADJ_ERROR_REG)
							ELSE				; if(TMP8_REG)
							ENDIF				; if(TMP8_REG)
						ELSE				; if(GAP__INTLK_DIS) Add 2013/09/30
						ENDIF				; if(GAP__INTLK_DIS) Add 2013/09/30
					ELSE				; if(PROG_STP_STAT)
					ENDIF				; if(PROG_STP_STAT)
				ELSE				; if(MOVE_AXIS)
				ENDIF				; if(MOVE_AXIS)

; --------------
; Add:2014/11/26
ELSE		; if(Mx62=Mx62)

	DEVIATION_STAT_REG = DVI_ERROR

ENDIF		; if(Mx62=Mx62)
; Add:2014/11/26
; --------------

				IOC_GAP_1_DRV_REG = 0
				IOC_GAP_1_JGP_REG = 0
				IOC_GAP_1_JGM_REG = 0

			ELSE
			ENDIF

			; --------------
			; JACK-UP[#1-#4]
			; --------------
			IF( IOC_JCK_0_DRV_REG != 0 OR IOC_JCK_0_JGP_REG != 0 OR IOC_JCK_0_JGM_REG != 0 )

; --------------
; Add:2014/11/26
DEVIATION_STAT_REG = DVI_NORMAL

IF( M1762 = M162 AND M1862 = M262 AND M2062 = M362 AND M2162 = M462 )
; Add:2014/11/26
; --------------
				; --------------------------------------
				; Abort if Amp Fault or following error in coordinate system 1
				; (Add:2014/09/14)
				; --------------------------------------
				IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
					CMD^A						; Abort
					KILL_TIMER_FNC				; 100msec wait
					CMD^K						; Kill
					KILL_TIMER_FNC				; 100msec wait

					INITIALIZE_REG     = SYS_NORMAL
					DEVIATION_STAT_REG = DVI_NORMAL
				ELSE
				ENDIF

; --------------
; Add:2014/09/28
; Store setting value at move command
;				IF( REQ_JACK_RETRY_REG = 0 )
				TMP2_REG = REQ_JACK_RETRY_REG & $000040
				IF( TMP2_REG = $000000 )
					; ----------------------------------------------
					; Vertical offset setpoint from IOC is changed? [unit=mm]
					; ----------------------------------------------
					IF( MEM_VRT_STPOS_REG != REQ_VRT_ABSPOS_REG )
						MEM_VRT_STPOS_REG = REQ_VRT_ABSPOS_REG
					ELSE
					ENDIF
					; --------------------------------------------------
					; Gap setpoing from IOC is changed? [unit=mm](Add:2014/09/14)
					; --------------------------------------------------
					IF( MEM_GAP_STPOS_REG != REQ_GAP_ABSPOS_REG )
						MEM_GAP_STPOS_REG = REQ_GAP_ABSPOS_REG
					ELSE
					ENDIF
				ELSE
				ENDIF
; Add:2014/09/28
; --------------

				IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
					IF( PROG_STAT_REG = PROG_STP_STAT )
						IF( GAP__INTLK_VAL = GAP__INTLK_DIS )		; Add 2013/09/30
							TMP16_REG = 0
							TMP16_REG = 0

							JCK_0_MOV_REG = IOC_JCK_0_DRV_REG
							JCK_0_JGP_REG = IOC_JCK_0_JGP_REG
							JCK_0_JGM_REG = IOC_JCK_0_JGM_REG
							; --
							; Up
							; --
							IF( IOC_JCK_0_DRV_REG > 0 OR IOC_JCK_0_JGP_REG != 0 )
								IF( OPEN_KILL_1_REG = LIMIT_OFF OR CLOSE_KILL_2_REG = LIMIT_OFF )
									TMP16_REG = 1
								ELSE
								ENDIF
							ELSE
							ENDIF
							; ----
							; Down
							; ----
							IF( IOC_JCK_0_DRV_REG < 0 OR IOC_JCK_0_JGM_REG != 0 )
								IF( OPEN_KILL_2_REG = LIMIT_OFF OR CLOSE_KILL_1_REG = LIMIT_OFF )
									TMP16_REG = 1
								ELSE
								ENDIF
							ELSE
							ENDIF

							; ---------------
							; not detected LS
							; ---------------
							IF( TMP16_REG = 0 )
								; ---------
								; over 10um
								; ---------
								; ----------
								; MOT[#3-#4]
								; ----------
								TMP4_REG = ( MOT_3_OFFSET_REG - MOT_3_POS_REG )
								TMP5_REG = ( MOT_4_OFFSET_REG - MOT_4_POS_REG )
								TMP6_REG = TMP4_REG - TMP5_REG
								IF( TMP6_REG < 0 )
									GAP_DN_DN_VAL = TMP6_REG * -1
								ELSE
									GAP_DN_DN_VAL = TMP6_REG * 1
								ENDIF
								; ----------
								; MOT[#1-#2]
								; ----------
								TMP4_REG = ( MOT_1_OFFSET_REG - MOT_1_POS_REG )
								TMP5_REG = ( MOT_2_OFFSET_REG - MOT_2_POS_REG )
								TMP6_REG = TMP4_REG - TMP5_REG
								IF( TMP6_REG < 0 )
									GAP_UP_UP_VAL = TMP6_REG * -1
								ELSE
									GAP_UP_UP_VAL = TMP6_REG * 1
								ENDIF
; --------------
; Del:2014/10/17
;								; ----------
;								; MOT[#1-#3]
;								; ----------
;								TMP4_REG = ( MOT_1_OFFSET_REG - MOT_1_POS_REG )
;								TMP5_REG = ( MOT_3_OFFSET_REG - MOT_3_POS_REG )
;								TMP6_REG = TMP4_REG - TMP5_REG
;								IF( TMP6_REG < 0 )
;									GAP_UP_DN_VAL = TMP6_REG * -1
;								ELSE
;									GAP_UP_DN_VAL = TMP6_REG * 1
;								ENDIF
;								; ----------
;								; MOT[#2-#4]
;								; ----------
;								TMP4_REG = ( MOT_2_OFFSET_REG - MOT_2_POS_REG )
;								TMP5_REG = ( MOT_4_OFFSET_REG - MOT_4_POS_REG )
;								TMP6_REG = TMP4_REG - TMP5_REG
;								IF( TMP6_REG < 0 )
;									GAP_DN_UP_VAL = TMP6_REG * -1
;								ELSE
;									GAP_DN_UP_VAL = TMP6_REG * 1
;								ENDIF
; Del:2014/10/17
; --------------
								ADJ_ERROR_REG = $000000
								ADJ_ERROR_REG = $000000
								; ----------------
								; GAP-UP-UP[#1-#2]
								; ----------------
								IF( ADJ_RANGE_MAX < GAP_UP_UP_VAL )			; over range[10um]
									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_1_ADJ_DRV
									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_2_ADJ_DRV
								ELSE
								ENDIF
								; ----------------
								; GAP-DN-DN[#3-#4]
								; ----------------
								IF( ADJ_RANGE_MAX < GAP_DN_DN_VAL )			; over range[10um]
									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_3_ADJ_DRV
									ADJ_ERROR_REG = ADJ_ERROR_REG | GAP_4_ADJ_DRV
								ELSE
								ENDIF

								; ----------
								; under 10um
								; ----------
								IF( ADJ_ERROR_REG = $000000 )
P6600 = P6600 + 1		; for Debug

									GAP__BRK_ON_REG = GAP__BRK_ON_INI		; clear count(Add 2013/09/30)

									; ---------------------------------------------
									; turns Servo-on from Servo-off(Add 2013/09/30)
									; ---------------------------------------------
									IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
										TMP9_REG = 0
										TMP9_REG = 0

										; -------
										; MOT[#1]
										; -------
										IF( SRDY_1_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
										ELSE
										ENDIF
										; -------
										; MOT[#2]
										; -------
										IF( SRDY_2_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
										ELSE
										ENDIF
										; -------
										; MOT[#3]
										; -------
										IF( SRDY_3_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
										ELSE
										ENDIF
										; -------
										; MOT[#4]
										; -------
										IF( SRDY_4_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
										ELSE
										ENDIF

										IF( TMP9_REG = 1 )
; --------------
; Add:2014/11/20
											IF( IOC_JCK_0_DRV_REG != 0 )
												IF( COMP_SCAN_REG = COMP_SCAN_DISABLE )		; Set I51=1 at setpoint move
;													COMP_FLAG_REG = COMP_SCAN_ENABLE		; Disable skew compensation
													IF( COMP_DISABLE__REG = 0 )
														COMP_FLAG_REG = COMP_SCAN_ENABLE	; Disable skew compensation
													ELSE
														COMP_FLAG_REG = COMP_SCAN_DISABLE	; Disable skew compensation
													ENDIF
												ELSE
													COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
													COMP_01_VAL_REG = 0
													COMP_17_VAL_REG = 0
													COMP_03_VAL_REG = 0
													COMP_20_VAL_REG = 0
												ENDIF
											ELSE
												COMP_FLAG_REG   = COMP_SCAN_DISABLE			; Disable skew compensation
												COMP_01_VAL_REG = 0
												COMP_17_VAL_REG = 0
												COMP_03_VAL_REG = 0
												COMP_20_VAL_REG = 0
											ENDIF
; Add:2014/11/20
; --------------
											SRDY_1_OUT = SERVO_RDY__ON
											SRDY_2_OUT = SERVO_RDY__ON
											SRDY_3_OUT = SERVO_RDY__ON
											SRDY_4_OUT = SERVO_RDY__ON

											SV_RDY_TIMER_FNC				; Wait (20msec)
											CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
											CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock

											GAP__BRAKE_REG  = SERVO_RDY_OFF		;Edited by kashima
											GAP__BRAKE_STAT = GAP__BRAKE_REG
											LOCK_1_STAT_REG = LOCK_OCCUR
											LOCK_2_STAT_REG = LOCK_OCCUR
											LOCK_3_STAT_REG = LOCK_OCCUR
											LOCK_4_STAT_REG = LOCK_OCCUR

											BRK_OFF_TIMER_FNC				; Wait (100msec)
										ELSE
										ENDIF
									ELSE									; if(SERVO_RDY_OFF)
									ENDIF									; if(SERVO_RDY_OFF)

P6142 = P6141					; for Debug (JACK command value at two times before)
P6141 = P700					; for Debug (JACK command value at last time)
P700 = IOC_JCK_0_DRV_REG		; for Debug (JACK command value at this time)

; --------------
; Add 2014/09/27
IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
	IF( PRG_EXEC_REG = 0 )

									IOC_RCV_RDY_REG = RCV_NREADY_VAL		; not ready 20150617

									CMD"&1B12R"								; Execute a motion program (&1)
	ELSE
	ENDIF
ELSE
ENDIF
; Add 2014/09/27
; --------------

								ELSE		; if(ADJ_ERROR)
								ENDIF		; if(ADJ_ERROR)
							ELSE		; if(TMP16_REG)
							ENDIF		; if(TMP16_REG)
						ELSE
						ENDIF
					ELSE
					ENDIF

;					IOC_JCK_0_DRV_REG = 0
;					IOC_JCK_0_JGP_REG = 0
;					IOC_JCK_0_JGM_REG = 0

				ELSE
				ENDIF

; --------------
; Add:2014/11/26
ELSE		; if(Mx62=Mx62)

	DEVIATION_STAT_REG = DVI_ERROR

ENDIF		; if(Mx62=Mx62)
; Add:2014/11/26
; --------------

				IOC_JCK_0_DRV_REG = 0
				IOC_JCK_0_JGP_REG = 0
				IOC_JCK_0_JGM_REG = 0

			ELSE	; if(JACK-UP)
			ENDIF	; if(JACK-UP)

			; --------------------
			; HOME POSITION[#1-#4]
			; --------------------
			IF( IOC_GO_HOME_DRV_REG != 0 OR IOC_SP_HOME_DRV_REG != 0 )
P6700 = P6700 + 1		; for Debug

				; --------------------------------------
				; Abort if Amp Fault or following error in coordinate system 1
				; (Add:2014/09/14)
				; --------------------------------------
				IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
					CMD^A						; Abort
					KILL_TIMER_FNC				; 100msec wait
					CMD^K						; Abort
					KILL_TIMER_FNC				; 100msec wait

					INITIALIZE_REG     = SYS_NORMAL
					DEVIATION_STAT_REG = DVI_NORMAL
				ELSE
				ENDIF

; --------------
; Add:2014/11/20
				COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
				COMP_01_VAL_REG = 0
				COMP_17_VAL_REG = 0
				COMP_03_VAL_REG = 0
				COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------

				IOC_RCV_RDY_REG = RCV_NREADY_VAL			; not ready 20150617

				ENABLE PLC10		; drive home position plc
				ENABLE PLC11		; checking of home ls plc
				DISABLE PLC5

			ELSE	; if(GO_HOME)
			ENDIF	; if(GO_HOME)

		ELSE			; IF(!ADJ__START)

		ENDIF			; IF(!ADJ__START)

		; -----------------
		; STOP COMMAND[GAP]
		; -----------------
;		IF( IOC_GAP_1_STP_REG != 0 AND PROG_STAT_REG = PROG_RUN_STAT )
		IF( IOC_GAP_1_STP_REG != 0 )
			GAP_1_STP_REG     = IOC_GAP_1_STP_REG
			IOC_GAP_1_STP_REG = 0

			LOCK_1_STAT_REG = LOCK_OCCUR
			LOCK_2_STAT_REG = LOCK_OCCUR
			LOCK_3_STAT_REG = LOCK_OCCUR
			LOCK_4_STAT_REG = LOCK_OCCUR

P711  = GAP_1_STP_REG			; for Debug
P6200 = P6200 + 1				; for Debug

			IF( ADJ_MODE__REG = ADJ__START )
				ADJ_STOP__REG = 1

			ELSE
P6201 = P6201 + 1				; for Debug
;				IF( PRG_EXEC_REG = PRG_EXEC_JOG OR PRG_GAP__INTLK = 1 )
				IF( PRG_EXEC_REG > 0 OR PRG_GAP__INTLK = 1 )
					CMD"H"					; JOG
					HOLD_TIMER_FNC			; 300msec wait

					HLD_COUNT_REG = 1
					WHILE( HLD_COUNT_REG < 40 )
;						IF( MOV_1_STAT_REG = MOVE_AXIS )
						IF( MOV_1_STAT_REG = MOVE_AXIS OR MOV_2_STAT_REG = MOVE_AXIS OR MOV_3_STAT_REG = MOVE_AXIS OR MOV_4_STAT_REG = MOVE_AXIS )
							HLD_COUNT_REG = HLD_COUNT_REG + 1
						ELSE
							HLD_COUNT_REG = 50
						ENDIF

						SV_RDY_TIMER_FNC
					ENDWHILE
				ELSE
				ENDIF

				CMD^A						; Abort
				KILL_TIMER_FNC				; 100msec wait

				CMD"#1J/#2J/#17J/#18J/"
				CMD"#3J/#4J/#20J/#21J/"

				KILL_TIMER_FNC				; 100msec wait
				CMD^K						; kill-all
; --------------
; Add:2015/6/19
				SRDY_1_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_2_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_3_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_4_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)

				LOCK_1_STAT_REG = UNLOCK_OCCUR
				LOCK_2_STAT_REG = UNLOCK_OCCUR
				LOCK_3_STAT_REG = UNLOCK_OCCUR
				LOCK_4_STAT_REG = UNLOCK_OCCUR

				GAP__BRK_ON_REG = GAP__BRK_ON_INI	; clear count
				GAP__BRAKE_REG  = SERVO_RDY__ON
				GAP__BRAKE_STAT = GAP__BRAKE_REG
; Add:2015/6/19
; --------------
				KILL_TIMER_FNC				; 100msec wait

				DRIVE_MODE_REG = DRIVE_STOP

				IF( PRG_EXEC_REG = PRG_EXEC_JOG OR PRG_GAP__INTLK = 1 )
					; ============================
					; Rev 2013/10/15(for BNL 2.8m)
					I0124 = MOTOR_FLAG_VAL
					I0224 = MOTOR_FLAG_VAL
					I0324 = MOTOR_FLAG_VAL
					I0424 = MOTOR_FLAG_VAL
					I1724 = MOTOR_FLAG_VAL
					I1824 = MOTOR_FLAG_VAL
					I2024 = MOTOR_FLAG_VAL
					I2124 = MOTOR_FLAG_VAL
					; Rev 2013/10/15(for BNL 2.8m)
					; ============================
				ELSE
				ENDIF

			ENDIF

			IF( PRG_GAP__INTLK = 1 )				; execute GAP-Eva program
				PRG_GAP__INTLK = 0					; clear GAP-Eva
				PRG_GAP__START = 0

				MOTOR_1_JOG  = GAP__INTLK_SPD		; set speed
				MOTOR_2_JOG  = GAP__INTLK_SPD
				MOTOR_3_JOG  = GAP__INTLK_SPD
				MOTOR_4_JOG  = GAP__INTLK_SPD
				MOTOR_17_JOG = GAP__INTLK_SPD
				MOTOR_18_JOG = GAP__INTLK_SPD
				MOTOR_20_JOG = GAP__INTLK_SPD
				MOTOR_21_JOG = GAP__INTLK_SPD

				MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
				MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
				MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
				MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
				MOTOR_17_JOG_JOG = GAP__INTLK_SPD
				MOTOR_18_JOG_JOG = GAP__INTLK_SPD
				MOTOR_20_JOG_JOG = GAP__INTLK_SPD
				MOTOR_21_JOG_JOG = GAP__INTLK_SPD
			ELSE
			ENDIF

			GAP_1_STP_REG = 0
			REF_POS_REG   = 0
			PRG_EXEC_REG  = 0
			ADJ_STOP__REG = 1

; --------------
; Add:2014/11/20
			COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
			COMP_01_VAL_REG = 0
			COMP_17_VAL_REG = 0
			COMP_03_VAL_REG = 0
			COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------

			IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617


		ELSE
		ENDIF

		; ------------------
		; STOP COMMAND[JACK]
		; ------------------
		IF( IOC_JCK_0_STP_REG != 0 )
			IF( GAP__INTLK_VAL = GAP__INTLK_DIS )
P6401 = P6401 + 1		; for Debug

				JCK_0_STP_REG     = IOC_JCK_0_STP_REG
				IOC_JCK_0_STP_REG = 0

				LOCK_1_STAT_REG = LOCK_OCCUR
				LOCK_2_STAT_REG = LOCK_OCCUR
				LOCK_3_STAT_REG = LOCK_OCCUR
				LOCK_4_STAT_REG = LOCK_OCCUR

				IF( ADJ_MODE__REG = ADJ__START )
					ADJ_STOP__REG = 1

				ELSE
;					IF( PRG_EXEC_REG = PRG_EXEC_JOG OR PRG_GAP__INTLK = 1 )
					IF( PRG_EXEC_REG > 0 OR PRG_GAP__INTLK = 1 )
						CMD"H"					; JOG
						HOLD_TIMER_FNC			; 300msec wait

						HLD_COUNT_REG = 1
						WHILE( HLD_COUNT_REG < 40 )
;							IF( MOV_1_STAT_REG = MOVE_AXIS )
							IF( MOV_1_STAT_REG = MOVE_AXIS OR MOV_2_STAT_REG = MOVE_AXIS OR MOV_3_STAT_REG = MOVE_AXIS OR MOV_4_STAT_REG = MOVE_AXIS )
								HLD_COUNT_REG = HLD_COUNT_REG + 1
							ELSE
								HLD_COUNT_REG = 50
							ENDIF

							SV_RDY_TIMER_FNC
						ENDWHILE
					ELSE
					ENDIF

					CMD^A							; Abort
					KILL_TIMER_FNC					; 100msec wait

					CMD"#1J/#2J/#17J/#18J/"			; #1,#2(GAP UPPER) Servo Lock(stop)
					CMD"#3J/#4J/#20J/#21J/"			; #3,#4(GAP LOWER) Servo Lock(stop)

					KILL_TIMER_FNC					; 100msec wait
					CMD^K							; kill-all
; --------------
; Add:2015/6/19
					SRDY_1_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
					SRDY_2_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
					SRDY_3_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
					SRDY_4_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)

					LOCK_1_STAT_REG = UNLOCK_OCCUR
					LOCK_2_STAT_REG = UNLOCK_OCCUR
					LOCK_3_STAT_REG = UNLOCK_OCCUR
					LOCK_4_STAT_REG = UNLOCK_OCCUR

					GAP__BRK_ON_REG = GAP__BRK_ON_INI	; clear count
					GAP__BRAKE_REG  = SERVO_RDY__ON
					GAP__BRAKE_STAT = GAP__BRAKE_REG
; Add:2015/6/19
; --------------
					KILL_TIMER_FNC					; 100msec wait

					DRIVE_MODE_REG = DRIVE_STOP

					IF( PRG_EXEC_REG = PRG_EXEC_JOG OR PRG_GAP__INTLK = 1 )
						; ============================
						; Rev 2013/10/15(for BNL 2.8m)
						I0124 = MOTOR_FLAG_VAL
						I0224 = MOTOR_FLAG_VAL
						I0324 = MOTOR_FLAG_VAL
						I0424 = MOTOR_FLAG_VAL
						I1724 = MOTOR_FLAG_VAL
						I1824 = MOTOR_FLAG_VAL
						I2024 = MOTOR_FLAG_VAL
						I2124 = MOTOR_FLAG_VAL
						; Rev 2013/10/15(for BNL 2.8m)
						; ============================
					ELSE
					ENDIF

				ENDIF

				IF( PRG_GAP__INTLK = 1 )				; execute GAP-Eva program
					PRG_GAP__INTLK = 0					; clear GAP-Eva
					PRG_GAP__START = 0

					MOTOR_1_JOG  = GAP__INTLK_SPD		; set speed
					MOTOR_2_JOG  = GAP__INTLK_SPD
					MOTOR_3_JOG  = GAP__INTLK_SPD
					MOTOR_4_JOG  = GAP__INTLK_SPD
					MOTOR_17_JOG = GAP__INTLK_SPD
					MOTOR_18_JOG = GAP__INTLK_SPD
					MOTOR_20_JOG = GAP__INTLK_SPD
					MOTOR_21_JOG = GAP__INTLK_SPD

					MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_17_JOG_JOG = GAP__INTLK_SPD
					MOTOR_18_JOG_JOG = GAP__INTLK_SPD
					MOTOR_20_JOG_JOG = GAP__INTLK_SPD
					MOTOR_21_JOG_JOG = GAP__INTLK_SPD
				ELSE
				ENDIF

				JCK_0_STP_REG = 0
				REF_POS_REG   = 0
				PRG_EXEC_REG  = 0
				ADJ_STOP__REG = 1

			ELSE		; if(GAP__INTLK_DIS)
			ENDIF		; if(GAP__INTLK_DIS)

; --------------
; Add:2014/11/20
			COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
			COMP_01_VAL_REG = 0
			COMP_17_VAL_REG = 0
			COMP_03_VAL_REG = 0
			COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------

			IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617

		ELSE	; if(STOP)
		ENDIF	; if(STOP)

	; ----------------
	; maintenance mode or separate mode
	; Rev 2013/10/31
	; ----------------
	ELSE		; if(ACTIVE_MODE_REG)

		; ----------------
		; maintenance mode
		; Add not adjusting mode
		; ----------------
		IF( ACTIVE_MODE_REG = MNT_MODE )
			; -------------
			; DRIVE COMMAND
			; -------------
			; ---------------
			; MOT[#1-#4](ALL)
			; ---------------
			IF( ADJ_MODE__REG != ADJ__START )
				IF( IOC_GAP_1_DRV_REG != 0 OR IOC_GAP_1_JGP_REG != 0 OR IOC_GAP_1_JGM_REG != 0 )

					; --------------------------------------
					; Abort if Amp Fault or following error in coordinate system 1
					; (Add:2014/09/14)
					; --------------------------------------
					IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
						CMD^A						; Abort
						KILL_TIMER_FNC				; 100msec wait
						CMD^K						; Kill
						KILL_TIMER_FNC				; 100msec wait

						INITIALIZE_REG     = SYS_NORMAL
						DEVIATION_STAT_REG = DVI_NORMAL
					ELSE
					ENDIF

					IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
						IF( PROG_STAT_REG = PROG_STP_STAT )
							IF( GAP__INTLK_VAL = GAP__INTLK_DIS )
								TMP8_REG = 0
								TMP8_REG = 0

								GAP_1_MOV_REG = IOC_GAP_1_DRV_REG
								GAP_1_JGP_REG = IOC_GAP_1_JGP_REG
								GAP_1_JGM_REG = IOC_GAP_1_JGM_REG
								; ----
								; Open
								; ----
								IF( IOC_GAP_1_DRV_REG > 0 OR IOC_GAP_1_JGP_REG != 0 )
									IF( OPEN_KILL_1_REG = LIMIT_OFF OR OPEN_KILL_2_REG = LIMIT_OFF )
										TMP8_REG = 1
									ELSE
									ENDIF
								ELSE
								ENDIF
								; -----
								; Close
								; -----
								IF( IOC_GAP_1_DRV_REG < 0 OR IOC_GAP_1_JGM_REG != 0 )
;									IF( CLOSE_KILL_1_REG = LIMIT_OFF OR CLOSE_KILL_2_REG = LIMIT_OFF )
									IF( CLOSE_KILL_1_REG = LIMIT_OFF OR CLOSE_KILL_2_REG = LIMIT_OFF OR GAP_CLOSE_KILL_REG = LIMIT_OFF )
										TMP8_REG = 1
									ELSE
									ENDIF
								ELSE
								ENDIF

								; ---------------
								; not detected LS
								; ---------------
								IF( TMP8_REG = 0 )
									GAP__BRK_ON_REG = GAP__BRK_ON_INI		; clear brake-on count

									; -----------------------------
									; turns Servo-on from Servo-off
									; -----------------------------
									IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
										TMP9_REG = 0
										TMP9_REG = 0

										; -------
										; MOT[#1]
										; -------
										IF( SRDY_1_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
										ELSE
										ENDIF
										; -------
										; MOT[#2]
										; -------
										IF( SRDY_2_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
										ELSE
										ENDIF
										; -------
										; MOT[#3]
										; -------
										IF( SRDY_3_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
										ELSE
										ENDIF
										; -------
										; MOT[#4]
										; -------
										IF( SRDY_4_OUT = SERVO_RDY_OFF )
											TMP9_REG   = 1
										ELSE
										ENDIF

										IF( TMP9_REG = 1 )
											SRDY_1_OUT = SERVO_RDY__ON
											SRDY_2_OUT = SERVO_RDY__ON
											SRDY_3_OUT = SERVO_RDY__ON
											SRDY_4_OUT = SERVO_RDY__ON

											SV_RDY_TIMER_FNC				; Wait (20msec)
											CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
											CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock

											GAP__BRAKE_REG  = SERVO_RDY_OFF
											GAP__BRAKE_STAT = GAP__BRAKE_REG
											LOCK_1_STAT_REG = LOCK_OCCUR
											LOCK_2_STAT_REG = LOCK_OCCUR
											LOCK_3_STAT_REG = LOCK_OCCUR
											LOCK_4_STAT_REG = LOCK_OCCUR

											BRK_OFF_TIMER_FNC				; Wait (100msec)
										ELSE
										ENDIF
									ELSE									; if(SERVO_RDY_OFF)
									ENDIF									; if(SERVO_RDY_OFF)

P710  = IOC_GAP_1_DRV_REG		; for Debug
P6100 = P6100 + 1				; for Debug
P6101 = ADJ_ERROR_REG			; for Debug

; --------------
; Add:2014/09/27
IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
	IF( PRG_EXEC_REG = 0 )

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

									CMD"&1B14R"							; Execute a motion program (&1)
	ELSE
	ENDIF
ELSE
ENDIF
; Add:2014/09/27
; --------------

								ELSE		; if(TMP8_REG)
								ENDIF		; if(TMP8_REG)
							ELSE		; if(GAP__INTLK_DIS)
							ENDIF		; if(GAP__INTLK_DIS)
						ELSE		; if(PROG_STP_STAT)
						ENDIF		; if(PROG_STP_STAT)

						IOC_GAP_1_DRV_REG = 0
						IOC_GAP_1_JGP_REG = 0
						IOC_GAP_1_JGM_REG = 0

					ELSE		; if(STOP_AXIS)
					ENDIF		; if(STOP_AXIS)
				ELSE		; if(receive command)
				ENDIF		; if(receive command)

				; ----------------
				; MOT[#1-2](UPPER)
				; ----------------
				IF( IOC_GAP_2_DRV_REG != 0 OR IOC_GAP_2_JGP_REG != 0 OR IOC_GAP_2_JGM_REG != 0 )

					; --------------------------------------
					; Abort if Amp Fault or following error in coordinate system 1
					; (Add:2014/09/14)
					; --------------------------------------
					IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
						CMD^A						; Abort
						KILL_TIMER_FNC				; 100msec wait
						CMD^K						; Kill
						KILL_TIMER_FNC				; 100msec wait

						INITIALIZE_REG     = SYS_NORMAL
						DEVIATION_STAT_REG = DVI_NORMAL

					ELSE
					ENDIF

					IF( PROG_STAT_REG = PROG_STP_STAT )
						IF( GAP__INTLK_VAL = GAP__INTLK_DIS )		; Add 2013/09/30
							GAP_2_MOV_REG = IOC_GAP_2_DRV_REG
							GAP_2_JGP_REG = IOC_GAP_2_JGP_REG
							GAP_2_JGM_REG = IOC_GAP_2_JGM_REG

							GAP__BRK_ON_REG = GAP__BRK_ON_INI		; clear brake-on count

							; ---------------------------------------------
							; turns Servo-on from Servo-off(Add 2013/09/30)
							; ---------------------------------------------
							IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
								TMP9_REG = 0
								TMP9_REG = 0

								; -------
								; MOT[#1]
								; -------
								IF( SRDY_1_OUT = SERVO_RDY_OFF )
									TMP9_REG   = 1
								ELSE
								ENDIF
								; -------
								; MOT[#2]
								; -------
								IF( SRDY_2_OUT = SERVO_RDY_OFF )
									TMP9_REG   = 1
								ELSE
								ENDIF
								; -------
								; MOT[#3]
								; -------
								IF( SRDY_3_OUT = SERVO_RDY_OFF )
									TMP9_REG   = 1
								ELSE
								ENDIF
								; -------
								; MOT[#4]
								; -------
								IF( SRDY_4_OUT = SERVO_RDY_OFF )
									TMP9_REG   = 1
								ELSE
								ENDIF

								IF( TMP9_REG = 1 )
									SRDY_1_OUT = SERVO_RDY__ON
									SRDY_2_OUT = SERVO_RDY__ON
									SRDY_3_OUT = SERVO_RDY__ON
									SRDY_4_OUT = SERVO_RDY__ON

									SV_RDY_TIMER_FNC				; Wait (20msec)
									CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
									CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock

									GAP__BRAKE_REG  = SERVO_RDY_OFF
									GAP__BRAKE_STAT = GAP__BRAKE_REG
									LOCK_1_STAT_REG = LOCK_OCCUR
									LOCK_2_STAT_REG = LOCK_OCCUR
									LOCK_3_STAT_REG = LOCK_OCCUR
									LOCK_4_STAT_REG = LOCK_OCCUR

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF
							ELSE									; if(SERVO_RDY_OFF)
							ENDIF									; if(SERVO_RDY_OFF)

P720  = IOC_GAP_2_DRV_REG		; for Debug
P6120 = P6120 + 1				; for Debug
P6121 = ADJ_ERROR_REG			; for Debug

; --------------
; Add:2014/09/27
IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
	IF( PRG_EXEC_REG = 0 )

							IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

							CMD"&1B14R"							; Execute a motion program (&1)
	ELSE
	ENDIF
ELSE
ENDIF
; Add:2014/09/27
; --------------
						ELSE								; if(GAP__INTLK_DIS)
						ENDIF								; if(GAP__INTLK_DIS)
					ELSE								; if(PROG_STP_STAT)
					ENDIF								; if(PROG_STP_STAT)

					IOC_GAP_2_DRV_REG = 0
					IOC_GAP_2_JGP_REG = 0
					IOC_GAP_2_JGM_REG = 0

				ELSE		; if(receive command)
				ENDIF		; if(receive command)

				; -----------------
				; MOT[#3-#4](LOWER)
				; -----------------
				IF( IOC_GAP_3_DRV_REG != 0 OR IOC_GAP_3_JGP_REG != 0 OR IOC_GAP_3_JGM_REG != 0 )

					; --------------------------------------
					; Abort if Amp Fault or following error in coordinate system 1
					; (Add:2014/09/14)
					; --------------------------------------
					IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
						CMD^A						; Abort
						KILL_TIMER_FNC				; 100msec wait
						CMD^K						; Kill
						KILL_TIMER_FNC				; 100msec wait

						INITIALIZE_REG     = SYS_NORMAL
						DEVIATION_STAT_REG = DVI_NORMAL
					ELSE
					ENDIF

					IF( PROG_STAT_REG = PROG_STP_STAT )
						IF( GAP__INTLK_VAL = GAP__INTLK_DIS )
							GAP_3_MOV_REG = IOC_GAP_3_DRV_REG
							GAP_3_JGP_REG = IOC_GAP_3_JGP_REG
							GAP_3_JGM_REG = IOC_GAP_3_JGM_REG

							GAP__BRK_ON_REG = GAP__BRK_ON_INI		;clear brake-on count

							; -----------------------------
							; turns Servo-on from Servo-off
							; -----------------------------
							IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
								TMP9_REG = 0
								TMP9_REG = 0

								; -------
								; MOT[#1]
								; -------
								IF( SRDY_1_OUT = SERVO_RDY_OFF )
									TMP9_REG   = 1
								ELSE
								ENDIF
								; -------
								; MOT[#2]
								; -------
								IF( SRDY_2_OUT = SERVO_RDY_OFF )
									TMP9_REG   = 1
								ELSE
								ENDIF
								; -------
								; MOT[#3]
								; -------
								IF( SRDY_3_OUT = SERVO_RDY_OFF )
									TMP9_REG   = 1
								ELSE
								ENDIF
								; -------
								; MOT[#4]
								; -------
								IF( SRDY_4_OUT = SERVO_RDY_OFF )
									TMP9_REG   = 1
								ELSE
								ENDIF

								IF( TMP9_REG = 1 )
									SRDY_1_OUT = SERVO_RDY__ON
									SRDY_2_OUT = SERVO_RDY__ON
									SRDY_3_OUT = SERVO_RDY__ON
									SRDY_4_OUT = SERVO_RDY__ON

;									SV_RDY_TIMER_FNC				; Wait (20msec) comment out 20150529
									CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
									CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock

									GAP__BRAKE_REG  = SERVO_RDY_OFF
									GAP__BRAKE_STAT = GAP__BRAKE_REG
									LOCK_1_STAT_REG = LOCK_OCCUR
									LOCK_2_STAT_REG = LOCK_OCCUR
									LOCK_3_STAT_REG = LOCK_OCCUR
									LOCK_4_STAT_REG = LOCK_OCCUR

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF
							ELSE									; if(SERVO_RDY_OFF)
							ENDIF									; if(SERVO_RDY_OFF)

P730  = IOC_GAP_3_DRV_REG		; for Debug
P6130 = P6130 + 1				; for Debug
P6131 = ADJ_ERROR_REG			; for Debug

; --------------
; Add:2014/09/27
IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
	IF( PRG_EXEC_REG = 0 )

							IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

							CMD"&1B14R"							; Execute a motion program (&1)
	ELSE
	ENDIF
ELSE
ENDIF
; Add:2014/09/27
; --------------
						ELSE								; if(GAP__INTLK_DIS)
						ENDIF								; if(GAP__INTLK_DIS)
					ELSE								; if(PROG_STP_STAT)
					ENDIF								; if(PROG_STP_STAT)

					IOC_GAP_3_DRV_REG = 0
					IOC_GAP_3_JGP_REG = 0
					IOC_GAP_3_JGM_REG = 0

				ELSE			; if(receive command)
				ENDIF			; if(receive command)
			ELSE			; if(!ADJ__START)
			ENDIF			; if(!ADJ__START)

			; ------------
			; STOP COMMAND
			; ------------
			; ---------------
			; MOT[#1-#4](ALL)
			; ---------------
			IF( IOC_GAP_1_STP_REG != 0 )
				GAP_1_STP_REG     = IOC_GAP_1_STP_REG
				IOC_GAP_1_STP_REG = 0

				LOCK_1_STAT_REG = LOCK_OCCUR
				LOCK_2_STAT_REG = LOCK_OCCUR
				LOCK_3_STAT_REG = LOCK_OCCUR
				LOCK_4_STAT_REG = LOCK_OCCUR

;				IF( PRG_EXEC_REG = PRG_EXEC_JOG )
				IF( PRG_EXEC_REG > 0 )
					CMD"H"						; JOG
					HOLD_TIMER_FNC				; 300msec wait

					HLD_COUNT_REG = 1
					WHILE( HLD_COUNT_REG < 40 )
;						IF( MOV_1_STAT_REG = MOVE_AXIS )
						IF( MOV_1_STAT_REG = MOVE_AXIS OR MOV_2_STAT_REG = MOVE_AXIS OR MOV_3_STAT_REG = MOVE_AXIS OR MOV_4_STAT_REG = MOVE_AXIS )
							HLD_COUNT_REG = HLD_COUNT_REG + 1
						ELSE
							HLD_COUNT_REG = 50
						ENDIF

						SV_RDY_TIMER_FNC
					ENDWHILE
				ELSE
				ENDIF

				CMD^A							; Abort
				KILL_TIMER_FNC					; 100msec wait

;				CMD"#1J/#17J/"
				CMD"#1J/#2J/#17J/#18J/"			; #1,#2(GAP UPPER) Servo Lock(stop)
				CMD"#3J/#4J/#20J/#21J/"			; #3,#4(GAP LOWER) Servo Lock(stop)

				KILL_TIMER_FNC					; 100msec wait
				CMD^K							; kill-all
; --------------
; Add:2015/6/19
				SRDY_1_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_2_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_3_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_4_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)

				LOCK_1_STAT_REG = UNLOCK_OCCUR
				LOCK_2_STAT_REG = UNLOCK_OCCUR
				LOCK_3_STAT_REG = UNLOCK_OCCUR
				LOCK_4_STAT_REG = UNLOCK_OCCUR

				GAP__BRK_ON_REG = GAP__BRK_ON_INI	; clear count
				GAP__BRAKE_REG  = SERVO_RDY__ON
				GAP__BRAKE_STAT = GAP__BRAKE_REG
; Add:2015/6/19
; --------------
				KILL_TIMER_FNC					; 100msec wait

				DRIVE_MODE_REG = DRIVE_STOP

				IF( PRG_GAP__INTLK = 1 )					; Add 2013/10/03(speed)
					PRG_GAP__INTLK = 0
					PRG_GAP__START = 0

					MOTOR_1_JOG  = GAP__INTLK_SPD
					MOTOR_2_JOG  = GAP__INTLK_SPD
					MOTOR_3_JOG  = GAP__INTLK_SPD
					MOTOR_4_JOG  = GAP__INTLK_SPD
					MOTOR_17_JOG = GAP__INTLK_SPD
					MOTOR_18_JOG = GAP__INTLK_SPD
					MOTOR_20_JOG = GAP__INTLK_SPD
					MOTOR_21_JOG = GAP__INTLK_SPD

					MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_17_JOG_JOG = GAP__INTLK_SPD
					MOTOR_18_JOG_JOG = GAP__INTLK_SPD
					MOTOR_20_JOG_JOG = GAP__INTLK_SPD
					MOTOR_21_JOG_JOG = GAP__INTLK_SPD
				ELSE										; Add 2013/10/03(speed)
				ENDIF										; Add 2013/10/03(speed)

				GAP_1_STP_REG = 0
				REF_POS_REG   = 0
				PRG_EXEC_REG  = 0
				ADJ_STOP__REG = 1

				IOC_RCV_RDY_REG = RCV__READY_VAL				; ready 20150617

			ELSE
			ENDIF


			; -----------------
			; MOT[#1-#2](UPPER)
			; -----------------
			IF( IOC_GAP_2_STP_REG != 0 )
				GAP_2_STP_REG     = IOC_GAP_2_STP_REG
				IOC_GAP_2_STP_REG = 0

				LOCK_1_STAT_REG = LOCK_OCCUR
				LOCK_2_STAT_REG = LOCK_OCCUR
				LOCK_3_STAT_REG = LOCK_OCCUR
				LOCK_4_STAT_REG = LOCK_OCCUR

;				IF( PRG_EXEC_REG = PRG_EXEC_JOG )
				IF( PRG_EXEC_REG > 0 )
					CMD"H"						; JOG
					HOLD_TIMER_FNC				; 300msec wait

					HLD_COUNT_REG = 1
					WHILE( HLD_COUNT_REG < 40 )
;						IF( MOV_1_STAT_REG = MOVE_AXIS )
						IF( MOV_1_STAT_REG = MOVE_AXIS OR MOV_2_STAT_REG = MOVE_AXIS OR MOV_3_STAT_REG = MOVE_AXIS OR MOV_4_STAT_REG = MOVE_AXIS )
							HLD_COUNT_REG = HLD_COUNT_REG + 1
						ELSE
							HLD_COUNT_REG = 50
						ENDIF

						SV_RDY_TIMER_FNC
					ENDWHILE
				ELSE
				ENDIF

				CMD^A							; Abort
				KILL_TIMER_FNC					; 100msec wait

				CMD"#1J/#2J/#17J/#18J/"			; #1,#2(GAP UPPER) Servo Lock(stop)
;				CMD"#3J/#4J/#20J/#21J/"			; #3,#4(GAP LOWER) Servo Lock(stop)

				KILL_TIMER_FNC					; 100msec wait
				CMD^K							; kill-all
; --------------
; Add:2015/6/19
				SRDY_1_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_2_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_3_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_4_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)

				LOCK_1_STAT_REG = UNLOCK_OCCUR
				LOCK_2_STAT_REG = UNLOCK_OCCUR
				LOCK_3_STAT_REG = UNLOCK_OCCUR
				LOCK_4_STAT_REG = UNLOCK_OCCUR

				GAP__BRK_ON_REG = GAP__BRK_ON_INI	; clear count
				GAP__BRAKE_REG  = SERVO_RDY__ON
				GAP__BRAKE_STAT = GAP__BRAKE_REG
; Add:2015/6/19
; --------------
				KILL_TIMER_FNC					; 100msec wait

				DRIVE_MODE_REG = DRIVE_STOP

				IF( PRG_GAP__INTLK = 1 )					; Add 2013/10/03(speed)
					PRG_GAP__INTLK = 0
					PRG_GAP__START = 0

					MOTOR_1_JOG  = GAP__INTLK_SPD
					MOTOR_2_JOG  = GAP__INTLK_SPD
					MOTOR_3_JOG  = GAP__INTLK_SPD
					MOTOR_4_JOG  = GAP__INTLK_SPD
					MOTOR_17_JOG = GAP__INTLK_SPD
					MOTOR_18_JOG = GAP__INTLK_SPD
					MOTOR_20_JOG = GAP__INTLK_SPD
					MOTOR_21_JOG = GAP__INTLK_SPD

					MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_17_JOG_JOG = GAP__INTLK_SPD
					MOTOR_18_JOG_JOG = GAP__INTLK_SPD
					MOTOR_20_JOG_JOG = GAP__INTLK_SPD
					MOTOR_21_JOG_JOG = GAP__INTLK_SPD
				ELSE										; Add 2013/10/03(speed)
				ENDIF										; Add 2013/10/03(speed)

				GAP_2_STP_REG = 0
				REF_POS_REG   = 0
				PRG_EXEC_REG  = 0

				IOC_RCV_RDY_REG = RCV__READY_VAL				; ready 20150617

			ELSE
			ENDIF

			; -----------------
			; MOT[#3-#4](LOWER)
			; -----------------
			IF( IOC_GAP_3_STP_REG != 0 )
				GAP_3_STP_REG     = IOC_GAP_3_STP_REG
				IOC_GAP_3_STP_REG = 0

				LOCK_1_STAT_REG = LOCK_OCCUR
				LOCK_2_STAT_REG = LOCK_OCCUR
				LOCK_3_STAT_REG = LOCK_OCCUR
				LOCK_4_STAT_REG = LOCK_OCCUR

;				IF( PRG_EXEC_REG = PRG_EXEC_JOG )
				IF( PRG_EXEC_REG > 0 )
					CMD"H"						; JOG
					HOLD_TIMER_FNC				; 300msec wait

					HLD_COUNT_REG = 1
					WHILE( HLD_COUNT_REG < 40 )
;						IF( MOV_3_STAT_REG = MOVE_AXIS )
						IF( MOV_1_STAT_REG = MOVE_AXIS OR MOV_2_STAT_REG = MOVE_AXIS OR MOV_3_STAT_REG = MOVE_AXIS OR MOV_4_STAT_REG = MOVE_AXIS )
							HLD_COUNT_REG = HLD_COUNT_REG + 1
						ELSE
							HLD_COUNT_REG = 50
						ENDIF

						SV_RDY_TIMER_FNC
					ENDWHILE
				ELSE
				ENDIF

				CMD^A							; Abort
				KILL_TIMER_FNC					; 100msec wait

;				CMD"#1J/#2J/#17J/#18J/"			; #1,#2(GAP UPPER) Servo Lock(stop)
				CMD"#3J/#4J/#20J/#21J/"			; #3,#4(GAP LOWER) Servo Lock(stop)

				KILL_TIMER_FNC					; 100msec wait
				CMD^K							; kill-all
; --------------
; Add:2015/6/19
				SRDY_1_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_2_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_3_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
				SRDY_4_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)

				LOCK_1_STAT_REG = UNLOCK_OCCUR
				LOCK_2_STAT_REG = UNLOCK_OCCUR
				LOCK_3_STAT_REG = UNLOCK_OCCUR
				LOCK_4_STAT_REG = UNLOCK_OCCUR

				GAP__BRK_ON_REG = GAP__BRK_ON_INI	; clear count
				GAP__BRAKE_REG  = SERVO_RDY__ON
				GAP__BRAKE_STAT = GAP__BRAKE_REG
; Add:2015/6/19
; --------------
				KILL_TIMER_FNC					; 100msec wait

				DRIVE_MODE_REG = DRIVE_STOP

				IF( PRG_GAP__INTLK = 1 )					; Add 2013/10/03(speed)
					PRG_GAP__INTLK = 0
					PRG_GAP__START = 0

					MOTOR_1_JOG  = GAP__INTLK_SPD
					MOTOR_2_JOG  = GAP__INTLK_SPD
					MOTOR_3_JOG  = GAP__INTLK_SPD
					MOTOR_4_JOG  = GAP__INTLK_SPD
					MOTOR_17_JOG = GAP__INTLK_SPD
					MOTOR_18_JOG = GAP__INTLK_SPD
					MOTOR_20_JOG = GAP__INTLK_SPD
					MOTOR_21_JOG = GAP__INTLK_SPD

					MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
					MOTOR_17_JOG_JOG = GAP__INTLK_SPD
					MOTOR_18_JOG_JOG = GAP__INTLK_SPD
					MOTOR_20_JOG_JOG = GAP__INTLK_SPD
					MOTOR_21_JOG_JOG = GAP__INTLK_SPD
				ELSE										; Add 2013/10/03(speed)
				ENDIF										; Add 2013/10/03(speed)

				GAP_3_STP_REG = 0
				REF_POS_REG   = 0
				PRG_EXEC_REG  = 0

				IOC_RCV_RDY_REG = RCV__READY_VAL				; ready 20150617

			ELSE
			ENDIF

		; ----------------
		; separate mode
		; Add not adjusting mode
		; ----------------
		ELSE		; if(MNT_MODE)
			; -------------
			; DRIVE COMMAND
			; -------------
			; -------
			; MOT[#1]
			; -------
			IF( ADJ_MODE__REG != ADJ__START )
				IF( IOC_GAP_4_DRV_REG != 0 OR IOC_GAP_4_JGP_REG != 0 OR IOC_GAP_4_JGM_REG != 0 )

					; --------------------------------------
					; Abort if Amp Fault or following error in coordinate system
					; (Add:2014/09/14)
					; --------------------------------------
					IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
						CMD^A						; Abort
						KILL_TIMER_FNC				; 100msec wait
						CMD^K						; Kill
						KILL_TIMER_FNC				; 100msec wait

						INITIALIZE_REG     = SYS_NORMAL
						DEVIATION_STAT_REG = DVI_NORMAL
					ELSE
					ENDIF

					IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
						IF( PROG_STAT_REG = PROG_STP_STAT )
							GAP_4_MOV_REG = IOC_GAP_4_DRV_REG
							GAP_4_JGP_REG = IOC_GAP_4_JGP_REG
							GAP_4_JGM_REG = IOC_GAP_4_JGM_REG

							GAP__BRK_ON_REG = GAP__BRK_ON_INI		; Add 2013/12/08(clear count)

							MOTOR_1_JOG      = SPA_SPD				; Set separate mode velocity
							MOTOR_1_JOG_JOG  = SPA_SPD				; Set separate mode velocity

							; ---------------------------------------------
							; turns Servo-on from Servo-off(Add 2013/10/30)
							; ---------------------------------------------
							IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
								IF( SRDY_1_OUT = SERVO_RDY_OFF )
									SRDY_1_OUT = SERVO_RDY__ON
;									SV_RDY_TIMER_FNC				; Wait (20msec) comment out 20150529

									CMD"#1J/"						; Servo-Lock

									GAP__BRAKE_REG  = SERVO_RDY_OFF
									GAP__BRAKE_STAT = GAP__BRAKE_REG
									LOCK_1_STAT_REG = LOCK_OCCUR
								ELSE
								ENDIF

								BRK_OFF_TIMER_FNC					; Wait (100msec)

							ELSE
							ENDIF

							IF( GAP_4_MOV_REG != 0 )
								IF( MOV_1_STAT_REG = STOP_AXIS )
									M172 = GAP_4_MOV_REG

									IF( GAP_4_MOV_REG > 0 )
										MOT_1_DIR_REG = CCW_DIR
									ELSE
										MOT_1_DIR_REG = CW__DIR
									ENDIF

									BRK_OFF_TIMER_FNC				; Wait (100msec)

P6301 = GAP_4_MOV_REG		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

;;									CMD"#1J^(GAP_4_MOV_REG)"		; Axis drive(GAP)
									CMD"#1J^*"						; Axis drive(GAP)

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF

								GAP_4_MOV_REG = 0;					; Clear data received from IOC
							ELSE
							ENDIF

							IF( GAP_4_JGP_REG != 0 )
								IF( MOV_1_STAT_REG = STOP_AXIS )
									BRK_OFF_TIMER_FNC				; Wait (100msec)
									MOT_1_DIR_REG = CCW_DIR

P6321 = P6321 + 1		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

									CMD"#1J+"

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF

								GAP_4_JGP_REG = 0;					; Clear data received from IOC
							ELSE
							ENDIF

							IF( GAP_4_JGM_REG != 0 )
								IF( MOV_1_STAT_REG = STOP_AXIS )
									BRK_OFF_TIMER_FNC				; Wait (100msec)
									MOT_1_DIR_REG = CW__DIR

P6331 = P6331 + 1		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

									CMD"#1J-"

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF

								GAP_4_JGM_REG = 0;					; Clear data from IOC
							ELSE
							ENDIF
						ELSE
						ENDIF
					ELSE
					ENDIF

					IOC_GAP_4_DRV_REG = 0
					IOC_GAP_4_JGP_REG = 0
					IOC_GAP_4_JGM_REG = 0
				ELSE
				ENDIF

				; -------
				; MOT[#2]
				; -------
				IF( IOC_GAP_5_DRV_REG != 0 OR IOC_GAP_5_JGP_REG != 0 OR IOC_GAP_5_JGM_REG != 0 )

					; --------------------------------------
					; Abort if Amp Fault or following error in coordinate system
					; (Add:2014/09/14)
					; --------------------------------------
					IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
						CMD^A						; Abort
						KILL_TIMER_FNC				; 100msec wait
						CMD^K						; Kill
						KILL_TIMER_FNC				; 100msec wait

						INITIALIZE_REG     = SYS_NORMAL
						DEVIATION_STAT_REG = DVI_NORMAL
					ELSE
					ENDIF

					IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
						IF( PROG_STAT_REG = PROG_STP_STAT )
							GAP_5_MOV_REG = IOC_GAP_5_DRV_REG
							GAP_5_JGP_REG = IOC_GAP_5_JGP_REG
							GAP_5_JGM_REG = IOC_GAP_5_JGM_REG

							GAP__BRK_ON_REG = GAP__BRK_ON_INI		; Add 2013/12/08(clear count)

							MOTOR_2_JOG      = SPA_SPD				; Set separate mode velocity
							MOTOR_2_JOG_JOG  = SPA_SPD				; Set separate mode velocity

							; ---------------------------------------------
							; turns Servo-on from Servo-off(Add 2013/10/30)
							; ---------------------------------------------
							IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
								IF( SRDY_2_OUT = SERVO_RDY_OFF )
									SRDY_2_OUT = SERVO_RDY__ON
;									SV_RDY_TIMER_FNC				; Wait (20msec) comment out 20150529

									CMD"#2J/"						; Servo-Lock

									GAP__BRAKE_REG  = SERVO_RDY_OFF
									GAP__BRAKE_STAT = GAP__BRAKE_REG
									LOCK_2_STAT_REG = LOCK_OCCUR
								ELSE
								ENDIF

								BRK_OFF_TIMER_FNC					; Wait (100msec)
							ELSE
							ENDIF

							IF( GAP_5_MOV_REG != 0 )
								IF( MOV_2_STAT_REG = STOP_AXIS )
									M272 = GAP_5_MOV_REG

									IF( GAP_5_MOV_REG > 0 )
										MOT_2_DIR_REG = CCW_DIR
									ELSE
										MOT_2_DIR_REG = CW__DIR
									ENDIF

									BRK_OFF_TIMER_FNC				; Wait (100msec)

P6302 = GAP_5_MOV_REG		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

;;									CMD"#2J^(GAP_5_MOV_REG)"		; Axis drive(GAP)
									CMD"#2J^*"						; Axis drive(GAP)

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF

								GAP_5_MOV_REG = 0;					; Clear data received from IOC
							ELSE
							ENDIF

							IF( GAP_5_JGP_REG != 0 )
								IF( MOV_2_STAT_REG = STOP_AXIS )
									BRK_OFF_TIMER_FNC				; Wait (100msec)

									MOT_2_DIR_REG = CCW_DIR

P6322 = P6322 + 1		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

									CMD"#2J+"

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF

								GAP_5_JGP_REG = 0;					; Clear data received from IOC
							ELSE
							ENDIF

							IF( GAP_5_JGM_REG != 0 )
								IF( MOV_2_STAT_REG = STOP_AXIS )
									BRK_OFF_TIMER_FNC					; Wait (100msec)

									MOT_2_DIR_REG = CW__DIR

P6332 = P6332 + 1		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

									CMD"#2J-"

									BRK_OFF_TIMER_FNC					; Wait (100msec)
								ELSE
								ENDIF

								GAP_5_JGM_REG = 0;					; Clear data received from IOC
							ELSE
							ENDIF
						ELSE
						ENDIF
					ELSE
					ENDIF

					IOC_GAP_5_DRV_REG = 0
					IOC_GAP_5_JGP_REG = 0
					IOC_GAP_5_JGM_REG = 0
				ELSE
				ENDIF

				; -------
				; MOT[#3]
				; -------
				IF( IOC_GAP_6_DRV_REG != 0 OR IOC_GAP_6_JGP_REG != 0 OR IOC_GAP_6_JGM_REG != 0 )

					; --------------------------------------
					; Abort if Amp Fault or following error in coordinate system 1
					; (Add:2014/09/14)
					; --------------------------------------
					IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
						CMD^A						; Abort
						KILL_TIMER_FNC				; 100msec wait
						CMD^K						; Kill
						KILL_TIMER_FNC				; 100msec wait

						INITIALIZE_REG     = SYS_NORMAL
						DEVIATION_STAT_REG = DVI_NORMAL
					ELSE
					ENDIF

					IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
						IF( PROG_STAT_REG = PROG_STP_STAT )
							GAP_6_MOV_REG = IOC_GAP_6_DRV_REG
							GAP_6_JGP_REG = IOC_GAP_6_JGP_REG
							GAP_6_JGM_REG = IOC_GAP_6_JGM_REG

							GAP__BRK_ON_REG = GAP__BRK_ON_INI		; Add 2013/12/08(clear count)

							MOTOR_3_JOG      = SPA_SPD				; Set separate mode velocity
							MOTOR_3_JOG_JOG  = SPA_SPD				; Set separate mode velocity

							; ---------------------------------------------
							; turns Servo-on from Servo-off(Add 2013/10/30)
							; ---------------------------------------------
							IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
								IF( SRDY_3_OUT = SERVO_RDY_OFF )
									SRDY_3_OUT = SERVO_RDY__ON
;									SV_RDY_TIMER_FNC				; Wait (20msec) comment out 20150529

									CMD"#3J/"						; Servo-Lock

									GAP__BRAKE_REG  = SERVO_RDY_OFF
									GAP__BRAKE_STAT = GAP__BRAKE_REG
									LOCK_3_STAT_REG = LOCK_OCCUR
								ELSE
								ENDIF

								BRK_OFF_TIMER_FNC					; Wait (100msec)

							ELSE
							ENDIF

							IF( GAP_6_MOV_REG != 0 )
								IF( MOV_3_STAT_REG = STOP_AXIS )
									M372 = GAP_6_MOV_REG
									BRK_OFF_TIMER_FNC				; Wait (100msec)

									IF( GAP_6_MOV_REG > 0 )
										MOT_3_DIR_REG = CCW_DIR
									ELSE
										MOT_3_DIR_REG = CW__DIR
									ENDIF

P6303 = GAP_6_MOV_REG		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

;;									CMD"#3J^(GAP_6_MOV_REG)"		; Axis drive(GAP)
									CMD"#3J^*"						; Axis drive(GAP)

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF

								GAP_6_MOV_REG = 0;					; Clear data received from IOC
							ELSE
							ENDIF

							IF( GAP_6_JGP_REG != 0 )
								IF( MOV_3_STAT_REG = STOP_AXIS )
									BRK_OFF_TIMER_FNC				; Wait (100msec)

									MOT_3_DIR_REG = CCW_DIR

P6323 = P6323 + 1		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

									CMD"#3J+"

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF

								GAP_6_JGP_REG = 0;					; Clear data received from IOC
							ELSE
							ENDIF

							IF( GAP_6_JGM_REG != 0 )
								IF( MOV_3_STAT_REG = STOP_AXIS )
									BRK_OFF_TIMER_FNC				; Wait (100msec)
									MOT_3_DIR_REG = CW__DIR
P6333 = P6333 + 1		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

									CMD"#3J-"

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF

								GAP_6_JGM_REG = 0;					; Clear data received from IOC
							ELSE
							ENDIF
						ELSE
						ENDIF
					ELSE
					ENDIF

					IOC_GAP_6_DRV_REG = 0
					IOC_GAP_6_JGP_REG = 0
					IOC_GAP_6_JGM_REG = 0
				ELSE
				ENDIF

				; -------
				; MOT[#4]
				; -------
				IF( IOC_GAP_7_DRV_REG != 0 OR IOC_GAP_7_JGP_REG != 0 OR IOC_GAP_7_JGM_REG != 0 )

					; --------------------------------------
					; Abort if Amp Fault or following error in coordinate system 1
					; (Add:2014/09/14)
					; --------------------------------------
					IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
						CMD^A						; Abort
						KILL_TIMER_FNC				; 100msec wait
						CMD^K						; Kill
						KILL_TIMER_FNC				; 100msec wait

						INITIALIZE_REG     = SYS_NORMAL
						DEVIATION_STAT_REG = DVI_NORMAL
					ELSE
					ENDIF

					IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
						IF( PROG_STAT_REG = PROG_STP_STAT )
							GAP_7_MOV_REG = IOC_GAP_7_DRV_REG
							GAP_7_JGP_REG = IOC_GAP_7_JGP_REG
							GAP_7_JGM_REG = IOC_GAP_7_JGM_REG

							GAP__BRK_ON_REG = GAP__BRK_ON_INI		; Add 2013/12/08(clear count)

							MOTOR_4_JOG      = SPA_SPD				; Set separate mode velocity
							MOTOR_4_JOG_JOG  = SPA_SPD				; Set separate mode velocity

							; ---------------------------------------------
							; turns Servo-on from Servo-off(Add 2013/10/30)
							; ---------------------------------------------
							IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
								IF( SRDY_4_OUT = SERVO_RDY_OFF )
									SRDY_4_OUT = SERVO_RDY__ON
;									SV_RDY_TIMER_FNC				; Wait (20msec) comment out 20150529

									CMD"#4J/"						; Servo-Lock

									GAP__BRAKE_REG  = SERVO_RDY_OFF
									GAP__BRAKE_STAT = GAP__BRAKE_REG
									LOCK_4_STAT_REG = LOCK_OCCUR
								ELSE
								ENDIF

								BRK_OFF_TIMER_FNC					; Wait (100msec)

							ELSE
							ENDIF

							IF( GAP_7_MOV_REG != 0 )
								IF( MOV_4_STAT_REG = STOP_AXIS )
									M472 = GAP_7_MOV_REG
									BRK_OFF_TIMER_FNC				; Wait (100msec)

									IF( GAP_7_MOV_REG > 0 )
										MOT_4_DIR_REG = CCW_DIR
									ELSE
										MOT_4_DIR_REG = CW__DIR
									ENDIF

P6304 = GAP_7_MOV_REG		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

;;									CMD"#4J^(GAP_7_MOV_REG)"		; Axis drive(GAP)
									CMD"#4J^*"						; Axis drive(GAP)

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF

								GAP_7_MOV_REG = 0;					; Clear data received from IOC
							ELSE
							ENDIF

							IF( GAP_7_JGP_REG != 0 )
								IF( MOV_4_STAT_REG = STOP_AXIS )
									BRK_OFF_TIMER_FNC				; Wait (100msec)

									MOT_4_DIR_REG = CCW_DIR

P6324 = P6324 + 1		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

									CMD"#4J+"

									BRK_OFF_TIMER_FNC				; Wait(100msec)
								ELSE
								ENDIF

								GAP_7_JGP_REG = 0;					; Clear data received from IOC
							ELSE
							ENDIF

							IF( GAP_7_JGM_REG != 0 )
								IF( MOV_4_STAT_REG = STOP_AXIS )
									BRK_OFF_TIMER_FNC				; Wait (100msec)

									MOT_4_DIR_REG = CW__DIR

P6334 = P6334 + 1		; for Debug

									IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617

									CMD"#4J-"

									BRK_OFF_TIMER_FNC				; Wait (100msec)
								ELSE
								ENDIF

								GAP_7_JGM_REG = 0;					; Clear data received from IOC
							ELSE
							ENDIF
						ELSE
						ENDIF
					ELSE
					ENDIF

					IOC_GAP_7_DRV_REG = 0
					IOC_GAP_7_JGP_REG = 0
					IOC_GAP_7_JGM_REG = 0
				ELSE
				ENDIF
			ELSE			; IF(!ADJ__START)
			ENDIF			; IF(!ADJ__START)


			; ------------
			; STOP COMMAND
			; ------------
			IF( ADJ_MODE__REG != ADJ__START )

				; -------
				; MOT[#1]
				; -------
				IF( IOC_GAP_4_STP_REG != 0 )
					GAP_4_STP_REG     = IOC_GAP_4_STP_REG
					IOC_GAP_4_STP_REG = 0
					LOCK_1_STAT_REG   = LOCK_OCCUR
					GAP__BRAKE_REG    = SERVO_RDY__ON
					GAP__BRAKE_STAT   = GAP__BRAKE_REG

P6311 = P6311 + 1		; for Debug
					CMD^A									; Abort
					KILL_TIMER_FNC							; 100msec wait
					CMD"#1J/"								; servo-lock
					KILL_TIMER_FNC							; 100msec wait
					CMD^K									; kill-all
;					KILL_TIMER_FNC							; 100msec wait comment out 20150529
					SRDY_1_OUT = SERVO_RDY_OFF				; servo-off
					KILL_TIMER_FNC							; 100msec wait

					DRIVE_MODE_REG = DRIVE_STOP

					GAP_4_STP_REG = 0

					IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617 demo machine

				ELSE
				ENDIF

				; -------
				; MOT[#2]
				; -------
				IF( IOC_GAP_5_STP_REG != 0 )
					GAP_5_STP_REG     = IOC_GAP_5_STP_REG
					IOC_GAP_5_STP_REG = 0
					LOCK_2_STAT_REG   = LOCK_OCCUR
					GAP__BRAKE_REG    = SERVO_RDY__ON
					GAP__BRAKE_STAT   = GAP__BRAKE_REG

P6312 = P6312 + 1		; for Debug
					CMD^A									; Abort
					KILL_TIMER_FNC							; 100msec wait
					CMD"#2J/"								; servo-lock
					KILL_TIMER_FNC							; 100msec wait
					CMD^K									; kill-all
;					KILL_TIMER_FNC							; 100msec wait comment out 20150529
					SRDY_2_OUT = SERVO_RDY_OFF				; servo-off
					KILL_TIMER_FNC							; 100msec wait

					DRIVE_MODE_REG = DRIVE_STOP

					GAP_5_STP_REG = 0

					IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617 demo machine

				ELSE
				ENDIF

				; -------
				; MOT[#3]
				; -------
				IF( IOC_GAP_6_STP_REG != 0 )
					GAP_6_STP_REG     = IOC_GAP_6_STP_REG
					IOC_GAP_6_STP_REG = 0
					LOCK_3_STAT_REG   = LOCK_OCCUR
					GAP__BRAKE_REG    = SERVO_RDY__ON
					GAP__BRAKE_STAT   = GAP__BRAKE_REG

P6313 = P6313 + 1		; for Debug
					CMD^A									; Abort
					KILL_TIMER_FNC							; 100msec wait
					CMD"#3J/"								; servo-lock
					KILL_TIMER_FNC							; 100msec wait
					CMD^K									; kill-all
;					KILL_TIMER_FNC							; 100msec wait comment out 20150529
					SRDY_3_OUT = SERVO_RDY_OFF				; servo-off
					KILL_TIMER_FNC							; 100msec wait

					DRIVE_MODE_REG = DRIVE_STOP

					GAP_6_STP_REG = 0

					IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617 demo machine

				ELSE
				ENDIF

				; -------
				; MOT[#4]
				; -------
				IF( IOC_GAP_7_STP_REG != 0 )
					GAP_7_STP_REG     = IOC_GAP_7_STP_REG
					IOC_GAP_7_STP_REG = 0
					LOCK_4_STAT_REG   = LOCK_OCCUR
					GAP__BRAKE_REG    = SERVO_RDY__ON
					GAP__BRAKE_STAT   = GAP__BRAKE_REG

P6314 = P6314 + 1		; for Debug
					CMD^A									; Abort
					KILL_TIMER_FNC							; 100msec wait
					CMD"#4J/"								; servo-lock
					KILL_TIMER_FNC							; 100msec wait
					CMD^K									; kill-all
;					KILL_TIMER_FNC							; 100msec wait comment out 20150529
					SRDY_4_OUT = SERVO_RDY_OFF				; servo-off
					KILL_TIMER_FNC							; 100msec wait

					DRIVE_MODE_REG = DRIVE_STOP

					GAP_7_STP_REG = 0

					IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617 demo machine

				ELSE
				ENDIF
			ELSE			; IF(!ADJ__START)
			ENDIF			; IF(!ADJ__START)

		ENDIF		; if(MNT_MODE)

	ENDIF		; if(ACTIVE_MODE_REG)


	; -------------
	; Clear Command
	; -------------
	IOC_GAP_1_DRV_REG = 0		; GAP[#1-#4]
	IOC_GAP_1_JGP_REG = 0
	IOC_GAP_1_JGM_REG = 0
	IOC_GAP_1_STP_REG = 0

	IOC_GAP_2_DRV_REG = 0		; GAP[#1-#2]
	IOC_GAP_2_JGP_REG = 0
	IOC_GAP_2_JGM_REG = 0
	IOC_GAP_2_STP_REG = 0

	IOC_GAP_3_DRV_REG = 0		; GAP[#3-#4]
	IOC_GAP_3_JGP_REG = 0
	IOC_GAP_3_JGM_REG = 0
	IOC_GAP_3_STP_REG = 0

	IOC_GAP_4_DRV_REG = 0		; MOT[#1]
	IOC_GAP_4_JGP_REG = 0
	IOC_GAP_4_JGM_REG = 0
	IOC_GAP_4_STP_REG = 0

	IOC_GAP_5_DRV_REG = 0		; MOT[#2]
	IOC_GAP_5_JGP_REG = 0
	IOC_GAP_5_JGM_REG = 0
	IOC_GAP_5_STP_REG = 0

	IOC_GAP_6_DRV_REG = 0		; MOT[#3]
	IOC_GAP_6_JGP_REG = 0
	IOC_GAP_6_JGM_REG = 0
	IOC_GAP_6_STP_REG = 0

	IOC_GAP_7_DRV_REG = 0		; MOT[#4]
	IOC_GAP_7_JGP_REG = 0
	IOC_GAP_7_JGM_REG = 0
	IOC_GAP_7_STP_REG = 0

	IOC_JCK_0_DRV_REG = 0		; JACK[#1-#4]
	IOC_JCK_0_JGP_REG = 0
	IOC_JCK_0_JGM_REG = 0
	IOC_JCK_0_STP_REG = 0


	; ----------------------------------
	; BRAKE ON/OFF(Servo OFF/ON) COMMAND
	; ----------------------------------
	; -----------------------
	; GAP BRAKE OFF(Servo ON)
	; -----------------------
	IF( GAP__BRAKE_REG = SERVO_RDY_OFF AND GAP__BRAKE_STAT != GAP__BRAKE_REG )
		IF( MOT_SRDY_1_REG = SERVO_RDY__ON )
			IF( SRDY_1_OUT = SERVO_RDY_OFF )
				SRDY_1_OUT      = SERVO_RDY__ON		; Servo ON[#1]
				CMD"#1J/#2J/#17J/#18J/"				; Servo-Lock
				CMD"#3J/#4J/#20J/#21J/"				; Servo-Lock
				LOCK_1_STAT_REG = LOCK_OCCUR
				SV_RDY_TIMER_FNC					; Wait (20msec)
			ELSE
			ENDIF
		ELSE
		ENDIF

		IF( MOT_SRDY_2_REG = SERVO_RDY__ON )
			IF( SRDY_2_OUT = SERVO_RDY_OFF )
				SRDY_2_OUT      = SERVO_RDY__ON		; Servo ON[#2]
				CMD"#1J/#2J/#17J/#18J/"				; Servo-Lock
				CMD"#3J/#4J/#20J/#21J/"				; Servo-Lock
				LOCK_2_STAT_REG = LOCK_OCCUR
				SV_RDY_TIMER_FNC					; Wait (20msec)
			ELSE
			ENDIF
		ELSE
		ENDIF

		IF( MOT_SRDY_3_REG = SERVO_RDY__ON )
			IF( SRDY_3_OUT = SERVO_RDY_OFF )
				SRDY_3_OUT      = SERVO_RDY__ON		; Servo ON[#3]
				CMD"#1J/#2J/#17J/#18J/"				; Servo-Lock
				CMD"#3J/#4J/#20J/#21J/"				; Servo-Lock
				LOCK_3_STAT_REG = LOCK_OCCUR
				SV_RDY_TIMER_FNC					; Wait (20msec)
			ELSE
			ENDIF
		ELSE
		ENDIF

		IF( MOT_SRDY_4_REG = SERVO_RDY__ON )
			IF( SRDY_4_OUT = SERVO_RDY_OFF )
				SRDY_4_OUT      = SERVO_RDY__ON		; Servo ON[#4]
				CMD"#1J/#2J/#17J/#18J/"				; Servo-Lock
				CMD"#3J/#4J/#20J/#21J/"				; Servo-Lock
				LOCK_4_STAT_REG = LOCK_OCCUR
				SV_RDY_TIMER_FNC					; Wait (20msec)
			ELSE
			ENDIF
		ELSE
		ENDIF

		; ------------------------
		; Gap motors were servo-on
		; ------------------------
		IF( SRDY_1_OUT = SERVO_RDY__ON AND SRDY_2_OUT = SERVO_RDY__ON AND SRDY_3_OUT = SERVO_RDY__ON AND SRDY_4_OUT = SERVO_RDY__ON )
			GAP__BRAKE_STAT = SERVO_RDY_OFF
			GAP__BRAKE_STAT = GAP__BRAKE_REG
		ELSE
		ENDIF

	ELSE
	ENDIF

	; -----------------------
	; GAP BRAKE ON(Servo OFF)
	; -----------------------
	IF( GAP__BRAKE_REG = SERVO_RDY__ON AND GAP__BRAKE_STAT != GAP__BRAKE_REG )

		IF( SRDY_1_OUT = SERVO_RDY__ON )
			SRDY_1_OUT      = SERVO_RDY_OFF		; Servo OFF[#1]
			LOCK_1_STAT_REG = UNLOCK_OCCUR
		ELSE
		ENDIF

		IF( SRDY_2_OUT = SERVO_RDY__ON )
			SRDY_2_OUT      = SERVO_RDY_OFF		; Servo OFF[#2]
			LOCK_2_STAT_REG = UNLOCK_OCCUR
		ELSE
		ENDIF

		IF( SRDY_3_OUT = SERVO_RDY__ON )
			SRDY_3_OUT      = SERVO_RDY_OFF		; Servo OFF[#3]
			LOCK_3_STAT_REG = UNLOCK_OCCUR
		ELSE
		ENDIF

		IF( SRDY_4_OUT = SERVO_RDY__ON )
			SRDY_4_OUT      = SERVO_RDY_OFF		; Servo OFF[#4]
			LOCK_4_STAT_REG = UNLOCK_OCCUR
		ELSE
		ENDIF

		; -------------------------
		; Gap motors were servo-off
		; -------------------------
		IF( SRDY_1_OUT = SERVO_RDY_OFF AND SRDY_2_OUT = SERVO_RDY_OFF AND SRDY_3_OUT = SERVO_RDY_OFF AND SRDY_4_OUT = SERVO_RDY_OFF )
			GAP__BRAKE_STAT = SERVO_RDY__ON
			GAP__BRAKE_STAT = GAP__BRAKE_REG
			GAP__BRK_ON_REG = GAP__BRK_ON_INI				; Add 2013/09/30
		ELSE
		ENDIF

	ELSE
	ENDIF

CLOSE


; ======================================
; ======================================
;	checking of system status
;		PLC6
; ======================================
; ======================================
OPEN PLC6 CLEAR


	; -------------------------
	; check GAP Interlock
	; -------------------------
	GAP__INTLK_VAL = GAP__INTLK_DIS

	; --------------------------------------
	;	main loop
	; --------------------------------------
	IF( INITIALIZE_REG = SYS_NORMAL )

		; --------------------------------------
		;	check MOTOR status
		; --------------------------------------
		MOT_MOV_1_FNC		; Check move status (MOTOR #1)
		IF( SRDY_1_OUT= SERVO_RDY_OFF )
			MOV_1_STAT_REG = STOP_AXIS
		ELSE
			IF( MOV_1_STAT_REG = MOVE_AXIS )
				LOCK_1_STAT_REG = UNLOCK_OCCUR
			ELSE
				IF( LOCK_1_STAT_REG != LOCK_OCCUR )
					CMD"#1J/#17J/"
					LOCK_1_STAT_REG = LOCK_OCCUR
				ELSE
				ENDIF
			ENDIF
		ENDIF

		MOT_DIR_1_FNC		; Check move direction (MOTOR #1)
;		IF( MOV_1_STAT_REG = STOP_AXIS )
;			DIR_1_STAT_REG = NO__DIR
;		ELSE
;		ENDIF


		MOT_MOV_2_FNC		; Check move status (MOTOR #2)
		IF( SRDY_2_OUT= SERVO_RDY_OFF )
			MOV_2_STAT_REG = STOP_AXIS
		ELSE
			IF( MOV_2_STAT_REG = MOVE_AXIS )
				LOCK_2_STAT_REG = UNLOCK_OCCUR
			ELSE
				IF( LOCK_2_STAT_REG != LOCK_OCCUR )
					CMD"#2J/#18J/"
					LOCK_2_STAT_REG = LOCK_OCCUR
				ELSE
				ENDIF
			ENDIF
		ENDIF

		MOT_DIR_2_FNC		; Check move direction (MOTOR #2)
;		IF( MOV_2_STAT_REG = STOP_AXIS )
;			DIR_2_STAT_REG = NO__DIR
;		ELSE
;		ENDIF


		MOT_MOV_3_FNC		; Check move status (MOTOR #3)
		IF( SRDY_3_OUT= SERVO_RDY_OFF )
			MOV_3_STAT_REG = STOP_AXIS
		ELSE
			IF( MOV_3_STAT_REG = MOVE_AXIS )
				LOCK_3_STAT_REG = UNLOCK_OCCUR
			ELSE
				IF( LOCK_3_STAT_REG != LOCK_OCCUR )
					CMD"#3J/#20J/"
					LOCK_3_STAT_REG = LOCK_OCCUR
				ELSE
				ENDIF
			ENDIF
		ENDIF

		MOT_DIR_3_FNC		; Check move direction (MOTOR #3)
;		IF( MOV_3_STAT_REG = STOP_AXIS )
;			DIR_3_STAT_REG = NO__DIR
;		ELSE
;		ENDIF


		MOT_MOV_4_FNC		; Check move status (MOTOR #4)
		IF( SRDY_4_OUT= SERVO_RDY_OFF )
			MOV_4_STAT_REG = STOP_AXIS
		ELSE
			IF( MOV_4_STAT_REG = MOVE_AXIS )
				LOCK_4_STAT_REG = UNLOCK_OCCUR
			ELSE
				IF( LOCK_4_STAT_REG != LOCK_OCCUR )
					CMD"#4J/#21J/"
					LOCK_4_STAT_REG = LOCK_OCCUR
				ELSE
				ENDIF
			ENDIF
		ENDIF

		MOT_DIR_4_FNC		; Check move direction (MOTOR #4)
;		IF( MOV_4_STAT_REG = STOP_AXIS )
;			DIR_4_STAT_REG = NO__DIR
;		ELSE
;		ENDIF


		; -----------------------------------------------------------------
		; check detected kill-limit switch in SPA-MODE(add 2014/04/02)
		; -----------------------------------------------------------------
		IF( ACTIVE_MODE_REG = SPA_MODE )
			IF( OPEN_KILL_1_REG = LIMIT_OFF )
P6450 = MOT_1_DIR_REG
				IF( SRDY_1_OUT = SERVO_RDY__ON )
					IF( MOT_1_DIR_REG = CCW_DIR )
						IOC_GAP_4_STP_REG = 1
					ELSE
					ENDIF
				ELSE
				ENDIF
				IF( SRDY_2_OUT = SERVO_RDY__ON )
					IF( MOT_2_DIR_REG = CCW_DIR )
						IOC_GAP_5_STP_REG = 1
					ELSE
					ENDIF
				ELSE
				ENDIF
			ELSE
			ENDIF

;			IF( CLOSE_KILL_1_REG = LIMIT_OFF )
			IF( CLOSE_KILL_1_REG = LIMIT_OFF OR GAP_CLOSE_KILL_REG = LIMIT_OFF )
P6450 = MOT_1_DIR_REG
				IF( SRDY_1_OUT = SERVO_RDY__ON )
					IF( MOT_1_DIR_REG = CW__DIR )
						IOC_GAP_4_STP_REG = 1
					ELSE
					ENDIF
				ELSE
				ENDIF
				IF( SRDY_2_OUT = SERVO_RDY__ON )
					IF( MOT_2_DIR_REG = CW__DIR )
						IOC_GAP_5_STP_REG = 1
					ELSE
					ENDIF
				ELSE
				ENDIF
			ELSE
			ENDIF

			IF( OPEN_KILL_2_REG = LIMIT_OFF )
				IF( SRDY_3_OUT = SERVO_RDY__ON )
					IF( MOT_3_DIR_REG = CCW_DIR )
						IOC_GAP_6_STP_REG = 1
					ELSE
					ENDIF
				ELSE
				ENDIF
				IF( SRDY_4_OUT = SERVO_RDY__ON )
					IF( MOT_4_DIR_REG = CCW_DIR )
						IOC_GAP_7_STP_REG = 1
					ELSE
					ENDIF
				ELSE
				ENDIF
			ELSE
			ENDIF

;			IF( CLOSE_KILL_2_REG = LIMIT_OFF )
			IF( CLOSE_KILL_2_REG = LIMIT_OFF OR GAP_CLOSE_KILL_REG = LIMIT_OFF )
				IF( SRDY_3_OUT = SERVO_RDY__ON )
					IF( MOT_3_DIR_REG = CW__DIR )
						IOC_GAP_6_STP_REG = 1
					ELSE
					ENDIF
				ELSE
				ENDIF
				IF( SRDY_4_OUT = SERVO_RDY__ON )
					IF( MOT_4_DIR_REG = CW__DIR )
						IOC_GAP_7_STP_REG = 1
					ELSE
					ENDIF
				ELSE
				ENDIF
			ELSE
			ENDIF
		ELSE
		ENDIF

		; ------------------------------------------------
		; check detected limit switch when driving JACK
		; ------------------------------------------------
		IF( ACTIVE_MODE_REG = USR_MODE OR ACTIVE_MODE_REG = ENG_MODE )
			IF( ADJ_MODE__REG != ADJ__START )
				IF( MOV_1_STAT_REG = MOVE_AXIS AND MOV_2_STAT_REG = MOVE_AXIS AND MOV_3_STAT_REG = MOVE_AXIS AND MOV_4_STAT_REG = MOVE_AXIS )
					TMP4_REG = 0
					TMP4_REG = 0

					; ------------
					; driving JACK
					; ------------
					IF( DRIVE_MODE_REG = JCK_DRIVE_MODE )
P6430 = P6430 + 1
						; ----
						; Down
						; ----
;						IF( DIR_1_STAT_REG = CCW_DIR )
						IF( DIR_1_STAT_REG = CW__DIR )
P6431 = P6431 + 1
P6440 = DIR_1_STAT_REG
							IF( CLOSE_1_REG = LIMIT_OFF OR CLOSE_KILL_1_REG = LIMIT_OFF )
								TMP4_REG = 1
							ELSE
							ENDIF

							IF( OPEN_2_REG = LIMIT_ON OR OPEN_KILL_2_REG = LIMIT_OFF )
								TMP4_REG = 1
							ELSE
							ENDIF
						ELSE		; if(CCW_DIR)
						ENDIF		; if(CCW_DIR)

						; --
						; Up
						; --
;						IF( DIR_1_STAT_REG = CW__DIR )
						IF( DIR_1_STAT_REG = CCW_DIR )
P6432 = P6432 + 1
P6440 = DIR_1_STAT_REG

							IF( OPEN_1_REG = LIMIT_ON OR OPEN_KILL_1_REG = LIMIT_OFF )
								TMP4_REG = 1
							ELSE
							ENDIF

							IF( CLOSE_2_REG = LIMIT_OFF OR CLOSE_KILL_2_REG = LIMIT_OFF )
								TMP4_REG = 1
							ELSE
							ENDIF
						ELSE		; if(CW__DIR)
						ENDIF		; if(CW__DIR)

						; ---------------------
						; detected limit switch
						; ---------------------
						IF( TMP4_REG != 0 )
;							IF( PRG_EXEC_REG = PRG_EXEC_JOG )
							IF( PRG_EXEC_REG > 0 )
								CMD"H"						; JOG
								HOLD_TIMER_FNC				; 300msec wait

								HLD_COUNT_REG = 1
								WHILE( HLD_COUNT_REG < 40 )
;									IF( MOV_1_STAT_REG = MOVE_AXIS )
									IF( MOV_1_STAT_REG = MOVE_AXIS OR MOV_2_STAT_REG = MOVE_AXIS OR MOV_3_STAT_REG = MOVE_AXIS OR MOV_4_STAT_REG = MOVE_AXIS )
										HLD_COUNT_REG = HLD_COUNT_REG + 1
									ELSE
										HLD_COUNT_REG = 50
									ENDIF

									SV_RDY_TIMER_FNC
								ENDWHILE
							ELSE
							ENDIF

							CMD^A							; Abort
							KILL_TIMER_FNC					; 100msec wait

							CMD"#1J/#2J/#17J/#18J/"			; #1,#2(GAP UPPER) Servo Lock(stop)
							CMD"#3J/#4J/#20J/#21J/"			; #3,#4(GAP LOWER) Servo Lock(stop)

							KILL_TIMER_FNC					; 100msec wait
							CMD^K							; kill-all
							KILL_TIMER_FNC					; 100msec wait

							DRIVE_MODE_REG = DRIVE_STOP		; Drive mode is Jack-up mode
						ELSE		; if(detected LS)
						ENDIF		; if(detected LS)
					ELSE		; if(JCK_DRIVE_MODE)
					ENDIF		; if(JCK_DRIVE_MODE)
				ELSE		; if(MOVE_AXIS)
				ENDIF		; if(MOVE_AXIS)
			ELSE		; if(! ADJ__START)
			ENDIF		; if(! ADJ__START)
		ELSE		; if(USR_MODE | ENG_MODE)
		ENDIF		; if(USR_MODE | ENG_MODE)

		; -----------------------
		; check software limit
		; -----------------------
;		IF( ACTIVE_MODE_REG = USR_MODE OR ACTIVE_MODE_REG = ENG_MODE )
;			IF( ADJ_MODE__REG != ADJ__START )
;				IF( MOV_1_STAT_REG = MOVE_AXIS AND MOV_2_STAT_REG = MOVE_AXIS AND MOV_3_STAT_REG = MOVE_AXIS AND MOV_4_STAT_REG = MOVE_AXIS )
;
;					TMP3_REG = 0
;					TMP3_REG = 0
;
;					; -----------
;					; driving GAP
;					; -----------
;					IF( DRIVE_MODE_REG = GAP_DRIVE_MODE )
;
;						TMP1_REG = GAP_SOFTLIM_UP_REG - 1000
;						TMP2_REG = GAP_SOFTLIM_DN_REG + 1000
;
;						; --------------------
;						; checking upper-limit
;						; --------------------
;						IF( GAP_SOFTLIM_UP_REG != 0 )
;							IF( TMP1_REG < M162 OR TMP1_REG < M262 OR TMP1_REG < M362 OR TMP1_REG < M462 )
;								TMP3_REG = 1
;							ELSE
;							ENDIF
;						ELSE
;						ENDIF
;
;						; --------------------
;						; checking lower-limit
;						; --------------------
;						IF( GAP_SOFTLIM_DN_REG != 0 )
;							IF( TMP2_REG > M162 OR TMP2_REG > M262 OR TMP2_REG > M362 OR TMP2_REG > M462 )
;								TMP3_REG = 1
;							ELSE
;							ENDIF
;						ELSE
;						ENDIF
;					ELSE		; if(GAP_DRIVE_MODE)
;					ENDIF		; if(GAP_DRIVE_MODE)
;
;					; ------------
;					; driving JACK
;					; ------------
;					IF( DRIVE_MODE_REG = JCK_DRIVE_MODE )
;						TMP1_REG = JCK_SOFTLIM_UP_REG - 1000
;						TMP2_REG = JCK_SOFTLIM_DN_REG + 1000
;
;						; --------------------
;						; checking upper-limit
;						; --------------------
;						IF( JCK_SOFTLIM_UP_REG != 0 )
;							IF( TMP1_REG < M162 OR TMP1_REG < M262 OR TMP1_REG < M362 OR TMP1_REG < M462 )
;								TMP3_REG = 1
;							ELSE
;							ENDIF
;						ELSE
;						ENDIF
;
;						; --------------------
;						; checking lower-limit
;						; --------------------
;						IF( JCK_SOFTLIM_UP_REG != 0 )
;							IF( TMP2_REG > M162 OR TMP2_REG > M262 OR TMP2_REG > M362 OR TMP2_REG > M462 )
;								TMP3_REG = 1
;							ELSE
;							ENDIF
;						ELSE
;						ENDIF
;					ELSE		; if(JCK_DRIVE_MODE)
;					ENDIF		; if(JCK_DRIVE_MODE)
;
;
;					; ----------
;					; over limit
;					; ----------
;					IF( TMP3_REG != 0 )
;						IF( PRG_EXEC_REG = PRG_EXEC_JOG )
;							CMD"H"						; JOG
;							HOLD_TIMER_FNC				; 300msec wait
;
;							HLD_COUNT_REG = 1
;							WHILE( HLD_COUNT_REG < 30 )
;								IF( MOV_1_STAT_REG = MOVE_AXIS )
;									HLD_COUNT_REG = HLD_COUNT_REG + 1
;								ELSE
;									HLD_COUNT_REG = 40
;								ENDIF
;
;								SV_RDY_TIMER_FNC
;							ENDWHILE
;						ELSE
;						ENDIF
;
;						CMD^A							; Abort
;						KILL_TIMER_FNC					; 100msec wait
;
;						CMD"#1J/#2J/#17J/#18J/"			; #1,#2(GAP UPPER) Servo Lock(stop)
;						CMD"#3J/#4J/#20J/#21J/"			; #3,#4(GAP LOWER) Servo Lock(stop)
;
;						KILL_TIMER_FNC					; 100msec wait
;						CMD^K
;						KILL_TIMER_FNC					; 100msec wait
;					ELSE		; if(OVER LIMIT)
;					ENDIF		; if(OVER LIMIT)
;
;				ELSE		; if(MOVE_AXIS)
;				ENDIF		; if(MOVE_AXIS)
;			ELSE		; if(! ADJ__START)
;			ENDIF		; if(! ADJ__START)
;		ELSE		; if(USR_MODE | ENG_MODE)
;		ENDIF		; if(USR_MODE | ENG_MODE)


		; -----------------------
		; check if GAP stopped
		; (not separate mode)
		; (not adjusting mode)
		; -----------------------
;		IF( ACTIVE_MODE_REG != SPA_MODE )
		IF( ACTIVE_MODE_REG != SPA_MODE AND ADJ_MODE__REG != ADJ__START )
			IF( BEACON_REG = BEACON_OFF )
				IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
					IF( SRDY_1_OUT = SERVO_RDY__ON AND SRDY_2_OUT = SERVO_RDY__ON AND SRDY_3_OUT = SERVO_RDY__ON AND SRDY_4_OUT = SERVO_RDY__ON )
						GAP__BRK_ON_REG = GAP__BRK_ON_REG + 1

						IF (PROG_STAT_REG = PROG_STP_STAT)
							IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617
						ENDIF

						IF( GAP__BRK_ON_REG > SRV_LOCK_TIM_MIN )
							IF( GAP__BRK_ON_REG < SRV_LOCK_TIM_MAX )
								CMD"#1J/#2J/#17J/#18J/"
								CMD"#3J/#4J/#20J/#21J/"

								LOCK_1_STAT_REG = LOCK_OCCUR
								LOCK_2_STAT_REG = LOCK_OCCUR
								LOCK_3_STAT_REG = LOCK_OCCUR
								LOCK_4_STAT_REG = LOCK_OCCUR
							ELSE
							ENDIF
						ELSE
						ENDIF

						; ------------------------------------
						; Start adjusting mode(Add 2013/11/13)
						; ------------------------------------
						IF( ACTIVE_MODE_REG < MNT_MODE )
;						IF( ACTIVE_MODE_REG < MNT_MODE AND ADJ_MODE__REG != ADJ__START )
							IF( SRV_LOCK_ADJ_MIN < GAP__BRK_ON_REG AND GAP__BRK_ON_REG < SRV_LOCK_ADJ_MAX )
;								IF( PRG_EXEC_REG > 0 )
								IF( PRG_EXEC_REG = PRG_EXEC_POS )						; Is it Synchronous move?
									IF( ADJ_MODE__REG != ADJ__START )
										IF( PRG_GAP__INTLK = 0 )						; Ignore during GAP evacuation
											IF( DRIVE_MODE_REG != HME_DRIVE_MODE )		; Ignore during HOME evacuation
;												; -------------------------------
;												; not detected LS(Del:2014/09/15)
;												; -------------------------------
;												IF( OPEN_KILL_REG = LIMIT_ON AND CLOSE_KILL_REG = LIMIT_ON AND OPEN_REG = LIMIT_ON AND CLOSE_REG = LIMIT_ON )
;													IF( GAP_CLOSE_KILL_REG = LIMIT_ON AND GAP_CLOSE_REG = LIMIT_ON )
;														ADJ_MODE__REG = ADJ__START		; start Adjusting mode
;													ELSE
;													ENDIF
;												ELSE
;												ENDIF

; --------------
; Rev:2014/11/25
;												ADJ_MODE__REG = ADJ__START				; start Adjusting mode
;												PRG_EXEC_REG  = 0
												IF( COMP_SCAN_REG = COMP_SCAN_DISABLE )
P6940 = P6940 + 1		; for Debug
;													ADJ_MODE__REG = ADJ__START			; start Adjusting mode
													IF( PRG_EXEC_REG > 0 )
;														ADJ_MODE__REG = ADJ__START			; start Adjusting mode
														IF( ADJ_MODE__REG = ADJ_FINISH AND GAP_1_STP_REG = 0 AND JCK_0_STP_REG = 0 )
															TMP5_REG = ABS(( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) + ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_1_OFFSET_REG - MOT_1_POS_REG ))
															TMP6_REG = ABS(( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) + ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_2_OFFSET_REG - MOT_2_POS_REG ))
															TMP7_REG = ABS(( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) - ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_3_OFFSET_REG - MOT_3_POS_REG ))
															TMP8_REG = ABS(( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) - ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_4_OFFSET_REG - MOT_4_POS_REG ))
															IF (ADJ_RANGE_MIN < TMP5_REG OR ADJ_RANGE_MIN < TMP6_REG OR ADJ_RANGE_MIN < TMP7_REG OR ADJ_RANGE_MIN < TMP8_REG)
																ADJ_MODE__REG = ADJ__START			; start Adjusting mode
																IOC_RCV_RDY_REG = RCV_NREADY_VAL	; not ready 20150617
															ENDIF
														ELSE
															ADJ_MODE__REG = ADJ_FINISH			; finish Adjusting mode
														ENDIF
													ELSE
														ADJ_MODE__REG = ADJ_FINISH			; finish Adjusting mode
													ENDIF
													PRG_EXEC_REG  = 0
												ELSE
P6941 = P6941 + 1		; for Debug
													ADJ_MODE__REG = ADJ_FINISH			; finish Adjusting mode
													PRG_EXEC_REG  = 0

													IOC_RCV_RDY_REG = RCV__READY_VAL		; ready 20150617

												ENDIF
; Rev:2014/11/25
; --------------
P6506 = PRG1_FLW_ERR	; for Debug
P6505 = P6505 + 1		; for Debug

											ELSE
											ENDIF
										ELSE
										ENDIF
									ELSE
									ENDIF
								ELSE
								ENDIF
							ELSE
							ENDIF
						ELSE
						ENDIF

;						IF( GAP__BRK_ON_REG > GAP__BRK_ON_MAX )
						IF( GAP__BRK_ON_REG > GAP__BRK_ON_MAX AND ADJ_MODE__REG != ADJ__START )
P6740 = P6740 + 1		; for Debug

							IF( HOME_ADJ_PRG_REG = HOME_EXEC_0 )	; 2014/05/01: Separate move of HOME evacuation stopped.
								CMD^K

								SRDY_1_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
								SRDY_2_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
								SRDY_3_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
								SRDY_4_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)

								LOCK_1_STAT_REG = UNLOCK_OCCUR
								LOCK_2_STAT_REG = UNLOCK_OCCUR
								LOCK_3_STAT_REG = UNLOCK_OCCUR
								LOCK_4_STAT_REG = UNLOCK_OCCUR

								GAP__BRK_ON_REG = GAP__BRK_ON_INI	; clear count
								GAP__BRAKE_REG  = SERVO_RDY__ON
								GAP__BRAKE_STAT = GAP__BRAKE_REG
								DRIVE_MODE_REG  = DRIVE_STOP		; Add 2014/04/30

								CMD^K								; kill-all

;								PRG_EXEC_REG    = 0

; ---------
; for Debug
IF( COMP_FLAG_REG = COMP_SCAN_ENABLE )
	P6930 = P6930 + 1		; for Debug
ELSE
ENDIF
; for Debug
; ---------

; --------------
; Add:2014/11/20
								COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
								COMP_01_VAL_REG = 0
								COMP_17_VAL_REG = 0
								COMP_03_VAL_REG = 0
								COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------

								IF( PRG_GAP__INTLK = 1 )
									PRG_GAP__INTLK = 0
									PRG_GAP__START = 0

									MOTOR_1_JOG  = GAP__INTLK_SPD
									MOTOR_2_JOG  = GAP__INTLK_SPD
									MOTOR_3_JOG  = GAP__INTLK_SPD
									MOTOR_4_JOG  = GAP__INTLK_SPD
									MOTOR_17_JOG = GAP__INTLK_SPD
									MOTOR_18_JOG = GAP__INTLK_SPD
									MOTOR_20_JOG = GAP__INTLK_SPD
									MOTOR_21_JOG = GAP__INTLK_SPD

									MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
									MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
									MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
									MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
									MOTOR_17_JOG_JOG = GAP__INTLK_SPD
									MOTOR_18_JOG_JOG = GAP__INTLK_SPD
									MOTOR_20_JOG_JOG = GAP__INTLK_SPD
									MOTOR_21_JOG_JOG = GAP__INTLK_SPD
								ELSE
								ENDIF

								; ============================
								; Rev 2013/10/15(for BNL 2.8m)
								I0124 = MOTOR_FLAG_VAL
								I0224 = MOTOR_FLAG_VAL
								I0324 = MOTOR_FLAG_VAL
								I0424 = MOTOR_FLAG_VAL
								I1724 = MOTOR_FLAG_VAL
								I1824 = MOTOR_FLAG_VAL
								I2024 = MOTOR_FLAG_VAL
								I2124 = MOTOR_FLAG_VAL
								; Rev 2013/10/15(for BNL 2.8m)
								; ============================

								PRG_EXEC_REG    = 0

							ELSE		; if(HOME_ADJ_PRG_REG)	; 2014/05/01: unchecked function
							ENDIF		; if(HOME_ADJ_PRG_REG)	; 2014/05/01: unchecked function

; ---------
; for Debug
IF( COMP_FLAG_REG = COMP_SCAN_ENABLE )
	P6931 = P6931 + 1		; for Debug
ELSE
ENDIF
; for Debug
; ---------

							IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617

						ELSE		; if(GAP__BRK_ON_MAX)
						ENDIF		; if(GAP__BRK_ON_MAX)
					ELSE		; if(SERVO_RDY__ON)
					ENDIF		; if(SERVO_RDY__ON)
				ELSE
				ENDIF
			ELSE
			ENDIF

		; -------------
		; separate mode
		; -------------
		ELSE			; if(!SPA_MODE & !ADJ__START)

			IF( BEACON_REG = BEACON_OFF )

				IF( ACTIVE_MODE_REG = SPA_MODE )
					IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND SRDY_1_OUT = SERVO_RDY__ON )
						GAP__BRK_ON_REG = GAP__BRK_ON_REG + 1
					ELSE
						IF( MOT_SRDY_2_REG = SERVO_RDY__ON AND SRDY_2_OUT = SERVO_RDY__ON )
							GAP__BRK_ON_REG = GAP__BRK_ON_REG + 1
						ELSE
							IF( MOT_SRDY_3_REG = SERVO_RDY__ON AND SRDY_3_OUT = SERVO_RDY__ON )
								GAP__BRK_ON_REG = GAP__BRK_ON_REG + 1
							ELSE
								IF( MOT_SRDY_4_REG = SERVO_RDY__ON AND SRDY_4_OUT = SERVO_RDY__ON )
									GAP__BRK_ON_REG = GAP__BRK_ON_REG + 1
								ELSE
								ENDIF
							ENDIF
						ENDIF
					ENDIF
				ELSE
				ENDIF

				IF( ADJ_MODE__REG = ADJ__START )
					IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
						IF( SRDY_1_OUT = SERVO_RDY__ON AND SRDY_2_OUT = SERVO_RDY__ON AND SRDY_3_OUT = SERVO_RDY__ON AND SRDY_4_OUT = SERVO_RDY__ON )
P6507 = P6507 + 1		; for Debug

; Del:2014/11/27
;							GAP__BRK_ON_REG = GAP__BRK_ON_REG + 1
; Del:2014/11/27
						ELSE
						ENDIF
					ELSE
					ENDIF
				ELSE
				ENDIF

				IF( SRV_LOCK_TIM_MIN < GAP__BRK_ON_REG AND GAP__BRK_ON_REG < SRV_LOCK_TIM_MAX )
P6508 = P6508 + 1		; for Debug

					IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND SRDY_1_OUT = SERVO_RDY__ON )
						CMD"#1J/"
						LOCK_1_STAT_REG = LOCK_OCCUR
					ELSE
					ENDIF
					IF( MOT_SRDY_2_REG = SERVO_RDY__ON AND SRDY_2_OUT = SERVO_RDY__ON )
						CMD"#2J/"
						LOCK_2_STAT_REG = LOCK_OCCUR
					ELSE
					ENDIF
					IF( MOT_SRDY_3_REG = SERVO_RDY__ON AND SRDY_3_OUT = SERVO_RDY__ON )
						CMD"#3J/"
						LOCK_3_STAT_REG = LOCK_OCCUR
					ELSE
					ENDIF
					IF( MOT_SRDY_4_REG = SERVO_RDY__ON AND SRDY_4_OUT = SERVO_RDY__ON )
						CMD"#4J/"
						LOCK_4_STAT_REG = LOCK_OCCUR
					ELSE
					ENDIF

				ELSE
				ENDIF

				IF( GAP__BRK_ON_REG > GAP__BRK_ON_MAX )
					GAP__BRK_ON_REG = GAP__BRK_ON_INI		; clear count
P6509 = P6509 + 1		; for Debug

					CMD^K

					; -------
					; MOT[#1]
					; -------
					IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND SRDY_1_OUT = SERVO_RDY__ON )
						SRDY_1_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
						LOCK_1_STAT_REG = UNLOCK_OCCUR
					ELSE
					ENDIF
					; -------
					; MOT[#2]
					; -------
					IF( MOT_SRDY_2_REG = SERVO_RDY__ON AND SRDY_2_OUT = SERVO_RDY__ON )
						SRDY_2_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
						LOCK_2_STAT_REG = UNLOCK_OCCUR
					ELSE
					ENDIF
					; -------
					; MOT[#3]
					; -------
					IF( MOT_SRDY_3_REG = SERVO_RDY__ON AND SRDY_3_OUT = SERVO_RDY__ON )
						SRDY_3_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
						LOCK_3_STAT_REG = UNLOCK_OCCUR
					ELSE
					ENDIF
					; -------
					; MOT[#4]
					; -------
					IF( MOT_SRDY_4_REG = SERVO_RDY__ON AND SRDY_4_OUT = SERVO_RDY__ON )
						SRDY_4_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
						LOCK_4_STAT_REG = UNLOCK_OCCUR
					ELSE
					ENDIF

					GAP__BRAKE_REG  = SERVO_RDY__ON
					GAP__BRAKE_STAT = GAP__BRAKE_REG
					DRIVE_MODE_REG  = DRIVE_STOP		; Add 2014/04/30

;					CMD^K

; ---------
; for Debug
IF( COMP_FLAG_REG = COMP_SCAN_ENABLE )
	P6932 = P6932 + 1		; for Debug
ELSE
ENDIF
; for Debug
; ---------

				ELSE
				ENDIF
			ELSE
			ENDIF
		ENDIF			; if(!SPA_MODE & !ADJ__START)


		; -----------------------------------------
		; check GAP Interlock(Add 2013/09/30)
		; Rev 2013/10/30(not separate mode)
		; Rev 2013/11/13(not adjusting mode)
		; -----------------------------------------
;		IF( ACTIVE_MODE_REG != SPA_MODE )
		IF( ACTIVE_MODE_REG != SPA_MODE AND ADJ_MODE__REG = ADJ_FINISH AND ADJ_PREMD_REG = ADJ_FINISH )
			IF( GAP__INTLK_REG = GAP__INTLK_ENA )

				IF( GAP__INTLK_SIG = GAP__LOCK__SIG )
					GAP__INTLK_VAL = GAP__INTLK_ENA
				ELSE
				ENDIF

			ELSE
			ENDIF
		ELSE			; if(!SPA_MODE & ADJ_FINISH)
		ENDIF			; if(!SPA_MODE & ADJ_FINISH)


		; -----------------------------------
		; GAP was interlocked(Add 2013/09/30)
		; -----------------------------------
;		IF( PRG_GAP__START = 1 AND PRG_GAP__INTLK = 0 )
		IF( PRG_GAP__START = 1 )
;			IF( PRG_GAP__INTLK = 0 )

				; ----
				; open
				; ----
;				PRG_GAP__START = 0
				GAP__INTLK_SPD = MOTOR_1_JOG

				MOTOR_1_JOG  = SPD_MAX
				MOTOR_2_JOG  = SPD_MAX
				MOTOR_3_JOG  = SPD_MAX
				MOTOR_4_JOG  = SPD_MAX
				MOTOR_17_JOG = SPD_MAX
				MOTOR_18_JOG = SPD_MAX
				MOTOR_20_JOG = SPD_MAX
				MOTOR_21_JOG = SPD_MAX

				MOTOR_1_JOG_JOG  = SPD_MAX
				MOTOR_2_JOG_JOG  = SPD_MAX
				MOTOR_3_JOG_JOG  = SPD_MAX
				MOTOR_4_JOG_JOG  = SPD_MAX
				MOTOR_17_JOG_JOG = SPD_MAX
				MOTOR_18_JOG_JOG = SPD_MAX
				MOTOR_20_JOG_JOG = SPD_MAX
				MOTOR_21_JOG_JOG = SPD_MAX

				SV_RDY_TIMER_FNC				; Wait (20msec)

; --------------
; Add:2014/09/27
IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
				P330 = 1						; Add 2013/10/14
				CMD"&1B20R"						; Execute a motion program (&1)

				PRG_GAP__START = 0
ELSE
ENDIF
; Add:2014/09/27
; --------------

;			ELSE
;			ENDIF
		ELSE
		ENDIF


		; ---------------------------------------------
		; turns Servo-on from Servo-off(Add 2013/09/30)
		; ---------------------------------------------
		IF( PRG_GAP__START = -1 )
			IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )

				TMP9_REG = 0
				TMP9_REG = 0

				; -------
				; MOT[#1]
				; -------
				IF( SRDY_1_OUT = SERVO_RDY_OFF )
					TMP9_REG   = 1
					SRDY_1_OUT = SERVO_RDY__ON
;					SV_RDY_TIMER_FNC				; Wait (20msec) comment out 20150529
					CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
					CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock
				ELSE
				ENDIF
				; -------
				; MOT[#2]
				; -------
				IF( SRDY_2_OUT = SERVO_RDY_OFF )
					TMP9_REG   = 1
					SRDY_2_OUT = SERVO_RDY__ON
;					SV_RDY_TIMER_FNC				; Wait (20msec) comment out 20150529
					CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
					CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock
				ELSE
				ENDIF
				; -------
				; MOT[#3]
				; -------
				IF( SRDY_3_OUT = SERVO_RDY_OFF )
					TMP9_REG   = 1
					SRDY_3_OUT = SERVO_RDY__ON
;					SV_RDY_TIMER_FNC				; Wait (20msec) comment out 20150529
					CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
					CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock
				ELSE
				ENDIF
				; -------
				; MOT[#4]
				; -------
				IF( SRDY_4_OUT = SERVO_RDY_OFF )
					TMP9_REG   = 1
					SRDY_4_OUT = SERVO_RDY__ON
;					SV_RDY_TIMER_FNC				; Wait (20msec) comment out 20150529
					CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
					CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock
				ELSE
				ENDIF

				IF( TMP9_REG = 1 )
					SV_RDY_TIMER_FNC				; Wait (20msec)

					CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
					CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock

					GAP__BRAKE_REG  = SERVO_RDY_OFF
					GAP__BRAKE_STAT = GAP__BRAKE_REG
					LOCK_1_STAT_REG = LOCK_OCCUR
					LOCK_2_STAT_REG = LOCK_OCCUR
					LOCK_3_STAT_REG = LOCK_OCCUR
					LOCK_4_STAT_REG = LOCK_OCCUR

					BRK_OFF_TIMER_FNC				; Wait (100msec)
				ELSE
					SV_RDY_TIMER_FNC				; Wait (20msec)

					CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
					CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock

				ENDIF

			ELSE									; Add 2013/09/30
			ENDIF									; Add 2013/09/30

			PRG_GAP__START = 1

		ELSE
		ENDIF


		; -------------------------------------
		; Occurred GAP Interlock(Add 2013/10/11)
		; Rev 2013/10/30(not separate mode)
		; -------------------------------------
;		IF( ACTIVE_MODE_REG != SPA_MODE )
		IF( ACTIVE_MODE_REG != SPA_MODE AND ADJ_MODE__REG = ADJ_FINISH AND ADJ_PREMD_REG = ADJ_FINISH )
;			IF( GAP__INTLK_STS != GAP__INTLK_VAL AND GAP__INTLK_VAL = GAP__INTLK_ENA )
			IF( GAP__INTLK_STS != GAP__INTLK_VAL )
			IF( GAP__INTLK_VAL = GAP__INTLK_ENA )
;;				IF( PRG_GAP__INTLK = 0 )
				IF( DRIVE_MODE_REG != HME_DRIVE_MODE )		; Add:2014/05/01

					IOC_RCV_RDY_REG = RCV_NREADY_VAL		; not ready 20150617

					IF( BEACON_REG = BEACON_ON )

						; ------------------------
						; moving axes were stopped
						; ------------------------
						LOCK_1_STAT_REG = LOCK_OCCUR
						LOCK_2_STAT_REG = LOCK_OCCUR
						LOCK_3_STAT_REG = LOCK_OCCUR
						LOCK_4_STAT_REG = LOCK_OCCUR

						; ----------------
						; Drive & JOG mode
						; ----------------
						IF( PRG_EXEC_REG > 0 )
							CMD"H"					; JOG
							HOLD_TIMER_FNC			; 300msec wait

							HLD_COUNT_REG = 1
							WHILE( HLD_COUNT_REG < 40 )
;								IF( MOV_1_STAT_REG = MOVE_AXIS )
								IF( MOV_1_STAT_REG = MOVE_AXIS OR MOV_2_STAT_REG = MOVE_AXIS OR MOV_3_STAT_REG = MOVE_AXIS OR MOV_4_STAT_REG = MOVE_AXIS )
									HLD_COUNT_REG = HLD_COUNT_REG + 1
								ELSE
									HLD_COUNT_REG = 50
								ENDIF

								SV_RDY_TIMER_FNC	; 20msec wait
;								HOLD_TIMER_FNC		; 300msec wait
							ENDWHILE
						ELSE
						ENDIF

						CMD^A						; Abort
						HOLD_TIMER_FNC				; 300msec wait

						CMD"#1J/#2J/#17J/#18J/"		; #1,#2(GAP UPPER) Servo Lock(stop)
						CMD"#3J/#4J/#20J/#21J/"		; #3,#4(GAP LOWER) Servo Lock(stop)

						KILL_TIMER_FNC				; 100msec wait

						SRDY_1_OUT = SERVO_RDY_OFF				; Servo OFF[#1]
						SRDY_2_OUT = SERVO_RDY_OFF				; Servo OFF[#2]
						SRDY_3_OUT = SERVO_RDY_OFF				; Servo OFF[#3]
						SRDY_4_OUT = SERVO_RDY_OFF				; Servo OFF[#4]

						GAP__BRAKE_STAT = SERVO_RDY__ON
						GAP__BRAKE_REG  = SERVO_RDY__ON
						GAP__BRK_ON_REG = GAP__BRK_ON_INI		; Add 2013/12/11

						KILL_TIMER_FNC				; 100msec wait

						CMD^K						; Kill

						HLD_COUNT_REG = 1
						WHILE( HLD_COUNT_REG < 30 )
							IF( MOT_OPN_1_REG != OPEN__MODE )
								HLD_COUNT_REG = HLD_COUNT_REG + 1
							ELSE
								HLD_COUNT_REG = 40
							ENDIF

;							SV_RDY_TIMER_FNC		; 20msec wait
							HOLD_TIMER_FNC			; 300msec wait
						ENDWHILE

					ELSE

					ENDIF
P6890 = P6890 + 1		; for Debug
					PRG_GAP__START = -1
; --------------
; Add:2014/11/20
					COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
					COMP_01_VAL_REG = 0
					COMP_17_VAL_REG = 0
					COMP_03_VAL_REG = 0
					COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------

				ELSE		; if(HME_DRIVE_MODE)			; Add:2014/05/01
				ENDIF		; if(HME_DRIVE_MODE)			; Add:2014/05/01
;;				ELSE		; if(GAP__INTLK_ENA)
;;				ENDIF		; if(GAP__INTLK_ENA)
			ELSE		; if(GAP_INTERLOCK)
			ENDIF		; if(GAP_INTERLOCK)
			ELSE		; if(GAP_INTERLOCK)
			ENDIF		; if(GAP_INTERLOCK)
		ELSE		; if(!SPA_MODE)
		ENDIF		; if(!SPA_MODE)


		; -----------------------------
		; user mode or engineering mode
		; Add not adjusting mode
		; -----------------------------
;		IF( ACTIVE_MODE_REG != MNT_MODE )
		IF( ACTIVE_MODE_REG = USR_MODE OR ACTIVE_MODE_REG = ENG_MODE )

			IF( ADJ_MODE__REG != ADJ__START )
				; --------------------------------------
				;	AXIS drive
				; --------------------------------------
				; --------------------------------------
				;	GAP(#1,#2,#3,#4)
				; --------------------------------------
				IF( MOV_1_STAT_REG = MOVE_AXIS AND MOV_2_STAT_REG = MOVE_AXIS AND MOV_3_STAT_REG = MOVE_AXIS AND MOV_4_STAT_REG = MOVE_AXIS )

				ELSE
					IF( MOV_1_STAT_REG != STOP_AXIS OR MOV_2_STAT_REG != STOP_AXIS OR MOV_3_STAT_REG != STOP_AXIS OR MOV_4_STAT_REG != STOP_AXIS )

						SYS_INTLCK_REG = SYS_INTLCK				; Interlock (Consistency fault [some axis is moving])

						IF( MOV_1_STAT_REG != STOP_AXIS )
							MOT_1_INT_REG = SYS_INTLCK
						ELSE
						ENDIF
						IF( MOV_2_STAT_REG != STOP_AXIS )
							MOT_2_INT_REG = SYS_INTLCK
						ELSE
						ENDIF
						IF( MOV_3_STAT_REG != STOP_AXIS )
							MOT_3_INT_REG = SYS_INTLCK
						ELSE
						ENDIF
						IF( MOV_4_STAT_REG != STOP_AXIS )
							MOT_4_INT_REG = SYS_INTLCK
						ELSE
						ENDIF

					ELSE
						SYS_INTLCK_REG = SYS_NORMAL				; Release interlock
						MOT_1_INT_REG  = SYS_NORMAL
						MOT_2_INT_REG  = SYS_NORMAL
						MOT_3_INT_REG  = SYS_NORMAL
						MOT_4_INT_REG  = SYS_NORMAL
					ENDIF
				ENDIF
			ELSE
			ENDIF

		; ----------------
		; maintenance mode
		; ----------------
		ELSE		; if(ACTIVE_MODE_REG)

		ENDIF		; if(ACTIVE_MODE_REG)


		; --------------------------------------
		;	output BEACON
		; --------------------------------------
		; --------------------------------------
		;	GAP(#1,#2,#3,#4)
		; Rev 2013/10/31(not separate mode)
		; Add 2013/11/13(not adjusting mode)
		; --------------------------------------
;		IF( ACTIVE_MODE_REG != SPA_MODE )
		IF( ACTIVE_MODE_REG != SPA_MODE AND ADJ_MODE__REG != ADJ__START )
			IF( MOV_1_STAT_REG = MOVE_AXIS AND SRDY_1_OUT = SERVO_RDY__ON )
				IF( MOV_2_STAT_REG = MOVE_AXIS AND SRDY_2_OUT = SERVO_RDY__ON )
					IF( MOV_3_STAT_REG = MOVE_AXIS AND SRDY_3_OUT = SERVO_RDY__ON )
						IF( MOV_4_STAT_REG = MOVE_AXIS AND SRDY_4_OUT = SERVO_RDY__ON )
;							IF( INITIALIZE_REG = SYS_NORMAL AND AMP_FLT_1_REG = AMP_NORMAL )
							IF( INITIALIZE_REG = SYS_NORMAL AND PRG1_FLT_ERR = AMP_NORMAL )
								IF( PROG_STAT_REG = PROG_RUN_STAT )
									BEACON_REG = BEACON_ON				; Start beacon output
								ELSE
									BEACON_REG = BEACON_OFF				; Stop beacon output
								ENDIF
							ELSE				; if(SYS_NORMAL)
								BEACON_REG = BEACON_OFF					; Stop beacon output
							ENDIF				; if(SYS_NORMAL)
						ELSE					; if(MOVE_STAT[#4])
							BEACON_REG = BEACON_OFF						; Stop beacon output
						ENDIF					; if(MOVE_STAT[#4])
					ELSE						; if(MOVE_STAT[#3])
						BEACON_REG = BEACON_OFF							; Stop beacon output
					ENDIF						; if(MOVE_STAT[#3])
				ELSE							; if(MOVE_STAT[#2])
					BEACON_REG = BEACON_OFF								; Stop beacon output
				ENDIF							; if(MOVE_STAT[#2])
			ELSE								; if(MOVE_STAT[#1])
				BEACON_REG = BEACON_OFF									; Stop beacon output (comment-out)
			ENDIF								; if(MOVE_STAT[#1])

			IF( HOME_ADJ_PRG_REG = 1 )			; HOMEëﬁî(å¬ï é≤ãÏìÆíÜ) Add:2014/05/28
				BEACON_REG = BEACON_ON								; Start beacon output
			ELSE
			ENDIF

		; -----------------------------
		; Add 2013/10/31(separate mode)
		; Add 2013/11/13(adjusting mode)
		; -----------------------------
		ELSE		; if(!SPA_MODE & !ADJ__START)
			TMP9_REG = 0
			TMP9_REG = 0

;;			IF( PROG_STAT_REG = PROG_RUN_STAT )
				; -------
				; MOT[#1]
				; -------
;				IF( MOV_1_STAT_REG = MOVE_AXIS AND SRDY_1_OUT = SERVO_RDY__ON )
				IF( MOV_1_STAT_REG = MOVE_AXIS AND SRDY_1_OUT = SERVO_RDY__ON AND MOV_1_STAT_REG = MOVE_AXIS )
					TMP9_REG = 1
				ELSE
				ENDIF
				; -------
				; MOT[#2]
				; -------
;				IF( MOV_2_STAT_REG = MOVE_AXIS AND SRDY_2_OUT = SERVO_RDY__ON )
				IF( MOV_2_STAT_REG = MOVE_AXIS AND SRDY_2_OUT = SERVO_RDY__ON AND MOV_2_STAT_REG = MOVE_AXIS )
					TMP9_REG = 1
				ELSE
				ENDIF
				; -------
				; MOT[#3]
				; -------
;				IF( MOV_3_STAT_REG = MOVE_AXIS AND SRDY_3_OUT = SERVO_RDY__ON )
				IF( MOV_3_STAT_REG = MOVE_AXIS AND SRDY_3_OUT = SERVO_RDY__ON AND MOV_3_STAT_REG = MOVE_AXIS )
					TMP9_REG = 1
				ELSE
				ENDIF
				; -------
				; MOT[#4]
				; -------
;				IF( MOV_4_STAT_REG = MOVE_AXIS AND SRDY_4_OUT = SERVO_RDY__ON )
				IF( MOV_4_STAT_REG = MOVE_AXIS AND SRDY_4_OUT = SERVO_RDY__ON AND MOV_4_STAT_REG = MOVE_AXIS )
					TMP9_REG = 1
				ELSE
				ENDIF

				IF( TMP9_REG = 1 )
					BEACON_REG = BEACON_ON				; Start beacon output
				ELSE
					BEACON_REG = BEACON_OFF				; Stop beacon output
				ENDIF
;;			ELSE
;;			ENDIF

		ENDIF		; if(!SPA_MODE & !ADJ__START))

	ELSE			; if(SYS_NORMAL)
	ENDIF			; if(SYS_NORMAL)

	; -----------------------------------------
	; checking of GAP Interlock(Add 2013/09/30)
	; -----------------------------------------
	GAP__INTLK_STS = GAP__INTLK_VAL			; GAP axis interlock status


CLOSE



; ======================================
; ======================================
;	start adjusting gap position
;		PLC7
; ======================================
; ======================================
OPEN PLC7 CLEAR


	; --------------------
	; start adjusting mode
	; --------------------
	IF( ADJ_MODE__REG = ADJ__START AND ADJ_PREMD_REG = ADJ_FINISH )
P6520 = P6520 + 1		; for Debug

		ADJ_PREMD_REG = ADJ__START
		ADJ_STAT__REG = ADJ_NORMAL
		ADJ_FLLOW_REG = ADJ_NORMAL

		IF( ADJ_STOP__REG = 0 )
			; ----------------
			; Servo OFF & KILL
			; ----------------
			CMD^A
			KILL_TIMER_FNC				; Wait (100msec)
			CMD"#1J/#2J/#17J/#18J/"
			CMD"#3J/#4J/#20J/#21J/"
			KILL_TIMER_FNC				; Wait (100msec)
			CMD^K
;			KILL_TIMER_FNC				; Wait (100msec) comment out 20150529

			SRDY_1_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
			SRDY_2_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
			SRDY_3_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
			SRDY_4_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)

			GAP__BRK_ON_REG = GAP__BRK_ON_INI	; clear count
			GAP__BRAKE_REG  = SERVO_RDY__ON
			GAP__BRAKE_STAT = GAP__BRAKE_REG

			LOCK_1_STAT_REG = UNLOCK_OCCUR
			LOCK_2_STAT_REG = UNLOCK_OCCUR
			LOCK_3_STAT_REG = UNLOCK_OCCUR
			LOCK_4_STAT_REG = UNLOCK_OCCUR

			BRK_OFF_TIMER_FNC				; Wait (100msec)

			; --------------
			; Store present velocity setting
			; --------------
			GAP_SPARATE_SPD = MOTOR_1_JOG			; Store present velocity setting

			MOTOR_1_JOG  = ADJ_SPD					; Set separate mode velocity
			MOTOR_2_JOG  = ADJ_SPD
			MOTOR_3_JOG  = ADJ_SPD
			MOTOR_4_JOG  = ADJ_SPD
			MOTOR_17_JOG = ADJ_SPD
			MOTOR_18_JOG = ADJ_SPD
			MOTOR_20_JOG = ADJ_SPD
			MOTOR_21_JOG = ADJ_SPD

			MOTOR_1_JOG_JOG  = ADJ_SPD				; Set separate mode velocity
			MOTOR_2_JOG_JOG  = ADJ_SPD
			MOTOR_3_JOG_JOG  = ADJ_SPD
			MOTOR_4_JOG_JOG  = ADJ_SPD
			MOTOR_17_JOG_JOG = ADJ_SPD
			MOTOR_18_JOG_JOG = ADJ_SPD
			MOTOR_20_JOG_JOG = ADJ_SPD
			MOTOR_21_JOG_JOG = ADJ_SPD

; --------------
; Add:2014/11/20
			COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
			COMP_01_VAL_REG = 0
			COMP_17_VAL_REG = 0
			COMP_03_VAL_REG = 0
			COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------
			; --------------------------------------
			;	X axis definition
			; --------------------------------------
			; --------------------------------------
			;	#17 I variables setting
			; --------------------------------------
			I1700 = MOTOR_INACTV				; Motor Inactivation
			I1702 = DAC_OFFSET_CH18_REG			; Command Output Address
			I1706 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

			; --------------------------------------
			;	#1 I variables setting
			; --------------------------------------
			I0102 = DAC_OUTPUT_CH01_REG			; Command Output Address
			I0103 = ROT_ENC_1					; Position Loop Feedback Address
			I0104 = ROT_ENC_1					; Velocity Loop Feedback Address
			I0106 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

			I0108 = MNT_POS_CNV_RATE			; Position Scale Factor
			I0109 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor

			I0124 = MNT_FLAG_VAL				; Flag Mode Control

			I0130 = (PROPO_GAIN_UP)				; PID Proportional Gain


			; --------------------------------------
			;	A axis definition
			; --------------------------------------
			; --------------------------------------
			;	#18 I variables setting
			; --------------------------------------
			I1800 = MOTOR_INACTV				; Motor Inactivation
			I1802 = DAC_OFFSET_CH17_REG			; Command Output Address
			I1806 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

			; --------------------------------------
			;	#2 I variables setting
			; --------------------------------------
			I0202 = DAC_OUTPUT_CH02_REG			; Command Output Address
			I0203 = ROT_ENC_2					; Position Loop Feedback Address
			I0204 = ROT_ENC_2					; Velocity Loop Feedback Address
			I0206 = MNT_MOTOR_FOLW				; Position Following Enable and Mode	

			I0208 = MNT_POS_CNV_RATE			; Position Scale Factor
			I0209 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor

			I0224 = MNT_FLAG_VAL				; Flag Mode Control

			I0230 = (PROPO_GAIN_UP)				; PID Proportional Gain


			; --------------------------------------
			;	Y axis definition
			; --------------------------------------
			; --------------------------------------
			;	#20 I variables setting
			; --------------------------------------
			I2000 = MOTOR_INACTV				; Motor Inactivation
			I2002 = DAC_OFFSET_CH21_REG			; Command Output Address
			I2006 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

			; --------------------------------------
			;	#3 I variables setting
			; --------------------------------------
			I0302 = DAC_OUTPUT_CH03_REG			; Command Output Address
			I0303 = ROT_ENC_3					; Position Loop Feedback Address	
			I0304 = ROT_ENC_3					; Velocity Loop Feedback Address
			I0306 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

			I0308 = MNT_POS_CNV_RATE			; Position Scale Factor
			I0309 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor	

			I0324 = MNT_FLAG_VAL				; Flag Mode Control

			I0330 = (PROPO_GAIN_DN)				; PID Proportional Gain

			; --------------------------------------
			;	B axis definition
			; --------------------------------------
			; --------------------------------------
			;	#21 I variables setting
			; --------------------------------------
			I2100 = MOTOR_INACTV				; Motor Inactivation
			I2102 = DAC_OFFSET_CH20_REG			; Command Output Address
			I2106 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

			; --------------------------------------
			;	#4 I variables setting
			; --------------------------------------
			I0402 = DAC_OUTPUT_CH04_REG			; Command Output Address
			I0403 = ROT_ENC_4					; Position Loop Feedback Address
			I0404 = ROT_ENC_4					; Velocity Loop Feedback Address
			I0406 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

			I0408 = MNT_POS_CNV_RATE			; Position Scale Factor
			I0409 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor

			I0424 = MNT_FLAG_VAL				; Flag Mode Control

			I0430 = (PROPO_GAIN_DN)				; PID Proportional Gain

; --------------
; Add:2015/05/29 remedy for stack

		SV_RDY_TIMER_FNC

		TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
		TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
		TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

		M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
		M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
		M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
		M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

		M1762 = M162
		M1862 = M262
		M2062 = M362
		M2162 = M462

		SV_RDY_TIMER_FNC

; Add:2015/05/29
; --------------

		ELSE		; if(ADJ_STOP__REG)
		ENDIF		; if(ADJ_STOP__REG)
	ELSE		; if(ADJ__START)
	ENDIF		; if(ADJ__START)


	; ---------------
	; servo ON & lock
	; ---------------
	; ---------------------------------------------
	; turns Servo-on from Servo-off(Add 2013/11/14)
	; ---------------------------------------------
	IF( ADJ_MODE__REG = ADJ__START AND ADJ_PREMD_REG = ADJ__START )
;	IF( ADJ_MODE__REG = ADJ__START )
		IF( ADJ_STOP__REG = 0 )
			IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
				TMP9_REG = 0
				TMP9_REG = 0
				; -------
				; MOT[#1]
				; -------
				IF( SRDY_1_OUT = SERVO_RDY_OFF )
					TMP9_REG   = 1
					SRDY_1_OUT = SERVO_RDY__ON
					CMD"#1J/"					; Servo-Lock
				ELSE
				ENDIF
				; -------
				; MOT[#2]
				; -------
				IF( SRDY_2_OUT = SERVO_RDY_OFF )
					TMP9_REG   = 1
					SRDY_2_OUT = SERVO_RDY__ON
					CMD"#2J/"					; Servo-Lock
				ELSE
				ENDIF
				; -------
				; MOT[#3]
				; -------
				IF( SRDY_3_OUT = SERVO_RDY_OFF )
					TMP9_REG   = 1
					SRDY_3_OUT = SERVO_RDY__ON
					CMD"#3J/"					; Servo-Lock
				ELSE
				ENDIF
				; -------
				; MOT[#4]
				; -------
				IF( SRDY_4_OUT = SERVO_RDY_OFF )
					TMP9_REG   = 1
					SRDY_4_OUT = SERVO_RDY__ON
					CMD"#4J/"					; Servo-Lock
				ELSE
				ENDIF

				IF( TMP9_REG = 1 )
					SV_RDY_TIMER_FNC				; Wait (20msec)

					GAP__BRAKE_REG  = SERVO_RDY_OFF
					GAP__BRAKE_STAT = GAP__BRAKE_REG

					LOCK_1_STAT_REG = LOCK_OCCUR
					LOCK_2_STAT_REG = LOCK_OCCUR
					LOCK_3_STAT_REG = LOCK_OCCUR
					LOCK_4_STAT_REG = LOCK_OCCUR

					BRK_OFF_TIMER_FNC				; Wait 100msec)
				ELSE
				ENDIF
			ELSE									; if(MOT_SRDY_xx_REG)
			ENDIF									; if(MOT_SRDY_xx_REG)
		ELSE									; if(ADJ_STOP__REG)
		ENDIF									; if(ADJ_STOP__REG)
	ELSE									; if(ADJ_MODE__REG)
	ENDIF									; if(ADJ_MODE__REG)


	; ----------------------
	; execute adjusting mode
	; ----------------------
	IF( ADJ_MODE__REG = ADJ__START AND ADJ_PREMD_REG = ADJ__START )

P6500 = P6500 + 1		; for Debug

		; ------------------------------------
		; calc Vertical offset(Add:2014/05/28)
		; ------------------------------------
		; --------
		; Upstream
		; --------
		TMP4_REG = ( MOT_1_OFFSET_REG - MOT_1_POS_REG )		; Upper
		TMP5_REG = ( MOT_3_OFFSET_REG - MOT_3_POS_REG )		; Lower
		ADJ_VRT_UP_OF_REG = ( TMP4_REG - TMP5_REG ) / 2
		; ----------
		; Downstream
		; ----------
		TMP4_REG = ( MOT_2_OFFSET_REG - MOT_2_POS_REG )		; Upper
		TMP5_REG = ( MOT_4_OFFSET_REG - MOT_4_POS_REG )		; Lower
		ADJ_VRT_DN_OF_REG = ( TMP4_REG - TMP5_REG ) / 2
		; -------
		; Average
		; -------
		ADJ_VRT_AV_OF_REG = ( ADJ_VRT_UP_OF_REG + ADJ_VRT_DN_OF_REG ) / 2

		ADJ_COUNT_REG  = 1
		WHILE( ADJ_COUNT_REG < ADJ_RETRY_MAX )

P6531 = P6531 + 1		; for Debug
P6532 = ADJ_COUNT_REG	; for Debug

			ADJ_PREMD_REG = ADJ_MODE__REG

; --------------
; Add:2014/09/26
			; ---------------
			; Amp Alarm(Mx23)
			; ---------------
			IF( AMP_ALM_1_REG = AMP_FAULT OR AMP_ALM_2_REG = AMP_FAULT OR AMP_ALM_3_REG = AMP_FAULT OR AMP_ALM_4_REG = AMP_FAULT )
				IF( MOT_SRDY_1_REG = SERVO_RDY__ON OR MOT_SRDY_2_REG = SERVO_RDY__ON OR MOT_SRDY_3_REG = SERVO_RDY__ON OR MOT_SRDY_4_REG = SERVO_RDY__ON )
P6906 = P6906 + 1		; for Debug

					CMD^A						; abort
					KILL_TIMER_FNC				; 100msec wait

					ADJ_FLLOW_REG = ADJ_ERROR
					ADJ_STAT__REG = ADJ_ERROR
					ADJ_COUNT_REG = ADJ_RETRY_MAX + 1
;					ADJ_MODE__REG = ADJ_FINISH
				ELSE
				ENDIF
			ELSE
			ENDIF

			; ------------------------------------
			; If Amp Fault or following error in coordinate system 1
			; ------------------------------------
			IF( PRG1_FLT_ERR = AMP_FAULT OR PRG1_FLW_ERR = DVI_FAULT OR PRG1_WAR_ERR = DVI_FAULT )
P6907 = P6907 + 1		; for Debug

				CMD^A						; abort-all
				KILL_TIMER_FNC				; 100msec wait

				ADJ_FLLOW_REG = ADJ_ERROR
				ADJ_STAT__REG = ADJ_ERROR
				ADJ_COUNT_REG = ADJ_RETRY_MAX + 1
;				ADJ_MODE__REG = ADJ_FINISH
			ELSE
			ENDIF
; Add:2014/09/26
; --------------

			; ----------------------
			; LS or kill-LS detected
			; ----------------------
			IF( ADJ_MODE__REG = ADJ__START AND ADJ_STAT__REG != ADJ_ERROR )
;				IF( OPEN_KILL_REG = LIMIT_OFF OR CLOSE_KILL_REG = LIMIT_OFF )
				IF( OPEN_KILL_REG = LIMIT_OFF OR CLOSE_KILL_REG = LIMIT_OFF OR GAP_CLOSE_KILL_REG = LIMIT_OFF )
					ADJ_STAT__REG = ADJ_ERROR
					ADJ_COUNT_REG = ADJ_RETRY_MAX + 1
;					ADJ_MODE__REG = ADJ_FINISH
				ELSE
				ENDIF

;				IF( OPEN_REG = LIMIT_ON OR CLOSE_REG = LIMIT_OFF )
				IF( OPEN_REG = LIMIT_ON OR CLOSE_REG = LIMIT_OFF OR GAP_CLOSE_REG = LIMIT_OFF )
					ADJ_STAT__REG = ADJ_ERROR
					ADJ_COUNT_REG = ADJ_RETRY_MAX + 1
;					ADJ_MODE__REG = ADJ_FINISH
				ELSE
				ENDIF
			ELSE
			ENDIF

			IF( ADJ_STAT__REG = ADJ_NORMAL )
				IF( ADJ_MODE__REG = ADJ__START )
					IF( ADJ_STOP__REG = 1 )

						ADJ_COUNT_REG = ADJ_RETRY_MAX + 1

					ELSE		; if(ADJ_STOP__REG)
						; ---------------
						; GAP was stopped
						; ---------------
						IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
							; ------------------------------------
							; calc Vertical offset(Add:2014/05/28)
							; ------------------------------------
							; --------
							; Upstream
							; --------
							TMP4_REG = ( MOT_1_OFFSET_REG - MOT_1_POS_REG )		; Upper
							TMP5_REG = ( MOT_3_OFFSET_REG - MOT_3_POS_REG )		; Lower
							ADJ_VRT_UP_OF_REG = ( TMP4_REG - TMP5_REG ) / 2
							; ----------
							; Downstream
							; ----------
							TMP4_REG = ( MOT_2_OFFSET_REG - MOT_2_POS_REG )		; Upper
							TMP5_REG = ( MOT_4_OFFSET_REG - MOT_4_POS_REG )		; Lower
							ADJ_VRT_DN_OF_REG = ( TMP4_REG - TMP5_REG ) / 2
							; -------
							; Average
							; -------
							ADJ_VRT_AV_OF_REG = ( ADJ_VRT_UP_OF_REG + ADJ_VRT_DN_OF_REG ) / 2

							; ----------------------------------------
							; Vertical Offset position correction value calculation [unit=nm]
							; ----------------------------------------
;							ADJ_VRT_OFFST_REG = ADJ_VRT_AV_OF_REG - VRT_AV_OFFSET_REG
							ADJ_VRT_OFFST_REG = ADJ_VRT_AV_OF_REG - ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV )
							; ---------
							; over 30um
							; ---------
							IF( ADJ_VRT_OFFST_REG > ADJ_VRT_OFFST_MAX )
								ADJ_VRT_OFFST_REG = 0
							ELSE
							ENDIF
							IF( ADJ_VRT_OFFST_REG < ADJ_VRT_OFFST_MIN )
								ADJ_VRT_OFFST_REG = 0
							ELSE
							ENDIF

							ADJ_COUNT_REG = ADJ_COUNT_REG + 1

							ADJ_DRIVE_REG = $000000
							; ----------
							; MOT[#3-#4]
							; ----------
							TMP4_REG = ( MOT_3_OFFSET_REG - MOT_3_POS_REG )
							TMP5_REG = ( MOT_4_OFFSET_REG - MOT_4_POS_REG )
							TMP6_REG = TMP4_REG - TMP5_REG
							ADJ_DN_AVE = ( TMP4_REG + TMP5_REG ) / 2
							IF( TMP6_REG < 0 )
								ADJ_DN_DIV = TMP6_REG * -1
							ELSE
								ADJ_DN_DIV = TMP6_REG * 1
							ENDIF

							IF( ADJ_RANGE_MAX < ADJ_DN_DIV )			; over range
								ADJ_STAT__REG = ADJ_ERROR
;								ADJ_MODE__REG = ADJ_FINISH
								ADJ_COUNT_REG = ADJ_RETRY_MAX + 1
							ELSE
								; -------
								; MOT[#4]
								; -------
								TMP7_REG = ( MOT_4_OFFSET_REG - MOT_4_POS_REG ) - ADJ_DN_AVE
								IF( TMP7_REG < 0 )
									TMP8_REG = TMP7_REG * -1
								ELSE
									TMP8_REG = TMP7_REG * 1
								ENDIF

								IF( TMP8_REG < ADJ_RANGE_MIN )									; under range
									TMP9_REG  = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) - ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV )
									TMP10_REG = ( MOT_4_OFFSET_REG - MOT_4_POS_REG )
									IF( TMP9_REG - ADJ_GAP_OFFST_MAX < TMP10_REG AND TMP10_REG < TMP9_REG + ADJ_GAP_OFFST_MAX )
										GAP_4_ADJ_POS = 0
									ELSE
										GAP_4_ADJ_POS = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) - ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_4_OFFSET_REG - MOT_4_POS_REG )
										ADJ_DRIVE_REG = ADJ_DRIVE_REG | GAP_4_ADJ_DRV
									ENDIF
								ELSE															; need adjusting
									GAP_4_ADJ_POS = ( TMP7_REG * -1 ) * MOT_LIN_ROT_CNV
									ADJ_DRIVE_REG = ADJ_DRIVE_REG | GAP_4_ADJ_DRV
								ENDIF

								; -------
								; MOT[#3]
								; -------
								TMP7_REG = ( MOT_3_OFFSET_REG - MOT_3_POS_REG ) - ADJ_DN_AVE
								IF( TMP7_REG < 0 )
									TMP8_REG = TMP7_REG * -1
								ELSE
									TMP8_REG = TMP7_REG * 1
								ENDIF

								IF( TMP8_REG < ADJ_RANGE_MIN )									; under range
									TMP9_REG  = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) - ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV )
									TMP10_REG = ( MOT_3_OFFSET_REG - MOT_3_POS_REG )
									IF( TMP9_REG - ADJ_GAP_OFFST_MAX < TMP10_REG AND TMP10_REG < TMP9_REG + ADJ_GAP_OFFST_MAX )
										GAP_3_ADJ_POS = 0
									ELSE
										GAP_3_ADJ_POS = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) - ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_3_OFFSET_REG - MOT_3_POS_REG )
										ADJ_DRIVE_REG = ADJ_DRIVE_REG | GAP_3_ADJ_DRV
									ENDIF

								ELSE															; need adjusting
									GAP_3_ADJ_POS = ( TMP7_REG * -1 ) * MOT_LIN_ROT_CNV
									ADJ_DRIVE_REG = ADJ_DRIVE_REG | GAP_3_ADJ_DRV
								ENDIF

							ENDIF		; if(ADJ_RANGE_MAX[#3-#4])


							; ----------
							; MOT[#1-#2]
							; ----------
							TMP4_REG   = ( MOT_1_OFFSET_REG - MOT_1_POS_REG )
							TMP5_REG   = ( MOT_2_OFFSET_REG - MOT_2_POS_REG )
							TMP6_REG   = TMP4_REG - TMP5_REG
							ADJ_UP_AVE = ( TMP4_REG + TMP5_REG ) / 2
							IF( TMP6_REG < 0 )
								ADJ_UP_DIV = TMP6_REG * -1
							ELSE
								ADJ_UP_DIV = TMP6_REG * 1
							ENDIF

							IF( ADJ_RANGE_MAX < ADJ_UP_DIV )			; over range
								ADJ_STAT__REG = ADJ_ERROR
;								ADJ_MODE__REG = ADJ_FINISH
								ADJ_COUNT_REG = ADJ_RETRY_MAX + 1
							ELSE
								; -------
								; MOT[#2]
								; -------
								TMP7_REG = ( MOT_2_OFFSET_REG - MOT_2_POS_REG ) - ADJ_UP_AVE
								IF( TMP7_REG < 0 )
									TMP8_REG = TMP7_REG * -1
								ELSE
									TMP8_REG = TMP7_REG * 1
								ENDIF

								IF( TMP8_REG < ADJ_RANGE_MIN )									; under range
									TMP9_REG  = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) + ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV )
									TMP10_REG = ( MOT_2_OFFSET_REG - MOT_2_POS_REG )
									IF( TMP9_REG - ADJ_GAP_OFFST_MAX < TMP10_REG AND TMP10_REG < TMP9_REG + ADJ_GAP_OFFST_MAX )
										GAP_2_ADJ_POS = 0
									ELSE
										GAP_2_ADJ_POS = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) + ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_2_OFFSET_REG - MOT_2_POS_REG )
										ADJ_DRIVE_REG = ADJ_DRIVE_REG | GAP_2_ADJ_DRV
									ENDIF
								ELSE															; need adjusting
									GAP_2_ADJ_POS = ( TMP7_REG * -1 ) * MOT_LIN_ROT_CNV
									ADJ_DRIVE_REG = ADJ_DRIVE_REG | GAP_2_ADJ_DRV
								ENDIF

								; -------
								; MOT[#1]
								; -------
								TMP7_REG = ( MOT_1_OFFSET_REG - MOT_1_POS_REG ) - ADJ_UP_AVE
								IF( TMP7_REG < 0 )
									TMP8_REG = TMP7_REG * -1
								ELSE
									TMP8_REG = TMP7_REG * 1
								ENDIF

								IF( TMP8_REG < ADJ_RANGE_MIN )									; under range
									TMP9_REG  = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) + ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV )
									TMP10_REG = ( MOT_1_OFFSET_REG - MOT_1_POS_REG )
									IF( TMP9_REG - ADJ_GAP_OFFST_MAX < TMP10_REG AND TMP10_REG < TMP9_REG + ADJ_GAP_OFFST_MAX )
										GAP_1_ADJ_POS = 0
									ELSE
										GAP_1_ADJ_POS = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) + ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_1_OFFSET_REG - MOT_1_POS_REG )
										ADJ_DRIVE_REG = ADJ_DRIVE_REG | GAP_1_ADJ_DRV
									ENDIF
								ELSE															; need adjusting
									GAP_1_ADJ_POS = ( TMP7_REG * -1 ) * MOT_LIN_ROT_CNV
									ADJ_DRIVE_REG = ADJ_DRIVE_REG | GAP_1_ADJ_DRV
								ENDIF

							ENDIF		; if(ADJ_RANGE_MAX[#1-#2])

							; --------
							; In range
							; --------
							IF( ADJ_DRIVE_REG = $000000 )
								ADJ_COUNT_REG = ADJ_RETRY_MAX + 1
							ELSE
							ENDIF

							; --------------
							; need adjusting
							; --------------
							; -------
							; MOT[#4]
							; -------
							IF( ADJ_STOP__REG = 1 )

								ADJ_COUNT_REG = ADJ_RETRY_MAX + 1

							ELSE		; if(ADJ_STOP__REG)
								IF( MOV_4_STAT_REG = STOP_AXIS )
									TMP10_REG = ADJ_DRIVE_REG & GAP_4_ADJ_DRV
									IF( TMP10_REG = GAP_4_ADJ_DRV )
										IF( GAP_4_ADJ_POS != 0 )
											CMD"#4J/"						; Servo-Lock
											SV_RDY_TIMER_FNC				; Wait (20msec)

;											M472 = GAP_4_ADJ_POS
;											M472 = GAP_4_ADJ_POS + ( ADJ_VRT_OFFST_REG )
;											M472 = GAP_4_ADJ_POS + ( ADJ_VRT_OFFST_REG ) + ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 - ADJ_DN_AVE )
											M472 = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) - ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_4_OFFSET_REG - MOT_4_POS_REG )

P6504 = GAP_4_ADJ_POS					; for Debug
P6514 = P6504 + ( ADJ_VRT_OFFST_REG )	; for Debug
P6524 = P6514 + ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 - ADJ_DN_AVE )	; for Debug

											BRK_OFF_TIMER_FNC				; Wait (100msec)
;;;											CMD"#4J^(GAP_4_ADJ_POS)"		; adjusting MOT[#4]
											CMD"#4J^*"						; adjusting MOT[#4]
											BRK_OFF_TIMER_FNC				; Wait (100msec)

											GAP_4_ADJ_POS = 0
										ELSE
										ENDIF
									ELSE
									ENDIF
								ELSE		; if(STOP_AXIS)
								ENDIF		; if(STOP_AXIS)
							ENDIF		; if(ADJ_STOP__REG)
							; -------
							; MOT[#3]
							; -------
							IF( ADJ_STOP__REG = 1 )

								ADJ_COUNT_REG = ADJ_RETRY_MAX + 1

							ELSE		; if(ADJ_STOP__REG)
								IF( MOV_3_STAT_REG = STOP_AXIS )
									TMP10_REG = ADJ_DRIVE_REG & GAP_3_ADJ_DRV
									IF( TMP10_REG = GAP_3_ADJ_DRV )
										IF( GAP_3_ADJ_POS != 0 )
											CMD"#3J/"						; Servo-Lock
											SV_RDY_TIMER_FNC				; Wait (20msec)

;											M372 = GAP_3_ADJ_POS
;											M372 = GAP_3_ADJ_POS + ( ADJ_VRT_OFFST_REG )
;											M372 = GAP_3_ADJ_POS + ( ADJ_VRT_OFFST_REG ) + ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 - ADJ_DN_AVE )
											M372 = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) - ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_3_OFFSET_REG - MOT_3_POS_REG )

P6503 = GAP_3_ADJ_POS					; for Debug
P6513 = P6503 + ( ADJ_VRT_OFFST_REG )	; for Debug
P6523 = P6513 + ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 - ADJ_DN_AVE )	; for Debug

											BRK_OFF_TIMER_FNC				; Wait (100msec)
;;;											CMD"#3J^(GAP_3_ADJ_POS)"		; adjusting MOT[#3]
											CMD"#3J^*"						; adjusting MOT[#3]
											BRK_OFF_TIMER_FNC				; Wait (100msec)

											GAP_3_ADJ_POS = 0
										ELSE
										ENDIF
									ELSE
									ENDIF
								ELSE		; if(STOP_AXIS)
								ENDIF		; if(STOP_AXIS)
							ENDIF		; if(ADJ_STOP__REG)
							; -------
							; MOT[#2]
							; -------
							IF( ADJ_STOP__REG = 1 )

								ADJ_COUNT_REG = ADJ_RETRY_MAX + 1

							ELSE		; if(ADJ_STOP__REG)
								IF( MOV_2_STAT_REG = STOP_AXIS )
									TMP10_REG = ADJ_DRIVE_REG & GAP_2_ADJ_DRV
									IF( TMP10_REG = GAP_2_ADJ_DRV )
										IF( GAP_2_ADJ_POS != 0 )
											CMD"#2J/"						; Servo-Lock
											SV_RDY_TIMER_FNC				; Wait (20msec)

;											M272 = GAP_2_ADJ_POS
;											M272 = GAP_2_ADJ_POS - ( ADJ_VRT_OFFST_REG )
;											M272 = GAP_2_ADJ_POS - ( ADJ_VRT_OFFST_REG ) + ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 - ADJ_UP_AVE )
											M272 = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) + ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_2_OFFSET_REG - MOT_2_POS_REG )

P6502 = GAP_2_ADJ_POS					; for Debug
P6512 = P6502 - ( ADJ_VRT_OFFST_REG )	; for Debug
P6522 = P6512 + ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 - ADJ_UP_AVE )	; for Debug

											BRK_OFF_TIMER_FNC				; Wait (100msec)
;;;											CMD"#2J^(GAP_2_ADJ_POS)"		; adjusting MOT[#2]
											CMD"#2J^*"						; adjusting MOT[#2]
											BRK_OFF_TIMER_FNC				; Wait (100msec)

											GAP_2_ADJ_POS = 0
										ELSE
										ENDIF
									ELSE
									ENDIF
								ELSE		; if(STOP_AXIS)
								ENDIF		; if(STOP_AXIS)
							ENDIF		; if(ADJ_STOP__REG)
							; -------
							; MOT[#1]
							; -------
							IF( ADJ_STOP__REG = 1 )

								ADJ_COUNT_REG = ADJ_RETRY_MAX + 1

							ELSE		; if(ADJ_STOP__REG)
								IF( MOV_1_STAT_REG = STOP_AXIS )
									TMP10_REG = ADJ_DRIVE_REG & GAP_1_ADJ_DRV
									IF( TMP10_REG = GAP_1_ADJ_DRV )
										IF( GAP_1_ADJ_POS != 0 )
											CMD"#1J/"						; Servo-Lock
											SV_RDY_TIMER_FNC				; Wait (20msec)

;											M172 = GAP_1_ADJ_POS
;											M172 = GAP_1_ADJ_POS - ( ADJ_VRT_OFFST_REG )
;											M172 = GAP_1_ADJ_POS - ( ADJ_VRT_OFFST_REG ) + ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 - ADJ_UP_AVE )
											M172 = ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 ) + ( MEM_VRT_STPOS_REG * MOT_SCALE_CNV ) - ( MOT_1_OFFSET_REG - MOT_1_POS_REG )

P6501 = GAP_1_ADJ_POS					; for Debug
P6511 = P6501 - ( ADJ_VRT_OFFST_REG )	; for Debug
P6521 = P6511 + ( MEM_GAP_STPOS_REG * MOT_SCALE_CNV / 2 - ADJ_UP_AVE )	; for Debug

											BRK_OFF_TIMER_FNC				; Wait (100msec)
;;;											CMD"#1J^(GAP_1_ADJ_POS)"		; adjusting MOT[#1]
											CMD"#1J^*"						; adjusting MOT[#1]
											BRK_OFF_TIMER_FNC				; Wait (100msec)

											GAP_1_ADJ_POS = 0
										ELSE
										ENDIF
									ELSE
									ENDIF
								ELSE		; if(STOP_AXIS)
								ENDIF		; if(STOP_AXIS)
							ENDIF		; if(ADJ_STOP__REG)

						ELSE		; if(STOP_AXIS)

							MOT_DRV_TIMER_FNC				; Wait (100msec)
							MOT_DRV_TIMER_FNC				; Wait (100msec)

						ENDIF		; if(STOP_AXIS)

					ENDIF		; if(ADJ_STOP__REG)

				ELSE		; if(ADJ_START)
				ENDIF		; if(ADJ_START)
			ELSE		; if(ADJ_NORMAL)
			ENDIF		; if(ADJ_NORMAL)

		ENDWHILE		; WHILE(!ADJ_RETRY_MAX)

		; -----------
		; finish waiting
		; -----------
;		IF( ADJ_STOP__REG = 0 )
		IF( ADJ_STOP__REG = 0 AND ADJ_FLLOW_REG = ADJ_NORMAL )
			FIN_COUNT_REG = 1
			WHILE( FIN_COUNT_REG < FIN_RETRY_MAX )
P6924 =P6924 + 1		;for Debug
				IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
					FIN_COUNT_REG = FIN_RETRY_MAX + 1
				ELSE
					FIN_COUNT_REG = FIN_COUNT_REG + 1
					BRK_OFF_TIMER_FNC				; Wait (100msec)
				ENDIF

			ENDWHILE		; WHILE(!FIN_RETRY_MAX)
		ELSE			; if(FIN_COUNT_REG)
		ENDIF			; if(FIN_COUNT_REG)

	ELSE			; if(ADJ__START)
	ENDIF			; if(ADJ__START)


	; ---------------------
	; finish adjusting mode
	; ---------------------
;	IF( ADJ_MODE__REG = ADJ__START OR ADJ_RETRY_MAX !< ADJ_COUNT_REG )
	IF( ADJ_MODE__REG = ADJ__START AND ADJ_PREMD_REG = ADJ__START )
P6920 = P6920 + 1		; for Debug

		IF( ADJ_STOP__REG = 1 )
P6921 = P6921 + 1		; for Debug
			CMD"H"					; JOG
			HOLD_TIMER_FNC			; 300msec wait

			HLD_COUNT_REG = 1
			WHILE( HLD_COUNT_REG < 40 )
;				IF( MOV_1_STAT_REG = MOVE_AXIS )
				IF( MOV_1_STAT_REG = MOVE_AXIS OR MOV_2_STAT_REG = MOVE_AXIS OR MOV_3_STAT_REG = MOVE_AXIS OR MOV_4_STAT_REG = MOVE_AXIS )
					HLD_COUNT_REG = HLD_COUNT_REG + 1
				ELSE
					HLD_COUNT_REG = 50
				ENDIF

				SV_RDY_TIMER_FNC
			ENDWHILE
		ELSE
		ENDIF

		CMD^A							; Abort
		KILL_TIMER_FNC					; 100msec wait
		CMD"#1J/#2J/#3J/#4J/"

		; ----------------
		; Servo OFF & KILL
		; ----------------
		BRK_OFF_TIMER_FNC				; ë“Çøéûä‘(100msec)
		CMD^K
;		BRK_OFF_TIMER_FNC				; ë“Çøéûä‘(100msec) comment out 20150529

		SRDY_1_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
		SRDY_2_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
		SRDY_3_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
		SRDY_4_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)

		GAP__BRK_ON_REG = GAP__BRK_ON_INI	; clear count
		GAP__BRAKE_REG  = SERVO_RDY__ON
		GAP__BRAKE_STAT = GAP__BRAKE_REG
		DRIVE_MODE_REG  = DRIVE_STOP		; Add 2014/04/30

		LOCK_1_STAT_REG = UNLOCK_OCCUR
		LOCK_2_STAT_REG = UNLOCK_OCCUR
		LOCK_3_STAT_REG = UNLOCK_OCCUR
		LOCK_4_STAT_REG = UNLOCK_OCCUR

		IF( GAP_SPARATE_SPD != 0 )
;		IF( GAP_SPARATE_SPD != 0 AND GAP_SPARATE_SPD != ADJ_SPD )
			MOTOR_1_JOG  = GAP_SPARATE_SPD			; Restore velocity setting
			MOTOR_2_JOG  = GAP_SPARATE_SPD
			MOTOR_3_JOG  = GAP_SPARATE_SPD
			MOTOR_4_JOG  = GAP_SPARATE_SPD
			MOTOR_17_JOG = GAP_SPARATE_SPD
			MOTOR_18_JOG = GAP_SPARATE_SPD
			MOTOR_20_JOG = GAP_SPARATE_SPD
			MOTOR_21_JOG = GAP_SPARATE_SPD

			MOTOR_1_JOG_JOG  = GAP_SPARATE_SPD		; Restore velocity setting
			MOTOR_2_JOG_JOG  = GAP_SPARATE_SPD
			MOTOR_3_JOG_JOG  = GAP_SPARATE_SPD
			MOTOR_4_JOG_JOG  = GAP_SPARATE_SPD
			MOTOR_17_JOG_JOG = GAP_SPARATE_SPD
			MOTOR_18_JOG_JOG = GAP_SPARATE_SPD
			MOTOR_20_JOG_JOG = GAP_SPARATE_SPD
			MOTOR_21_JOG_JOG = GAP_SPARATE_SPD

			GAP_SPARATE_SPD = 0
		ELSE
		ENDIF

		; --------------------------------------
		;	X axis definition
		; --------------------------------------
		; --------------------------------------
		;	#17 I variables setting
		; --------------------------------------
		I1700 = MOTOR_ACTIVE				; Motor Activation
		I1702 = DAC_OUTPUT_CH01_REG			; Command Output Address
		I1706 = MOTOR_FOLW					; Position Following Enable and Mode

		; --------------------------------------
		;	#1 I variables setting
		; --------------------------------------
		I0102 = DAC_OFFSET_CH18_REG			; Command Output Address
		I0103 = BISS_ADD_1_2				; Position Loop Feedback Address
		I0104 = BISS_ADD_1_2				; Velocity Loop Feedback Address
		I0106 = MOTOR_FOLW					; Position Following Enable and Mode

		I0108 = I1708						; Position Scale Factor
		I0109 = I1708						; Velocity-Loop Scale Factor

		I0124 = MOTOR_FLAG_VAL				; Flag Mode Control

		I0130 = (PROPO_GAIN_UP)				; PID Proportional Gain

		; --------------------------------------
		;	A axis definition
		; --------------------------------------
		; --------------------------------------
		;	#18 I variables setting
		; --------------------------------------
		I1800 = MOTOR_ACTIVE				; Motor Activation
		I1802 = DAC_OUTPUT_CH02_REG			; Command Output Address
		I1806 = MOTOR_FOLW					; Position Following Enable and Mode

		; --------------------------------------
		;	#2 I variables setting
		; --------------------------------------
		I0202 = DAC_OFFSET_CH17_REG			; Command Output Address
		I0203 = BISS_SUB_1_2				; Position Loop Feedback Address
		I0204 = BISS_SUB_1_2				; Velocity Loop Feedback Address
		I0206 = MOTOR_FOLW					; Position Following Enable and Mode

		I0208 = I1708						; Position Scale Factor
		I0209 = I1708						; Velocity-Loop Scale Factor

		I0224 = MOTOR_FLAG_VAL				; Flag Mode Control

		I0230 = (2*PROPO_GAIN_UP)			; PID Proportional Gain

		; --------------------------------------
		;	Y axis definition
		; --------------------------------------
		; --------------------------------------
		;	#20 I variables
		; --------------------------------------
		I2000 = MOTOR_ACTIVE				; Motor Activation
		I2002 = DAC_OUTPUT_CH03_REG			; Command Output Address
		I2006 = MOTOR_FOLW					; Position Following Enable and Mode

		; --------------------------------------
		;	#3 I variables setting
		; --------------------------------------
		I0302 = DAC_OFFSET_CH21_REG			; Command Output Address
		I0303 = BISS_ADD_3_4				; Position Loop Feedback Address
		I0304 = BISS_ADD_3_4				; Velocity Loop Feedback Address
		I0306 = MOTOR_FOLW					; Position Following Enable and Mode

		I0308 = I2008						; Position Scale Factor
		I0309 = I2008						; Velocity-Loop Scale Factor

		I0324 = MOTOR_FLAG_VAL				; Flag Mode Control

		I0330 = (PROPO_GAIN_DN)				; PID Proportional Gain


		; --------------------------------------
		;	B axis definition
		; --------------------------------------
		; --------------------------------------
		;	#21 I variables setting
		; --------------------------------------
		I2100 = MOTOR_ACTIVE				; Motor Activation
		I2102 = DAC_OUTPUT_CH04_REG			; Command Output Address
		I2106 = MOTOR_FOLW					; Position Following Enable and Mode

		; --------------------------------------
		;	#4 I variables setting
		; --------------------------------------
		I0402 = DAC_OFFSET_CH20_REG			; Command Output Address
		I0403 = BISS_SUB_3_4				; Position Loop Feedback Address
		I0404 = BISS_SUB_3_4				; Velocity Loop Feedback Address
		I0406 = MOTOR_FOLW					; Position Following Enable and Mode

		I0408 = I2008						; Position Scale Factor
		I0409 = I2008						; Velocity-Loop Scale Factor

		I0424 = MOTOR_FLAG_VAL				; Flag Mode Control

		I0430 = (2*PROPO_GAIN_DN)			; PID Proportional Gain

; --------------
; Add:2015/05/29 remedy for stack

		SV_RDY_TIMER_FNC

		TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
		TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
		TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

		M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
		M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
		M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
		M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

		M1762 = M162
		M1862 = M262
		M2062 = M362
		M2162 = M462

		SV_RDY_TIMER_FNC

; Add:2015/05/29
; --------------

		ADJ_MODE__REG = ADJ_FINISH
		ADJ_PREMD_REG = ADJ_FINISH
		ADJ_STOP__REG = 0

P6923 = P6923 + 1		; for Debug

;		IF( M1762 != M162 )
;			M1762 = M162
;		ELSE
;		ENDIF
;		IF( M1862 != M262 )
;			M1862 = M262
;		ELSE
;		ENDIF
;		IF( M2062 != M362 )
;			M2062 = M362
;		ELSE
;		ENDIF
;		IF( M2162 != M462 )
;			M2162 = M462
;		ELSE
;		ENDIF

	IOC_RCV_RDY_REG = RCV__READY_VAL			; ready 20150617

	ELSE			; IF(ADJ_FINISH)
	ENDIF			; IF(ADJ_FINISH)

; --------------
; Add:2014/09/28
	; --------------------------------
	; Process at following error and amplifier fault
	; At axis following error
	; --------------------------------
;	IF( ADJ_FLLOW_REG = ADJ_ERROR )
	IF( ADJ_FLLOW_REG = ADJ_ERROR OR ADJ_STAT__REG = ADJ_ERROR )
P6922 = P6922 + 1		; for Debug

		IF( ADJ_STAT__REG = ADJ_ERROR )
			CMD"H"						; JOG
			HOLD_TIMER_FNC				; 300msec wait

			HLD_COUNT_REG = 1
			WHILE(HLD_COUNT_REG < 40)
				IF( MOV_1_STAT_REG = MOVE_AXIS )
					HLD_COUNT_REG = HLD_COUNT_REG + 1
				ELSE
					HLD_COUNT_REG = 50
				ENDIF

				SV_RDY_TIMER_FNC
			ENDWHILE

			CMD^A						; Abort
			KILL_TIMER_FNC				; 100msec wait
		ELSE
		ENDIF

		CMD"#1J/#2J/#3J/#4J/"
		BRK_OFF_TIMER_FNC				; Wait (100msec)

		; ----------------
		; Servo OFF & KILL
		; ----------------
		CMD^K
;		KILL_TIMER_FNC				; Wait (100msec) comment out 20150529

		SRDY_1_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
		SRDY_2_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
		SRDY_3_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
		SRDY_4_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)

		GAP__BRK_ON_REG = GAP__BRK_ON_INI	; clear count
		GAP__BRAKE_REG  = SERVO_RDY__ON
		GAP__BRAKE_STAT = GAP__BRAKE_REG
		DRIVE_MODE_REG  = DRIVE_STOP		; Add 2014/04/30

		LOCK_1_STAT_REG = UNLOCK_OCCUR
		LOCK_2_STAT_REG = UNLOCK_OCCUR
		LOCK_3_STAT_REG = UNLOCK_OCCUR
		LOCK_4_STAT_REG = UNLOCK_OCCUR

		BRK_OFF_TIMER_FNC				; Wait (100msec)

		IF( GAP_SPARATE_SPD != 0 )
;		IF( GAP_SPARATE_SPD != 0 AND GAP_SPARATE_SPD != ADJ_SPD )
			MOTOR_1_JOG  = GAP_SPARATE_SPD			; Restore velocity setting
			MOTOR_2_JOG  = GAP_SPARATE_SPD
			MOTOR_3_JOG  = GAP_SPARATE_SPD
			MOTOR_4_JOG  = GAP_SPARATE_SPD
			MOTOR_17_JOG = GAP_SPARATE_SPD
			MOTOR_18_JOG = GAP_SPARATE_SPD
			MOTOR_20_JOG = GAP_SPARATE_SPD
			MOTOR_21_JOG = GAP_SPARATE_SPD

			MOTOR_1_JOG_JOG  = GAP_SPARATE_SPD		; Restore velocity setting
			MOTOR_2_JOG_JOG  = GAP_SPARATE_SPD
			MOTOR_3_JOG_JOG  = GAP_SPARATE_SPD
			MOTOR_4_JOG_JOG  = GAP_SPARATE_SPD
			MOTOR_17_JOG_JOG = GAP_SPARATE_SPD
			MOTOR_18_JOG_JOG = GAP_SPARATE_SPD
			MOTOR_20_JOG_JOG = GAP_SPARATE_SPD
			MOTOR_21_JOG_JOG = GAP_SPARATE_SPD

			GAP_SPARATE_SPD = 0
		ELSE
		ENDIF

; --------------
; Add:2014/11/20
		COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
		COMP_01_VAL_REG = 0
		COMP_17_VAL_REG = 0
		COMP_03_VAL_REG = 0
		COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------
		; --------------------------------------
		;	X axis definition
		; --------------------------------------
		; --------------------------------------
		;	#17 I variables setting
		; --------------------------------------
		I1700 = MOTOR_ACTIVE				; Motor Activation
		I1702 = DAC_OUTPUT_CH01_REG			; Command Output Address
		I1706 = MOTOR_FOLW					; Position Following Enable and Mode

		; --------------------------------------
		;	#1 I variables setting
		; --------------------------------------
		I0102 = DAC_OFFSET_CH18_REG			; Command Output Address
		I0103 = BISS_ADD_1_2				; Position Loop Feedback Address
		I0104 = BISS_ADD_1_2				; Velocity Loop Feedback Address
		I0106 = MOTOR_FOLW					; Position Following Enable and Mode

		I0108 = I1708						; Position Scale Factor
		I0109 = I1708						; Velocity-Loop Scale Factor

		I0124 = MOTOR_FLAG_VAL				; Flag Mode Control

		I0130 = (PROPO_GAIN_UP)				; PID Proportional Gain

		; --------------------------------------
		;	A axis definition
		; --------------------------------------
		; --------------------------------------
		;	#18 I variables setting
		; --------------------------------------
		I1800 = MOTOR_ACTIVE				; Motor Activation
		I1802 = DAC_OUTPUT_CH02_REG			; Command Output Address
		I1806 = MOTOR_FOLW					; Position Following Enable and Mode

		; --------------------------------------
		;	#2 I variables setting
		; --------------------------------------
		I0202 = DAC_OFFSET_CH17_REG			; Command Output Address
		I0203 = BISS_SUB_1_2				; Position Loop Feedback Address
		I0204 = BISS_SUB_1_2				; Velocity Loop Feedback Address
		I0206 = MOTOR_FOLW					; Position Following Enable and Mode

		I0208 = I1708						; Position Scale Factor
		I0209 = I1708						; Velocity-Loop Scale Factor

		I0224 = MOTOR_FLAG_VAL				; Flag Mode Control

		I0230 = (2*PROPO_GAIN_UP)			; PID Proportional Gain

		; --------------------------------------
		;	Y axis definition
		; --------------------------------------
		; --------------------------------------
		;	#20 I variables setting
		; --------------------------------------
		I2000 = MOTOR_ACTIVE				; Motor Activation
		I2002 = DAC_OUTPUT_CH03_REG			; Command Output Address
		I2006 = MOTOR_FOLW					; Position Following Enable and Mode

		; --------------------------------------
		;	#3 I variables
		; --------------------------------------
		I0302 = DAC_OFFSET_CH21_REG			; Command Output Address
		I0303 = BISS_ADD_3_4				; Position Loop Feedback Address
		I0304 = BISS_ADD_3_4				; Velocity Loop Feedback Address
		I0306 = MOTOR_FOLW					; Position Following Enable and Mode

		I0308 = I2008						; Position Scale Factor
		I0309 = I2008						; Velocity-Loop Scale Factor

		I0324 = MOTOR_FLAG_VAL				; Flag Mode Control

		I0330 = (PROPO_GAIN_DN)				; PID Proportional Gain


		; --------------------------------------
		;	B axis definition
		; --------------------------------------
		; --------------------------------------
		;	#21 I variables setting
		; --------------------------------------
		I2100 = MOTOR_ACTIVE				; Motor Activation
		I2102 = DAC_OUTPUT_CH04_REG			; Command Output Address
		I2106 = MOTOR_FOLW					; Position Following Enable and Mode

		; --------------------------------------
		;	#4 I variables setting
		; --------------------------------------
		I0402 = DAC_OFFSET_CH20_REG			; Command Output Address
		I0403 = BISS_SUB_3_4				; Position Loop Feedback Address
		I0404 = BISS_SUB_3_4				; Velocity Loop Feedback Address
		I0406 = MOTOR_FOLW					; Position Following Enable and Mode

		I0408 = I2008						; Position Scale Factor
		I0409 = I2008						; Velocity-Loop Scale Factor

		I0424 = MOTOR_FLAG_VAL				; Flag Mode Control

		I0430 = (2*PROPO_GAIN_DN)			; PID Proportional Gain

; --------------
; Add:2015/04/04
		SV_RDY_TIMER_FNC
; Add:2015/04/04
; --------------

; --------------
; Add:2015/05/29 remedy for stack

		SV_RDY_TIMER_FNC

		TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
		TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
		TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

		M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
		M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
		M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
		M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

		M1762 = M162
		M1862 = M262
		M2062 = M362
		M2162 = M462

		SV_RDY_TIMER_FNC

; Add:2015/05/29
; --------------
		ADJ_MODE__REG = ADJ_FINISH
		ADJ_PREMD_REG = ADJ_FINISH
		ADJ_STOP__REG = 0
		ADJ_STAT__REG = ADJ_NORMAL
		ADJ_FLLOW_REG = ADJ_NORMAL

		IOC_RCV_RDY_REG = RCV__READY_VAL		; ready 20150617


	ELSE
	ENDIF
; Add:2014/09/28
; --------------

CLOSE



; ======================================
; ======================================
;	home position drive
;		PLC10
; ======================================
; ======================================
OPEN PLC10 CLEAR


	; -------------------
	; HOME POSITION DRIVE
	; -------------------
	IF( IOC_GO_HOME_DRV_REG != 0 )
		IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
			IF( PROG_STAT_REG = PROG_STP_STAT )
				IF( GAP__INTLK_VAL = GAP__INTLK_DIS )
					TMP8_REG = 0
					TMP8_REG = 0
					; ----------------
					; detected KILL LS
					; ----------------
					IF( HOME_REG = LIMIT_ON )
						; ---------
						; Open-KILL
						; ---------
						IF( OPEN_KILL_1_REG = LIMIT_OFF OR OPEN_KILL_2_REG = LIMIT_OFF )
							TMP8_REG = 1
						ELSE
						ENDIF
					ELSE
						; ----------------------------
						; Close-KILL or GAP-Close-KILL
						; ----------------------------
;						IF( CLOSE_KILL_1_REG = LIMIT_OFF OR CLOSE_KILL_2_REG = LIMIT_OFF )
						IF( CLOSE_KILL_1_REG = LIMIT_OFF OR CLOSE_KILL_2_REG = LIMIT_OFF OR GAP_CLOSE_KILL_REG = LIMIT_OFF )
							TMP8_REG = 1

P6752 = P6752 + 1		; for Debug

						ELSE
						ENDIF
					ENDIF

					; --------------------
					; not detected KILL LS
					; --------------------
					IF( TMP8_REG = 0 )
						GAP__BRK_ON_REG = GAP__BRK_ON_INI		; clear count(Add 2013/09/30)

						; ---------------------------------------------
						; turns Servo-on from Servo-off(Add 2013/09/30)
						; ---------------------------------------------
						IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
							TMP9_REG = 0
							TMP9_REG = 0

							; -------
							; MOT[#1]
							; -------
							IF( SRDY_1_OUT = SERVO_RDY_OFF )
								TMP9_REG   = 1
;								SRDY_1_OUT = SERVO_RDY__ON
;								CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
;								CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock
							ELSE
							ENDIF
							; -------
							; MOT[#2]
							; -------
							IF( SRDY_2_OUT = SERVO_RDY_OFF )
								TMP9_REG   = 1
;								SRDY_2_OUT = SERVO_RDY__ON
;								CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
;								CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock
							ELSE
							ENDIF
							; -------
							; MOT[#3]
							; -------
							IF( SRDY_3_OUT = SERVO_RDY_OFF )
								TMP9_REG   = 1
;								SRDY_3_OUT = SERVO_RDY__ON
;								CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
;								CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock
							ELSE
							ENDIF
							; -------
							; MOT[#4]
							; -------
							IF( SRDY_4_OUT = SERVO_RDY_OFF )
								TMP9_REG   = 1
;								SRDY_4_OUT = SERVO_RDY__ON
;								CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
;								CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock
							ELSE
							ENDIF

							IF( TMP9_REG = 1 )
								SRDY_1_OUT = SERVO_RDY__ON
								SRDY_2_OUT = SERVO_RDY__ON
								SRDY_3_OUT = SERVO_RDY__ON
								SRDY_4_OUT = SERVO_RDY__ON
;								SV_RDY_TIMER_FNC				; Wait (20msec) comment out 20150529

								CMD"#1J/#2J/#17J/#18J/"			; Servo-Lock
								CMD"#3J/#4J/#20J/#21J/"			; Servo-Lock

								GAP__BRAKE_REG  = SERVO_RDY_OFF
								GAP__BRAKE_STAT = GAP__BRAKE_REG
								LOCK_1_STAT_REG = LOCK_OCCUR
								LOCK_2_STAT_REG = LOCK_OCCUR
								LOCK_3_STAT_REG = LOCK_OCCUR
								LOCK_4_STAT_REG = LOCK_OCCUR

								BRK_OFF_TIMER_FNC				; Wait (100msec)
							ELSE
							ENDIF
						ELSE									; if(SERVO_RDY_OFF)
						ENDIF									; if(SERVO_RDY_OFF)

P6701 = P6701 + 1		; for Debug

						GAP__INTLK_SPD   = MOTOR_1_JOG			; Velocity of GAP evacuation
						IF( HOME_REG = LIMIT_ON )				; detected HOME-LS
							MOTOR_1_JOG      = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_2_JOG      = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_3_JOG      = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_4_JOG      = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_17_JOG     = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_18_JOG     = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_20_JOG     = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_21_JOG     = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_1_JOG_JOG  = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_2_JOG_JOG  = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_3_JOG_JOG  = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_4_JOG_JOG  = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_17_JOG_JOG = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_18_JOG_JOG = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_20_JOG_JOG = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
							MOTOR_21_JOG_JOG = HOME_MIDL_SPEED		; Rev:2014/05/01 (Change velocity)
						ELSE									; not detected HOME-LS
							MOTOR_1_JOG      = HOME_FAST_SPEED
							MOTOR_2_JOG      = HOME_FAST_SPEED
							MOTOR_3_JOG      = HOME_FAST_SPEED
							MOTOR_4_JOG      = HOME_FAST_SPEED
							MOTOR_17_JOG     = HOME_FAST_SPEED
							MOTOR_18_JOG     = HOME_FAST_SPEED
							MOTOR_20_JOG     = HOME_FAST_SPEED
							MOTOR_21_JOG     = HOME_FAST_SPEED
							MOTOR_1_JOG_JOG  = HOME_FAST_SPEED
							MOTOR_2_JOG_JOG  = HOME_FAST_SPEED
							MOTOR_3_JOG_JOG  = HOME_FAST_SPEED
							MOTOR_4_JOG_JOG  = HOME_FAST_SPEED
							MOTOR_17_JOG_JOG = HOME_FAST_SPEED
							MOTOR_18_JOG_JOG = HOME_FAST_SPEED
							MOTOR_20_JOG_JOG = HOME_FAST_SPEED
							MOTOR_21_JOG_JOG = HOME_FAST_SPEED
						ENDIF

						SV_RDY_TIMER_FNC				; Wait (20msec)

						; ----------------
						; detected HOME-LS
						; HOME-LS -> OPEN DIR[SLOW]
						; ----------------
						IF( HOME_REG = LIMIT_ON )
; --------------
; Add:2014/09/27
IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )

P6753 = P6753 + 1		; for Debug

							HOME_DRV_STG_REG = HOME_EXEC_2
							HOME_DRV_PRG_REG = HOME_EXEC_2
							CMD"&1B22R"							; Execute a motion program (&1)

ELSE
ENDIF
; Add:2014/09/27
; --------------

						; --------------------
						; not detected HOME-LS
						; CLOSE DIR -> HOME-LS[FAST]
						; --------------------
						ELSE
; --------------
; Add:2014/09/27
IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )

P6754 = P6754 + 1		; for Debug

							HOME_DRV_STG_REG = HOME_EXEC_1
							HOME_DRV_PRG_REG = HOME_EXEC_1
							CMD"&1B21R"							; Execute a motion program (&1)

ELSE
ENDIF
; Add:2014/09/27
; --------------

						ENDIF

						IOC_GO_HOME_DRV_REG = 0

					ELSE		; if(not detected KILL LS)

P6755 = P6755 + 1		; for Debug

						DRIVE_MODE_REG      = DRIVE_STOP
						HOME_DRV_STG_REG    = HOME_EXEC_0
						HOME_DRV_PRG_REG    = HOME_EXEC_0
						IOC_GO_HOME_DRV_REG = 0

						SV_RDY_TIMER_FNC				; Wait (20msec)

						ENABLE PLC5
						DISABLE PLC13
						DISABLE PLC12
						DISABLE PLC11
						DISABLE PLC10

					ENDIF		; if(not detected KILL LS)
				ELSE		; if(GAP__INTLK_DIS)
				ENDIF		; if(GAP__INTLK_DIS)
			ELSE		; if(PROG_STP_STAT)
			ENDIF		; if(PROG_STP_STAT)
		ELSE		; if(STOP_AXIS)
		ENDIF		; if(STOP_AXIS)

		IOC_GO_HOME_DRV_REG = 0

	ELSE		; if(IOC_GO_HOME_DRV_REG)
	ENDIF		; if(IOC_GO_HOME_DRV_REG)


	; ------------
	; STOP DRIVING
	; ------------
	IF( IOC_SP_HOME_DRV_REG != 0 )
P6702 = P6702 + 1		; for Debug

		LOCK_1_STAT_REG = LOCK_OCCUR
		LOCK_2_STAT_REG = LOCK_OCCUR
		LOCK_3_STAT_REG = LOCK_OCCUR
		LOCK_4_STAT_REG = LOCK_OCCUR

;		IF( PRG_EXEC_REG = PRG_EXEC_JOG )
		IF( PRG_EXEC_REG > 0 )
			CMD"H"						; JOG
			HOLD_TIMER_FNC				; 300msec wait

			HLD_COUNT_REG = 1
			WHILE( HLD_COUNT_REG < 40 )
				IF( MOV_1_STAT_REG = MOVE_AXIS )
					HLD_COUNT_REG = HLD_COUNT_REG + 1
				ELSE
					HLD_COUNT_REG = 50
				ENDIF

				SV_RDY_TIMER_FNC
			ENDWHILE
		ELSE
		ENDIF

		CMD^A							; Abort
		KILL_TIMER_FNC					; 100msec wait

		CMD"#1J/#2J/#17J/#18J/"			; #1,#2(GAP UPPER) Servo Lock(stop)
		CMD"#3J/#4J/#20J/#21J/"			; #3,#4(GAP LOWER) Servo Lock(stop)

		KILL_TIMER_FNC					; 100msec wait
		CMD^K
		KILL_TIMER_FNC					; 100msec wait

		DRIVE_MODE_REG      = DRIVE_STOP
		HOME_DRV_STG_REG    = HOME_EXEC_0
		HOME_DRV_PRG_REG    = HOME_EXEC_0
		IOC_SP_HOME_DRV_REG = 0
		HOME_ADJ_PRG_REG    = HOME_EXEC_0

		MOTOR_1_JOG      = GAP__INTLK_SPD
		MOTOR_2_JOG      = GAP__INTLK_SPD
		MOTOR_3_JOG      = GAP__INTLK_SPD
		MOTOR_4_JOG      = GAP__INTLK_SPD
		MOTOR_17_JOG     = GAP__INTLK_SPD
		MOTOR_18_JOG     = GAP__INTLK_SPD
		MOTOR_20_JOG     = GAP__INTLK_SPD
		MOTOR_21_JOG     = GAP__INTLK_SPD
		MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
		MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
		MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
		MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
		MOTOR_17_JOG_JOG = GAP__INTLK_SPD
		MOTOR_18_JOG_JOG = GAP__INTLK_SPD
		MOTOR_20_JOG_JOG = GAP__INTLK_SPD
		MOTOR_21_JOG_JOG = GAP__INTLK_SPD

		SV_RDY_TIMER_FNC				; Wait (20msec)

		IOC_RCV_RDY_REG = RCV__READY_VAL	; ready 20150617

		ENABLE PLC5
		DISABLE PLC13
		DISABLE PLC12
		DISABLE PLC11
		DISABLE PLC10

	ELSE		; if(IOC_SP_HOME_DRV_REG)
	ENDIF		; if(IOC_SP_HOME_DRV_REG)


CLOSE


; ======================================
; ======================================
;	driving to home-position
;	(checking of Limit-Switch)
;		PLC11
; ======================================
; ======================================
OPEN PLC11 CLEAR

	; -------------------
	; HOME POSITION DRIVE
	; -------------------
	IF( DRIVE_MODE_REG = HME_DRIVE_MODE )
		; ----
		; Move
		; ----
		IF( MOV_1_STAT_REG = MOVE_AXIS AND MOV_2_STAT_REG = MOVE_AXIS AND MOV_3_STAT_REG = MOVE_AXIS AND MOV_4_STAT_REG = MOVE_AXIS )

			; ----------------
			; detected HOME-LS
			; ----------------
			IF( HOME_REG = LIMIT_ON AND HOME_DRV_STG_REG != HOME_EXEC_2 )
P6703 = P6703 + 1		; for Debug

;				IF( PRG_EXEC_REG = PRG_EXEC_JOG )
				IF( PRG_EXEC_REG > 0 )
					CMD"H"						; JOG
					HOLD_TIMER_FNC				; 300msec wait

					HLD_COUNT_REG = 1
					WHILE( HLD_COUNT_REG < 40 )
						IF( MOV_1_STAT_REG = MOVE_AXIS )
							HLD_COUNT_REG = HLD_COUNT_REG + 1
						ELSE
							HLD_COUNT_REG = 50
						ENDIF
						SV_RDY_TIMER_FNC
					ENDWHILE
				ELSE
				ENDIF

				CMD^A							; Abort
				KILL_TIMER_FNC					; 100msec wait

				CMD"#1J/#2J/#17J/#18J/"			; #1,#2(GAP UPPER) Servo Lock(stop)
				CMD"#3J/#4J/#20J/#21J/"			; #3,#4(GAP LOWER) Servo Lock(stop)

				KILL_TIMER_FNC					; 100msec wait

			ELSE			; if(HOME_REG)
			ENDIF			; if(HOME_REG)
		ELSE			; if(MOVE_AXIS)
		ENDIF			; if(MOVE_AXIS)

		; ----
		; Stop
		; ----
		IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
			; ----------------
			; detected HOME-LS
			; ----------------
			IF( HOME_REG = LIMIT_ON AND HOME_DRV_STG_REG != HOME_EXEC_2 )
				; --------------------------
				; CLOSE DIR -> HOME-LS[FAST]
				; --------------------------
				IF( HOME_DRV_STG_REG = HOME_EXEC_1 )
P6704 = P6704 + 1		; for Debug

					GAP__BRK_ON_REG = GAP__BRK_ON_INI		; clear count(Add 2013/09/30)
					GAP__BRAKE_REG  = SERVO_RDY_OFF
					GAP__BRAKE_STAT = GAP__BRAKE_REG


					MOTOR_1_JOG      = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_2_JOG      = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_3_JOG      = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_4_JOG      = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_17_JOG     = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_18_JOG     = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_20_JOG     = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_21_JOG     = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_1_JOG_JOG  = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_2_JOG_JOG  = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_3_JOG_JOG  = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_4_JOG_JOG  = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_17_JOG_JOG = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_18_JOG_JOG = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_20_JOG_JOG = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)
					MOTOR_21_JOG_JOG = HOME_MIDL_SPEED		; Rev:2014/05/01(Change velocity)

					SV_RDY_TIMER_FNC				; Wait (20msec)

; --------------
; Add:2014/09/27
IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )

P6750 = P6750 + 1		; for Debug

					HOME_DRV_STG_REG = HOME_EXEC_2
					HOME_DRV_PRG_REG = HOME_EXEC_2
					CMD"&1B22R"					; Execute a motion program (&1)
ELSE
ENDIF
; Add:2014/09/27
; --------------

				ELSE			; if(HOME_EXEC_1)
				ENDIF			; if(HOME_EXEC_1)

				; ------
				; finish
				; ------
				IF( HOME_DRV_STG_REG = HOME_EXEC_3 )
P6705 = P6705 + 1		; for Debug

					IF( HOME_ADJ_PRG_REG = HOME_EXEC_0 )
						HOME_ADJ_PRG_REG = -1
						ENABLE PLC12			; adjusting of home-position
						ENABLE PLC13			; checking of home-ls
					ELSE
					ENDIF

;					ENABLE PLC5
					DISABLE PLC10
					DISABLE PLC11

				ELSE			; if(HOME_EXEC_3)
				ENDIF			; if(HOME_EXEC_3)
			ELSE			; if(HOME_REG)
			ENDIF			; if(HOME_REG)
		ELSE			; if(STOP_AXIS)
		ENDIF			; if(STOP_AXIS)

		; -------------------------
		; HOME-LS -> OPEN DIR[SLOW]
		; -------------------------
		IF( HOME_REG = LIMIT_OFF AND HOME_DRV_STG_REG = HOME_EXEC_2 )
			IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
P6706 = P6706 + 1		; for Debug

				CMD^A							; Abort
				KILL_TIMER_FNC					; 100msec wait

				CMD"#1J/#2J/#17J/#18J/"			; #1,#2(GAP UPPER) Servo Lock(stop)
				CMD"#3J/#4J/#20J/#21J/"			; #3,#4(GAP LOWER) Servo Lock(stop)

				KILL_TIMER_FNC					; 100msec wait

				GAP__BRK_ON_REG = GAP__BRK_ON_INI		; clear count(Add 2013/09/30)
				GAP__BRAKE_REG  = SERVO_RDY_OFF
				GAP__BRAKE_STAT = GAP__BRAKE_REG

				MOTOR_1_JOG      = HOME_SLOW_SPEED
				MOTOR_2_JOG      = HOME_SLOW_SPEED
				MOTOR_3_JOG      = HOME_SLOW_SPEED
				MOTOR_4_JOG      = HOME_SLOW_SPEED
				MOTOR_17_JOG     = HOME_SLOW_SPEED
				MOTOR_18_JOG     = HOME_SLOW_SPEED
				MOTOR_20_JOG     = HOME_SLOW_SPEED
				MOTOR_21_JOG     = HOME_SLOW_SPEED
				MOTOR_1_JOG_JOG  = HOME_SLOW_SPEED
				MOTOR_2_JOG_JOG  = HOME_SLOW_SPEED
				MOTOR_3_JOG_JOG  = HOME_SLOW_SPEED
				MOTOR_4_JOG_JOG  = HOME_SLOW_SPEED
				MOTOR_17_JOG_JOG = HOME_SLOW_SPEED
				MOTOR_18_JOG_JOG = HOME_SLOW_SPEED
				MOTOR_20_JOG_JOG = HOME_SLOW_SPEED
				MOTOR_21_JOG_JOG = HOME_SLOW_SPEED

				SV_RDY_TIMER_FNC				; Wait (20msec)

; --------------
; Add:2014/09/27
IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )

P6751 = P6751 + 1		; for Debug

				HOME_DRV_STG_REG = HOME_EXEC_3
				HOME_DRV_PRG_REG = HOME_EXEC_3
				CMD"&1B23R"						; Execute a motion program (&1)

ELSE
ENDIF
; Add:2014/09/27
; --------------

			ELSE			; if(STOP_EXIS)
			ENDIF			; if(STOP_AXIS)
		ELSE			; if(HOME_REG)
			IF( HOME_REG = LIMIT_ON AND HOME_DRV_STG_REG = HOME_EXEC_2 )
P6770 = P6770 + 1		; for Debug

				SRDY_1_OUT = SERVO_RDY_OFF				; servo-off
				SRDY_2_OUT = SERVO_RDY_OFF				; servo-off
				SRDY_3_OUT = SERVO_RDY_OFF				; servo-off
				SRDY_4_OUT = SERVO_RDY_OFF				; servo-off

				KILL_TIMER_FNC							; 100msec wait
				CMD^K									; kill-all
				KILL_TIMER_FNC							; 100msec wait

				; --------------------
				; Restore velocity setting
				; --------------------
				MOTOR_1_JOG      = GAP__INTLK_SPD
				MOTOR_2_JOG      = GAP__INTLK_SPD
				MOTOR_3_JOG      = GAP__INTLK_SPD
				MOTOR_4_JOG      = GAP__INTLK_SPD
				MOTOR_17_JOG     = GAP__INTLK_SPD
				MOTOR_18_JOG     = GAP__INTLK_SPD
				MOTOR_20_JOG     = GAP__INTLK_SPD
				MOTOR_21_JOG     = GAP__INTLK_SPD
				MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
				MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
				MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
				MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
				MOTOR_17_JOG_JOG = GAP__INTLK_SPD
				MOTOR_18_JOG_JOG = GAP__INTLK_SPD
				MOTOR_20_JOG_JOG = GAP__INTLK_SPD
				MOTOR_21_JOG_JOG = GAP__INTLK_SPD

				SV_RDY_TIMER_FNC					; Wait (20msec)

				DRIVE_MODE_REG   = DRIVE_STOP
				HOME_DRV_STG_REG = HOME_EXEC_0
				HOME_DRV_PRG_REG = HOME_EXEC_0
				HOME_ADJ_PRG_REG = HOME_EXEC_0

				IOC_RCV_RDY_REG = RCV__READY_VAL		; ready 20150617

				ENABLE PLC5
				DISABLE PLC10
				DISABLE PLC11
				DISABLE PLC12
				DISABLE PLC13

			ELSE			; if(STOP_EXIS)
			ENDIF			; if(STOP_AXIS)

		ENDIF			; if(HOME_REG)

	ELSE			; if(HME_DRIVE_MODE)
	ENDIF			; if(HME_DRIVE_MODE)


CLOSE



; ======================================
; ======================================
;	adjusting of home-position
;		PLC12
; ======================================
; ======================================
OPEN PLC12 CLEAR


	IF( HOME_ADJ_PRG_REG = -1 )
		; ----------------
		; Servo OFF & KILL
		; ----------------
		CMD^A
		BRK_OFF_TIMER_FNC				; Wait (100msec)
		CMD"#1J/#2J/#17J/#18J/"			; Add 2014/05/01
		CMD"#3J/#4J/#20J/#21J/"			; Add 2014/05/01
		BRK_OFF_TIMER_FNC				; Wait (100msec)
		CMD^K
;		BRK_OFF_TIMER_FNC				; Wait (100msec) comment out 20150529

		SRDY_1_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
		SRDY_2_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
		SRDY_3_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)
		SRDY_4_OUT      = SERVO_RDY_OFF		; servo-off(brake-on)

		GAP__BRK_ON_REG = GAP__BRK_ON_INI	; clear count
		GAP__BRAKE_REG  = SERVO_RDY__ON
		GAP__BRAKE_STAT = GAP__BRAKE_REG

		LOCK_1_STAT_REG = UNLOCK_OCCUR
		LOCK_2_STAT_REG = UNLOCK_OCCUR
		LOCK_3_STAT_REG = UNLOCK_OCCUR
		LOCK_4_STAT_REG = UNLOCK_OCCUR


		; ------------------------
		; Restore velocity setting
		; ------------------------
		MOTOR_1_JOG      = HOME_SLOW_SPEED
		MOTOR_2_JOG      = HOME_SLOW_SPEED
		MOTOR_3_JOG      = HOME_SLOW_SPEED
		MOTOR_4_JOG      = HOME_SLOW_SPEED
		MOTOR_17_JOG     = HOME_SLOW_SPEED
		MOTOR_18_JOG     = HOME_SLOW_SPEED
		MOTOR_20_JOG     = HOME_SLOW_SPEED
		MOTOR_21_JOG     = HOME_SLOW_SPEED
		MOTOR_1_JOG_JOG  = HOME_SLOW_SPEED
		MOTOR_2_JOG_JOG  = HOME_SLOW_SPEED
		MOTOR_3_JOG_JOG  = HOME_SLOW_SPEED
		MOTOR_4_JOG_JOG  = HOME_SLOW_SPEED
		MOTOR_17_JOG_JOG = HOME_SLOW_SPEED
		MOTOR_18_JOG_JOG = HOME_SLOW_SPEED
		MOTOR_20_JOG_JOG = HOME_SLOW_SPEED
		MOTOR_21_JOG_JOG = HOME_SLOW_SPEED

		SV_RDY_TIMER_FNC					; Wait (20msec)

		; ----------------------------
		; Change into separate mode from synchronous mode
		; ----------------------------
; --------------
; Add:2014/11/20
		COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
		COMP_01_VAL_REG = 0
		COMP_17_VAL_REG = 0
		COMP_03_VAL_REG = 0
		COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------
		; --------------------------------------
		;	X axis definition
		; --------------------------------------
		; --------------------------------------
		;	#17 I variables setting
		; --------------------------------------
		I1700 = MOTOR_INACTV				; Motor Inactivation
		I1702 = DAC_OFFSET_CH18_REG			; Command Output Address
		I1706 = MNT_MOTOR_FOLW				; Position Following Enable and Mode
	
		; --------------------------------------
		;	#1 I variables setting
		; --------------------------------------
		I0102 = DAC_OUTPUT_CH01_REG			; Command Output Address
		I0103 = ROT_ENC_1					; Position Loop Feedback Address
		I0104 = ROT_ENC_1					; Velocity Loop Feedback Address
		I0106 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

		I0108 = MNT_POS_CNV_RATE			; Position Scale Factor
		I0109 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor

		I0124 = MNT_FLAG_VAL				; Flag Mode Control

		I0130 = (PROPO_GAIN_UP)				; PID Proportional Gain
;		I0131 = DERIV_GAIN_UP				; PID Derivative Gain
;		I0132 = SPEED_GAIN_UP				; PID Velocity Feedforward Gain
;		I0133 = INTEG_GAIN_UP				; PID Integral Gain
;		I0135 = ACC_FF_GAIN_UP				; PID Acceleration Feedforward Gain


		; --------------------------------------
		;	A axis definition
		; --------------------------------------
		; --------------------------------------
		;	#18 I variables setting
		; --------------------------------------
		I1800 = MOTOR_INACTV				; Motor Inactivation
		I1802 = DAC_OFFSET_CH17_REG			; Command Output Address
		I1806 = MNT_MOTOR_FOLW				; Position Following Enable and Mode
		; --------------------------------------
		;	#2 I variables 
		; --------------------------------------
		I0202 = DAC_OUTPUT_CH02_REG			; Command Output Address
		I0203 = ROT_ENC_2					; Position Loop Feedback Address
		I0204 = ROT_ENC_2					; Velocity Loop Feedback Address
		I0206 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

		I0208 = MNT_POS_CNV_RATE			; Position Scale Factor
		I0209 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor

		I0224 = MNT_FLAG_VAL				; Flag Mode Control

		I0230 = (PROPO_GAIN_UP)				; PID Derivative Gain
;		I0231 = DERIV_GAIN_UP				; PID Derivative Gain
;		I0232 = SPEED_GAIN_UP				; PID Velocity Feedforward Gain
;		I0233 = INTEG_GAIN_UP				; PID Integral Gain
;		I0235 = ACC_FF_GAIN_UP				; PID Acceleration Feedforward Gain


		; --------------------------------------
		;	Y axis definition
		; --------------------------------------
		; --------------------------------------
		;	#20 I variables setting
		; --------------------------------------
		I2000 = MOTOR_INACTV				; Motor Inactivation
		I2002 = DAC_OFFSET_CH21_REG			; Command Output Address
		I2006 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

		; --------------------------------------
		;	#3 I variables setting
		; --------------------------------------
		I0302 = DAC_OUTPUT_CH03_REG			; Command Output Address
		I0303 = ROT_ENC_3					; Position Loop Feedback Address
		I0304 = ROT_ENC_3					; Velocity Loop Feedback Address
		I0306 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

		I0308 = MNT_POS_CNV_RATE			; Position Scale Factor
		I0309 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor

		I0324 = MNT_FLAG_VAL				; Flag Mode Control

		I0330 = (PROPO_GAIN_DN)				; PID Proportional Gain
;		I0331 = DERIV_GAIN_DN				; PID Derivative Gain
;		I0332 = SPEED_GAIN_DN				; PID Velocity Feedforward Gain
;		I0333 = INTEG_GAIN_DN				; PID Integral Gain
;		I0335 = ACC_FF_GAIN_DN				; PID Acceleration Feedforward Gain

		; --------------------------------------
		;	B axis definition
		; --------------------------------------
		; --------------------------------------
		;	#21 I variables setting
		; --------------------------------------
		I2100 = MOTOR_INACTV				; Motor Inactivation
		I2102 = DAC_OFFSET_CH20_REG			; Command Output Address
		I2106 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

		; --------------------------------------
		;	#4 I variables setting
		; --------------------------------------
		I0402 = DAC_OUTPUT_CH04_REG			; Command Output Address
		I0403 = ROT_ENC_4					; Position Loop Feedback Address
		I0404 = ROT_ENC_4					; Velocity Loop Feedback Address
		I0406 = MNT_MOTOR_FOLW				; Position Following Enable and Mode

		I0408 = MNT_POS_CNV_RATE			; Position Scale Factor
		I0409 = MNT_SPD_CNV_RATE			; Velocity-Loop Scale Factor

		I0424 = MNT_FLAG_VAL				; Flag Mode Control

		I0430 = (PROPO_GAIN_DN)				; PID Proportional Gain
;		I0431 = DERIV_GAIN_DN				; PID Derivative Gain
;		I0432 = SPEED_GAIN_DN				; PID Velocity Feedforward Gain
;		I0433 = INTEG_GAIN_DN				; PID Integral Gain
;		I0435 = ACC_FF_GAIN_DN				; PID Acceleration Feedforward Gain

		SV_RDY_TIMER_FNC					; Wait (20msec)

; --------------
; Add:2015/05/29 remedy for stack

		SV_RDY_TIMER_FNC

		TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
		TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
		TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

		M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
		M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
		M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
		M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

		M1762 = M162
		M1862 = M262
		M2062 = M362
		M2162 = M462

		SV_RDY_TIMER_FNC

; Add:2015/05/29
; --------------

P6730 = P6730 + 1		; for Debug

		IF( MOT_SRDY_1_REG = SERVO_RDY__ON AND MOT_SRDY_2_REG = SERVO_RDY__ON AND MOT_SRDY_3_REG = SERVO_RDY__ON AND MOT_SRDY_4_REG = SERVO_RDY__ON )
			TMP9_REG = 0
			TMP9_REG = 0

			; -------
			; MOT[#1]
			; -------
			IF( SRDY_1_OUT = SERVO_RDY_OFF )
				TMP9_REG   = 1
				SRDY_1_OUT = SERVO_RDY__ON
				CMD"#1J/"					; Servo-Lock
			ELSE
			ENDIF
			; -------
			; MOT[#2]
			; -------
			IF( SRDY_2_OUT = SERVO_RDY_OFF )
				TMP9_REG   = 1
				SRDY_2_OUT = SERVO_RDY__ON
				CMD"#2J/"					; Servo-Lock
			ELSE
			ENDIF
			; -------
			; MOT[#3]
			; -------
			IF( SRDY_3_OUT = SERVO_RDY_OFF )
				TMP9_REG   = 1
				SRDY_3_OUT = SERVO_RDY__ON
				CMD"#3J/"					; Servo-Lock
			ELSE
			ENDIF
			; -------
			; MOT[#4]
			; -------
			IF( SRDY_4_OUT = SERVO_RDY_OFF )
				TMP9_REG   = 1
				SRDY_4_OUT = SERVO_RDY__ON
				CMD"#4J/"					; Servo-Lock
			ELSE
			ENDIF

			IF( TMP9_REG = 1 )
				SV_RDY_TIMER_FNC				; Wait (20msec)

				GAP__BRAKE_REG  = SERVO_RDY_OFF
				GAP__BRAKE_STAT = GAP__BRAKE_REG

				LOCK_1_STAT_REG = LOCK_OCCUR
				LOCK_2_STAT_REG = LOCK_OCCUR
				LOCK_3_STAT_REG = LOCK_OCCUR
				LOCK_4_STAT_REG = LOCK_OCCUR

				BRK_OFF_TIMER_FNC				; Wait (100msec)
			ELSE
			ENDIF
		ELSE									; if(MOT_SRDY_xx_REG)
		ENDIF									; if(MOT_SRDY_xx_REG)


		; ----------------------
		; not detected HOME_1-LS
		; ----------------------
		IF( HOME_1_REG = LIMIT_OFF )
			IF( MOV_1_STAT_REG = STOP_AXIS )
P6707 = P6707 + 1		; for Debug
				M172 = -1 * HOME_ADJ_DRV * MOT_LIN_ROT_CNV	; Calculate move distance
P6731 = M172			; for Debug
;				SV_RDY_TIMER_FNC							; Wait (20msec)
				BRK_OFF_TIMER_FNC							; Wait (100msec)
				CMD"#1J^*"									; adjusting MOT[#1]
			ELSE
			ENDIF
		ELSE
		ENDIF

		; ----------------------
		; not detected HOME_2-LS
		; ----------------------
		IF( HOME_2_REG = LIMIT_OFF )
			IF( MOV_2_STAT_REG = STOP_AXIS )
P6708 = P6708 + 1		; for Debug
				M272 = -1 * HOME_ADJ_DRV * MOT_LIN_ROT_CNV	; Calculate move distance
P6732 = M272			; for Debug
;				SV_RDY_TIMER_FNC							; Wait (20msec)
				BRK_OFF_TIMER_FNC							; Wait (100msec)
				CMD"#2J^*"									; adjusting MOT[#2]
			ELSE
			ENDIF
		ELSE
		ENDIF

		; ----------------------
		; not detected HOME_3-LS
		; ----------------------
		IF( HOME_3_REG = LIMIT_OFF )
			IF( MOV_3_STAT_REG = STOP_AXIS )
P6709 = P6709 + 1		; for Debug
				M372 = -1 * HOME_ADJ_DRV * MOT_LIN_ROT_CNV	; Calculate move distance
P6733 = M372			; for Debug
;				SV_RDY_TIMER_FNC							; Wait (20msec)
				BRK_OFF_TIMER_FNC							; Wait (100msec)
				CMD"#3J^*"									; adjusting MOT[#3]
			ELSE
			ENDIF
		ELSE
		ENDIF

		; ----------------------
		; not detected HOME_4-LS
		; ----------------------
		IF( HOME_4_REG = LIMIT_OFF )
			IF( MOV_4_STAT_REG = STOP_AXIS )
P6710 = P6710 + 1		; for Debug
				M472 = -1 * HOME_ADJ_DRV * MOT_LIN_ROT_CNV	; Calculate move distance
P6734 = M472			; for Debug
;				SV_RDY_TIMER_FNC							; Wait (20msec)
				BRK_OFF_TIMER_FNC							; Wait (100msec)
				CMD"#4J^*"									; adjusting MOT[#4]
			ELSE
			ENDIF
		ELSE
		ENDIF

		HOME_ADJ_PRG_REG = 1

;		DISABLE PLC12			; Del:2014/05/01

	ELSE		; if(HOME_ADJ_PRG_REG=-1)
	ENDIF		; if(HOME_ADJ_PRG_REG=-1)

CLOSE



; ======================================
; ======================================
;	adjusting home-position
;		PLC13
; ======================================
; ======================================
OPEN PLC13 CLEAR


;	SV_RDY_TIMER_FNC							; Wait (20msec) ->Del:2014/05/01

	IF( HOME_ADJ_PRG_REG = 1 )
		; ------------------
		; detected HOME_1-LS
		; ------------------
		IF( HOME_1_REG = LIMIT_ON )
			IF( MOV_1_STAT_REG = MOVE_AXIS )
P6725 = P6725 + 1		; for Debug
				CMD"#1J/"								; servo-lock
			ELSE
			ENDIF
		ELSE
		ENDIF

		; ------------------
		; detected HOME_2-LS
		; ------------------
		IF( HOME_2_REG = LIMIT_ON )
			IF( MOV_2_STAT_REG = MOVE_AXIS )
P6726 = P6726 + 1		; for Debug
				CMD"#2J/"								; servo-lock
			ELSE
			ENDIF
		ELSE
		ENDIF

		; ------------------
		; detected HOME_3-LS
		; ------------------
		IF( HOME_3_REG = LIMIT_ON )
			IF( MOV_3_STAT_REG = MOVE_AXIS )
P6727 = P6727 + 1		; for Debug
				CMD"#3J/"								; servo-lock
			ELSE
			ENDIF
		ELSE
		ENDIF

		; ------------------
		; detected HOME_4-LS
		; ------------------
		IF( HOME_4_REG = LIMIT_ON )
			IF( MOV_4_STAT_REG = MOVE_AXIS )
P6728 = P6728 + 1		; for Debug
				CMD"#4J/"								; servo-lock
			ELSE
			ENDIF
		ELSE
		ENDIF

		; ------------------------
		; receive command from IOC
		; ------------------------
		IF( IOC_GO_HOME_DRV_REG != 0 OR IOC_SP_HOME_DRV_REG != 0 )
			; ----------
			; HOME DRIVE
			; ----------
			IF( IOC_GO_HOME_DRV_REG != 0 )
				IOC_GO_HOME_DRV_REG = 0
			ELSE
			ENDIF

			; ------------
			; STOP DRIVING
			; ------------
			IF( IOC_SP_HOME_DRV_REG != 0 )		; Add:2014/05/28
				IOC_SP_HOME_DRV_REG = 0

				; ----------------
				; motor[#1] moving
				; ----------------
				IF( MOV_1_STAT_REG = MOVE_AXIS )
					CMD"#1J/"								; servo-lock
				ELSE
				ENDIF
				; ----------------
				; motor[#2] moving
				; ----------------
				IF( MOV_2_STAT_REG = MOVE_AXIS )
					CMD"#2J/"								; servo-lock
				ELSE
				ENDIF
				; ----------------
				; motor[#3] moving
				; ----------------
				IF( MOV_3_STAT_REG = MOVE_AXIS )
					CMD"#3J/"								; servo-lock
				ELSE
				ENDIF
				; ----------------
				; motor[#4] moving
				; ----------------
				IF( MOV_4_STAT_REG = MOVE_AXIS )
					CMD"#4J/"								; servo-lock
				ELSE
				ENDIF

			ELSE		; if(IOC_SP_HOME_DRV_REG)
			ENDIF		; if(IOC_SP_HOME_DRV_REG)
		ELSE
		ENDIF


		IF( MOV_1_STAT_REG = MOVE_AXIS OR MOV_2_STAT_REG = MOVE_AXIS OR MOV_3_STAT_REG = MOVE_AXIS OR MOV_4_STAT_REG = MOVE_AXIS )
P6712 = P6712 + 1		; for Debug
		ELSE
		ENDIF

		; ------------------
		; KILL-ALL if all axes stop 
		; ------------------
		IF( MOV_1_STAT_REG = STOP_AXIS AND MOV_2_STAT_REG = STOP_AXIS AND MOV_3_STAT_REG = STOP_AXIS AND MOV_4_STAT_REG = STOP_AXIS )
P6711 = P6711 + 1		; for Debug

			CMD^A									; Abort
			KILL_TIMER_FNC							; 100msec wait
			CMD"#1J/#2J/#3J/#4J/"								; servo-lock
			KILL_TIMER_FNC							; 100msec wait
			CMD^K									; kill-all
;			KILL_TIMER_FNC							; 100msec wait comment out 20150529

			SRDY_1_OUT = SERVO_RDY_OFF				; servo-off
			SRDY_2_OUT = SERVO_RDY_OFF				; servo-off
			SRDY_3_OUT = SERVO_RDY_OFF				; servo-off
			SRDY_4_OUT = SERVO_RDY_OFF				; servo-off

			; --------------------
			; Restore velocity setting
			; --------------------
			MOTOR_1_JOG      = GAP__INTLK_SPD
			MOTOR_2_JOG      = GAP__INTLK_SPD
			MOTOR_3_JOG      = GAP__INTLK_SPD
			MOTOR_4_JOG      = GAP__INTLK_SPD
			MOTOR_17_JOG     = GAP__INTLK_SPD
			MOTOR_18_JOG     = GAP__INTLK_SPD
			MOTOR_20_JOG     = GAP__INTLK_SPD
			MOTOR_21_JOG     = GAP__INTLK_SPD
			MOTOR_1_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_2_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_3_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_4_JOG_JOG  = GAP__INTLK_SPD
			MOTOR_17_JOG_JOG = GAP__INTLK_SPD
			MOTOR_18_JOG_JOG = GAP__INTLK_SPD
			MOTOR_20_JOG_JOG = GAP__INTLK_SPD
			MOTOR_21_JOG_JOG = GAP__INTLK_SPD

			SV_RDY_TIMER_FNC					; Wait (20msec)

			; ------------------------------
			; Change into synchronous mode from separate mode
			; ------------------------------
; --------------
; Add:2014/11/20
			COMP_FLAG_REG   = COMP_SCAN_DISABLE		; Disable skew compensation
			COMP_01_VAL_REG = 0
			COMP_17_VAL_REG = 0
			COMP_03_VAL_REG = 0
			COMP_20_VAL_REG = 0
; Add:2014/11/20
; --------------
			; --------------------------------------
			;	X axis definition
			; --------------------------------------
			; --------------------------------------
			;	#17 I variables setting
			; --------------------------------------
			I1700 = MOTOR_ACTIVE				; Motor Activation
			I1702 = DAC_OUTPUT_CH01_REG			; Command Output Address
			I1706 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#1 I variables setting
			; --------------------------------------
			I0102 = DAC_OFFSET_CH18_REG			; Command Output Address
			I0103 = BISS_ADD_1_2				; Position Loop Feedback Address
			I0104 = BISS_ADD_1_2				; Velocity Loop Feedback Address
			I0106 = MOTOR_FOLW					; Position Following Enable and Mode

			I0108 = I1708						; Position Scale Factor
			I0109 = I1708						; Velocity-Loop Scale Factor

			I0124 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0130 = (PROPO_GAIN_UP)				; PID Proportional Gain

			; --------------------------------------
			;	A axis definition
			; --------------------------------------
			; --------------------------------------
			;	#18 I variables setting
			; --------------------------------------
			I1800 = MOTOR_ACTIVE				; Motor Inactivation
			I1802 = DAC_OUTPUT_CH02_REG			; Command Output Address
			I1806 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#2 I variables setting
			; --------------------------------------
			I0202 = DAC_OFFSET_CH17_REG			; Command Output Address
			I0203 = BISS_SUB_1_2				; Position Loop Feedback Address
			I0204 = BISS_SUB_1_2				; Velocity Loop Feedback Address
			I0206 = MOTOR_FOLW					; Position Following Enable and Mode

			I0208 = I1708						; Position Scale Factor
			I0209 = I1708						; Velocity-Loop Scale Factor

			I0224 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0230 = (2*PROPO_GAIN_UP)			; PID Proportional Gain

			; --------------------------------------
			;	Y axis definition
			; --------------------------------------
			; --------------------------------------
			;	#20 I variables setting
			; --------------------------------------
			I2000 = MOTOR_ACTIVE				; Motor Activation
			I2002 = DAC_OUTPUT_CH03_REG			; Command Output Address
			I2006 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#3 I variables setting
			; --------------------------------------
			I0302 = DAC_OFFSET_CH21_REG			; Command Output Address
			I0303 = BISS_ADD_3_4				; Position Loop Feedback Address
			I0304 = BISS_ADD_3_4				; Velocity Loop Feedback Address
			I0306 = MOTOR_FOLW					; Position Following Enable and Mode

			I0308 = I2008						; Position Scale Factor
			I0309 = I2008						; Velocity-Loop Scale Factor

			I0324 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0330 = (PROPO_GAIN_DN)				; PID Proportional Gain


			; --------------------------------------
			;	B axis definition
			; --------------------------------------
			; --------------------------------------
			;	#21 I variables setting
			; --------------------------------------
			I2100 = MOTOR_ACTIVE				; Motor Activation
			I2102 = DAC_OUTPUT_CH04_REG			; Command Output Address
			I2106 = MOTOR_FOLW					; Position Following Enable and Mode

			; --------------------------------------
			;	#4 I variables setting
			; --------------------------------------
			I0402 = DAC_OFFSET_CH20_REG			; Command Output Address
			I0403 = BISS_SUB_3_4				; Position Loop Feedback Address
			I0404 = BISS_SUB_3_4				; Velocity Loop Feedback Address
			I0406 = MOTOR_FOLW					; Position Following Enable and Mode

			I0408 = I2008						; Position Scale Factor
			I0409 = I2008						; Velocity-Loop Scale Factor

			I0424 = MOTOR_FLAG_VAL				; Flag Mode Control

			I0430 = (2*PROPO_GAIN_DN)			; PID Proportional Gain

			SV_RDY_TIMER_FNC					; Wait (20msec)

; --------------
; Add:2015/05/29 remedy for stack

		SV_RDY_TIMER_FNC

		TMP4_REG = ( MOT_1_OFFSET_REG + MOT_2_OFFSET_REG + MOT_3_OFFSET_REG + MOT_4_OFFSET_REG )
		TMP5_REG = ( MOT_1_POS_REG + MOT_2_POS_REG + MOT_3_POS_REG + MOT_4_POS_REG )
		TMP6_REG = ( TMP4_REG - TMP5_REG ) / 2

		M162 = TMP6_REG * MOT_LIN_ROT_CNV * (I0108 * 32)
		M262 = TMP6_REG * MOT_LIN_ROT_CNV * (I0208 * 32)
		M362 = TMP6_REG * MOT_LIN_ROT_CNV * (I0308 * 32)
		M462 = TMP6_REG * MOT_LIN_ROT_CNV * (I0408 * 32)

		M1762 = M162
		M1862 = M262
		M2062 = M362
		M2162 = M462

		SV_RDY_TIMER_FNC

; Add:2015/05/29
; --------------
			DRIVE_MODE_REG   = DRIVE_STOP
			HOME_DRV_STG_REG = HOME_EXEC_0
			HOME_DRV_PRG_REG = HOME_EXEC_0
			HOME_ADJ_PRG_REG = HOME_EXEC_0

;			IF( M1762 != M162 )
;				M1762 = M162
;			ELSE
;			ENDIF
;			IF( M1862 != M262 )
;				M1862 = M262
;			ELSE
;			ENDIF
;			IF( M2062 != M362 )
;				M2062 = M362
;			ELSE
;			ENDIF
;			IF( M2162 != M462 )
;				M2162 = M462
;			ELSE
;			ENDIF

			IOC_RCV_RDY_REG = RCV__READY_VAL		; ready 20150617

			ENABLE PLC5
			DISABLE PLC10
			DISABLE PLC11
			DISABLE PLC12
			DISABLE PLC13

		ELSE		; if(STOP_AXIS)
		ENDIF		; if(STOP_AXIS)
	ELSE		; if(HOME_ADJ_PRG_REG=1)
	ENDIF		; if(HOME_ADJ_PRG_REG=1)

CLOSE


